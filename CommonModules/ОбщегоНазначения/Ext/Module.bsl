////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПИСИ НАБОРОВ ЗАПИСЕЙ РЕГИСТРОВ, КОНСТАНТ

// Проверяет значения констант из коллекции с текущим значением в ИБ,
// не проверяется для типа данных ХранилищеЗначений
// 
// Параметры: 
//  КоллекцияКонстантДляПроверки  - структура
//									ключ 		- строка, имя константы
//									значение 	- значение константы
//
// Возвращаемое значение:
//  Массив констант значение которых изменилось по сравнению с переданной коллекцией
//
Функция СоздатьМассивИзмененныхКонстант(КоллекцияКонстантДляПроверки) Экспорт
	
	МассивИзмененныхКонстант = Новый Массив;
	
	Для каждого ЭлементКоллекции Из КоллекцияКонстантДляПроверки Цикл
		
		ИмяКонстанты 	  = ЭлементКоллекции.Ключ;
		ЗначениеКонстанты = ЭлементКоллекции.Значение;
		
		ТекущееЗначение   = Константы[ИмяКонстанты].Получить();
		Если  ТипЗнч(ТекущееЗначение) = Тип("ХранилищеЗначения") Тогда
			// не сравниваем значения констант, у которых Тип данных - Хранилище значений
			Продолжить;
		КонецЕсли;	
		
		Если ЗначениеКонстанты <> ТекущееЗначение Тогда
			МассивИзмененныхКонстант.Добавить(Метаданные.Константы[ИмяКонстанты]);
		КонецЕсли;
	
	КонецЦикла;
	
	Возврат МассивИзмененныхКонстант;
	
КонецФункции

// Функция выполняет запись переданного набора записей и 
// формирует сообщение об ошибке, если не удалось записать набор
//
// Параметры
//  НаборЗаписей  - набор записей регистра сведений, который необходимо записать
//
// Возвращаемое значение:
//   Булево   - Истина, когда набор записей записан
//
Функция ЗаписатьНабор(НаборЗаписей) Экспорт

	Попытка
		НаборЗаписей.Записать();
	Исключение
		ВывестиИнформациюОбОшибке(ПолучитьПричинуОшибки(ИнформацияОбОшибке()).Описание);
		Если ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		Возврат Ложь;
	КонецПопытки;

	Возврат Истина;
	
КонецФункции

 ////////////////////////////////////////////////////////////////////////////////
// ЗАПОЛНЕНИЕ НАЧИСЛЕНИЙ И УДЕРЖАНИЙ

Функция ВалютаПоказателяИмяПоляЗапроса() Экспорт
	//
	//ИмяПоляЗапроса = ЗаполнениеДокументовПереопределяемый.ВалютаПоказателяИмяПоляЗапроса();
	//
	//Возврат ?(ЗначениеЗаполнено(ИмяПоляЗапроса), ИмяПоляЗапроса, "Валюта");
	//
	Возврат "Валюта";

КонецФункции


// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ
//

// Получает первичную информацию об ошибке
// Параметры:
//	ИнформацияОбОшибке - информация об ошибке
// Возвращает:
//	Информацию об ошибке, которая является первопричиной возникновения переданной ИнформацияОбОшибке
//  Если ошибка первичная, то возвращается сама ошибка, переданная в качестве параметра
Функция ПолучитьПричинуОшибки(ИнформацияОбОшибке) Экспорт
	ПричинаОшибки = ИнформацияОбОшибке.Причина;
	Если ПричинаОшибки = НеОпределено Тогда
		Возврат ИнформацияОбОшибке;
	КонецЕсли;
	Пока ПричинаОшибки.Причина <> НеОпределено Цикл
		ПричинаОшибки = ПричинаОшибки.Причина;
	КонецЦикла;
	Возврат ПричинаОшибки;
	
КонецФункции



// Функция выделяет первое слово в предложении
Функция ВыделитьСлово(ИсходнаяСтрока) Экспорт
	
	Буфер = СокрЛ(ИсходнаяСтрока);
	ПозицияПослПробела = Найти(Буфер, " ");

	Если ПозицияПослПробела = 0 Тогда
		ИсходнаяСтрока = "";
		Возврат Буфер;
	КонецЕсли;
	
	ВыделенноеСлово = СокрЛП(Лев(Буфер, ПозицияПослПробела));
	ИсходнаяСтрока = Сред(ИсходнаяСтрока, ПозицияПослПробела + 1);
	
	Возврат ВыделенноеСлово;
	
КонецФункции

// Функция преобразует строку к множественному числу
//
// Параметры: 
//  Слово1 - форма слова в ед числе      ("шкаф")
//  Слово2 - форма слова для числит 2-4  ("шкафа")
//  Слово3 - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - целое число
//
// Возвращаемое значение:
//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
//
// Описание:
//  Предназначена для формирования "правильной" подписи к числительным
//
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, ЦелоеЧисло) Экспорт

	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции

// Процедура вычисляет количество лет, месяцев и дней между двумя датами
//
// Параметры
//  Дата1	– дата, первая дата (более поздняя, часто текущая, стаж определяется по состоянию на эту дату)
//  Дата2	– дата, вторая дата (ранняя дата, с нее начинается "течение" стажа)
//  Лет		– Число, в этот параметр будет записано кол-во лет между двумя датами (Дата1-Дата2)
//  Месяцев	– Число, в этот параметр будет записано кол-во месяцев между двумя датами (Дата1-Дата2)
//  Дней	– Число, в этот параметр будет записано кол-во дней между двумя датами (Дата1-Дата2)
//
Процедура РазобратьРазностьДат(Дата1, Дата2, Лет = 0, Месяцев = 0, Дней = 0) Экспорт
	
	Лет		= 0;
	Месяцев	= 0;
	Дней	= 0;
	Если Дата1 > Дата2 Тогда
		
		ВременнаяДата = Дата1;
		Если День(ВременнаяДата) < День(Дата2) Тогда
			Дней = (ВременнаяДата - ДобавитьМесяц(ВременнаяДата,-1))/86400;
			ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-1);
		КонецЕсли;
		Если Месяц(ВременнаяДата) < Месяц(Дата2) Тогда
			ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-12);
			Месяцев = 12;
		КонецЕсли;
		Лет		= Макс(			 Год(ВременнаяДата)		- Год(Дата2),	0);
		Месяцев	= Макс(Месяцев	+ Месяц(ВременнаяДата)	- Месяц(Дата2),	0);
		Дней	= Макс(Дней		+ День(ВременнаяДата)	- День(Дата2),	0);
		
		// скорректируем отображаемое значение, если "вмешалось" разное количество дней в месяцах
		Если Дата2 <> (ДобавитьМесяц(Дата1,-Лет*12-Месяцев)-Дней*86400) Тогда
			Дней = Дней + (День(КонецМесяца(Дата2)) - День(НачалоМесяца(Дата2))) - (День(КонецМесяца(ДобавитьМесяц(Дата1,-1))) - День(НачалоМесяца(ДобавитьМесяц(Дата1,-1))));
		КонецЕсли;
		
	КонецЕсли;

КонецПроцедуры	// РазобратьРазностьДат

Функция ПолучитьРабочуюДату() Экспорт
	
	#Если Клиент Тогда
		Дата = РабочаяДата;
	#Иначе
		Дата = ТекущаяДата();
	#КонецЕсли
	
	Возврат Дата;
	
КонецФункции // ПолучитьРабочуюДату()

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции // глРазложить

Функция ПолучитьЗначениеПеременной(ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	Иначе
		// Ищем значение в структуре
		НайденноеЗначение = Неопределено;
		Если Кэш.Свойство(ИмяПараметра, НайденноеЗначение) Тогда
			Возврат НайденноеЗначение;
		КонецЕсли;
	КонецЕсли;
	
	
	НайденноеЗначение = ОбщегоНазначенияПереопределяемый.ПолучитьЗначениеПеременной(ИмяПараметра);
	
	Если НайденноеЗначение = НеОпределено Тогда

		// Значение в КЭШе не нашли, получим значение из БД
		Если ВРег(ИмяПараметра) = ВРег("глТекущийПользователь") Тогда
			НайденноеЗначение = ПараметрыСеанса.ТекущийПользователь;
			
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("глУчетнаяПолитикаПоПерсоналу") Тогда
			НайденноеЗначение = ЗаполнениеУчетнойПолитикиПоПерсоналу();
			
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("глУчетнаяПолитикаПоПерсоналуОрганизации") Тогда
			НайденноеЗначение = ОбщегоНазначенияЗК.ЗаполнениеУчетнойПолитикиПоПерсоналуОрганизации();
			
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("глУчетнаяПолитикаПоНалоговомуУчету") Тогда
			НайденноеЗначение = ОбщегоНазначенияПереопределяемый.ЗаполнениеУчетнойПолитикиНалоговомуУчету();	
			
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("глКоллекцияЗначенийЗаголовков") Тогда
			НайденноеЗначение = ЗаполнитьКоллекциюЗначенийЗаголовков();

		//vvv комментируем директиву, вставим ниже	
		//#Если Клиент Тогда
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("глКомпонентаСклоненияФИО") Тогда
			
			Попытка
				// Загружаем внешнюю компоненту
				ЗагрузитьВнешнююКомпоненту("NameDecl.dll");
				НайденноеЗначение = Новый("AddIn.NameDeclension");		
			Исключение
				// Не удалось выполнить операции с внешней компонентой
				//vvv комментируем
				//ОбщегоНазначения.СообщитьОбОшибке("Ошибка загрузки внешней компоненты для склонения ФИО! Функции склонения будут недоступны!");		
			КонецПопытки;
				
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("глСоответствиеТекстовЭлектронныхПисем") Тогда
			НайденноеЗначение = Новый Соответствие;
			
		//vvv добавим директиву
		#Если ТолстыйКлиентОбычноеПриложение Тогда
		//	
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаАвтоПолученияОтправкиЭлектронныхПисем") Тогда	
			Если ПравоДоступа("Использование", Метаданные.Обработки.АвтоПолучениеОтправкаЭлектронныхПисем) Тогда
				НайденноеЗначение = Обработки.АвтоПолучениеОтправкаЭлектронныхПисем.ПолучитьФорму();
			Иначе
				НайденноеЗначение = Неопределено;
			КонецЕсли;		
		//vvv	
		#КонецЕсли
		//
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("ЗначенияНастроекПользователей") Тогда
			НайденноеЗначение = Новый Соответствие;
			
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("ЗначенияДополнительныхПравПользователя") Тогда
			НайденноеЗначение = Новый Соответствие;		
	
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаСообщений") Тогда
			НайденноеЗначение = Обработки.СообщенияВыполняемыхДействий.Создать();
		//vvv добавим директиву
		#Если ТолстыйКлиентОбычноеПриложение Тогда
		//	
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаАвтоОбменДанными") Тогда
			НайденноеЗначение = ПроцедурыОбменаДанными.ВыполнитьИнициализациюАвтообменаПриНачалеРаботы();		
			
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("КэшСтратегииАвтонумерации") Тогда	
			НайденноеЗначение = Новый Соответствие;		
		#КонецЕсли
		
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("глКоличествоСекундОпросаОбмена") Тогда
			НайденноеЗначение = Константы.ИнтервалДляОпросаРегламентныхЗаданийВФайловомВарианте.Получить();
			Если НайденноеЗначение = 0 Тогда
				НайденноеЗначение = 60;
			КонецЕсли;
		ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОграничитьКоличествоСотрудниковПриПечатиВедомости") Тогда
			НайденноеЗначение = Ложь;
		
		Иначе
			СтрокаИсключения = "Невозможно обработать параметр " + """" + ИмяПараметра + """" + " для получения значения";
			ВызватьИсключение СтрокаИсключения;
		КонецЕсли;
	КонецЕсли;
		
	Кэш.Вставить(ИмяПараметра, НайденноеЗначение);
	КэшИзменен = Истина;
	
	Возврат НайденноеЗначение;
	
КонецФункции

Процедура УстановитьЗначениеПеременной(ИмяПараметра, Кэш, ЗначениеПараметра, ОбновлятьВоВсехКэшах = Ложь) Экспорт
	
	Если Кэш.Свойство(ИмяПараметра) Тогда
		Кэш.Вставить(ИмяПараметра, ЗначениеПараметра);
	КонецЕсли;
	
	#Если Клиент ИЛИ ВнешнееСоединение Тогда
		Если ОбновлятьВоВсехКэшах Тогда
			Кэш = ПараметрыСеанса.ОбщиеЗначения.Получить();
			Кэш.Вставить(ИмяПараметра, ЗначениеПараметра);
			ПараметрыСеанса.ОбщиеЗначения = Новый ХранилищеЗначения(Кэш);
		КонецЕсли;
	#КонецЕсли
	
КонецПроцедуры

Функция ШестнадцатиричноеВДесятичное(Источник) Экспорт
	
	Результат = 0;
	
	Для Поз = 1 По СтрДлина(Источник) Цикл
		ТекКод = КодСимвола(Источник, Поз);
		
		Если ТекКод >= КодСимвола("0") И ТекКод <= КодСимвола("9") Тогда
			ТекКод = ТекКод - КодСимвола("0");
		ИначеЕсли ТекКод >= КодСимвола("a") И ТекКод <= КодСимвола("f") Тогда
			ТекКод = ТекКод +10 - КодСимвола("a");
		ИначеЕсли ТекКод >= КодСимвола("A") И ТекКод <= КодСимвола("F") Тогда
			ТекКод = ТекКод +10 - КодСимвола("A");
		КонецЕсли;
		
		Результат = Результат * 16 + ТекКод;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ДесятичноеВШестнадцатиричное(Источник) Экспорт
	
	ШеснадцатиричныеСимволы = "0123456789ABCDEF";
	
	Если Источник < 0 Тогда
		Возврат "00";
	КонецЕсли;
	Если Источник > 255 Тогда
		Возврат "FF";
	КонецЕсли;
	
	ПервыйСимвол	= Цел(Источник / 16) + 1;
	ВтройСимвол		= Источник % 16;
	
	Возврат Сред(ШеснадцатиричныеСимволы, ПервыйСимвол, 1) + Сред(ШеснадцатиричныеСимволы, ВтройСимвол, 1);
	
КонецФункции

// Предназначена для получения запросом представлений объектов
// Поддерживает два синтаксиса
// 1.
// Параметры:
//	СсылкиОбъектовПарам - массив ссылок
// Возвращаемое значение
//	Соответствие в котором ключ - одна из переданных ссылок, 
//  а значение - представление этой ссылки
// 2. 
// Параметры:
//	СсылкиОбъектовПарам - ссылка
// Возвращаемое значение
//	Строка предсатвления ссылки
//
// Пример использования:
// 	МассивСсылок = Новый Массив;
// 	МассивСсылок.Добавить(НоваяОрганизация);
// 	МассивСсылок.Добавить(СтараяОрганизация);
// 	Представления = ПолучитьПредставленияОбъектов(МассивСсылок);
//	НоваяОрганизацияСтрокой = Представления[НоваяОрганизация];
//	СтараяОрганизацияСтрокой = Представления[СтараяОрганизация];
//
Функция ПолучитьПредставленияОбъектов(СсылкиОбъектовПарам) Экспорт
	// соответствие возвращается если передан массив ссылок
	ПереданМассив = Истина;
	
	// Если передано одиночное значение - "превратим" его в массив
	Если ТипЗнч(СсылкиОбъектовПарам) <> Тип("Массив") Тогда
		Ссылка = СсылкиОбъектовПарам;
		СсылкиОбъектов = Новый Массив;
		СсылкиОбъектов.Добавить(Ссылка);
		ПереданМассив = Ложь;
		
	Иначе
		СсылкиОбъектов = СсылкиОбъектовПарам;
		
	КонецЕсли;
	
	// Обработаем массив СсылкиОбъектов и сформируем 
	// соответствие ссылок по их типам
	СсылкиПоТипам = Новый Соответствие;
	Для Каждого СсылкаНаОбъект Из СсылкиОбъектов Цикл
		ПолноеИмя = СсылкаНаОбъект.Метаданные().ПолноеИмя();
		Если СсылкиПоТипам[ПолноеИмя] = НеОпределено Тогда
			СсылкиПоТипам[ПолноеИмя] = Новый Массив;
		КонецЕсли;
		СсылкиПоТипам[ПолноеИмя].Добавить(СсылкаНаОбъект);
	КонецЦикла;
	
	// формирование запроса
	ТекстЗапроса = "";
	Запрос = Новый Запрос;
	ПервоеЗначение = Истина;
	Для Каждого ЭлементСоответствия Из СсылкиПоТипам Цикл
		ИмяПараметра = "Массив" + СтрЗаменить(ЭлементСоответствия.Ключ, ".", "_");
		Если Не ПервоеЗначение Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|ОБЪЕДИНИТЬ ВСЕ";
			
		КонецЕсли;
		ТекстЗапроса = ТекстЗапроса + "
		|ВЫБРАТЬ 
		|	Ссылка КАК Ссылка,
		|	ПРЕДСТАВЛЕНИЕ(Ссылка) КАК Представление
		|ИЗ " + ЭлементСоответствия.Ключ + "
		|ГДЕ Ссылка В (&" + ИмяПараметра + ")";
		Запрос.УстановитьПараметр(ИмяПараметра, ЭлементСоответствия.Значение);
		ПервоеЗначение = Ложь;
	КонецЦикла;
	// обработка запроса
	Запрос.Текст = ТекстЗапроса;
	Выборка = Запрос.Выполнить().Выбрать();
	Если ПереданМассив Тогда
		ВозвращаемоеСоответствие = Новый Соответствие;
		Пока Выборка.Следующий() Цикл
			ВозвращаемоеСоответствие[Выборка.Ссылка] = Выборка.Представление;
		КонецЦикла;
		
		// дополним пустыми представлениями неполученных запросом ссылок
		Для Каждого СсылкаНаОбъект Из СсылкиОбъектов Цикл
			Если ВозвращаемоеСоответствие[СсылкаНаОбъект] = НеОпределено Тогда
				ВозвращаемоеСоответствие[СсылкаНаОбъект] = "";
			КонецЕсли;
			
		КонецЦикла;
		Возврат ВозвращаемоеСоответствие;
		
	Иначе
		Если Выборка.Следующий() Тогда
			Возврат Выборка.Представление;
		Иначе
			// если ссылки не нашлось - пустое представление
			Возврат "";
		КонецЕсли;
		
	КонецЕсли; 
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ НАСТРОЙКИ ПОРЯДКА ЭЛЕМЕНТОВ СПРАВОЧНИКА

// Вспомогательная функция для определнения условий запроса в механизме
// изменения порядка следования элементов. Ставит условия на родителя и владельца
//
// Параметры
//  Элемент - СправочникСсылка, для которого необходимо изменить порядок
//  Запрос - Запрос, в который дописываем условия
// 
//  Возвращаемое значение:
//   Строка - условие запроса
// 
Функция ПолучитьДополнениеЗапроса(Элемент, Запрос, БезПервогоИ = Ложь)

	ТекстЗапроса = "";
	
	Если Элемент.Метаданные().Иерархический = Истина Тогда
		Запрос.УстановитьПараметр("ТекущийРодитель", Элемент.Родитель);
		Если НЕ БезПервогоИ Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Родитель = &ТекущийРодитель
		|";
	КонецЕсли; 
	
	Если Элемент.Метаданные().Владельцы.Количество() > 0 Тогда
		Запрос.УстановитьПараметр("ТекущийВладелец", Элемент.Владелец);
		Если НЕ (ПустаяСтрока(ТекстЗапроса) И БезПервогоИ) Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Владелец = &ТекущийВладелец
		|";
	КонецЕсли; 

	Возврат ТекстЗапроса;
	
КонецФункции

// Возвращает значение порядка для нового элемента справочника.
//
// Параметры
//  ЭлементОбъект - СправочникОбъект - новый объект
//
// Возвращаемое значение:
//   Число - новый порядок
//
Функция НазначитьНовыйПорядок(ЭлементОбъект)

	ИмяТаблицы = ЭлементОбъект.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	СправочникПорядка.Порядок
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка";
	
	ДополнениеЗапроса = ПолучитьДополнениеЗапроса(ЭлементОбъект, Запрос, Истина);
	
	Если НЕ ПустаяСтрока(ДополнениеЗапроса) Тогда
		Запрос.Текст = Запрос.Текст + "
		|ГДЕ
		|" + ДополнениеЗапроса + "
		|";
	КонецЕсли; 
	
	Запрос.Текст = Запрос.Текст + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок УБЫВ
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат (Выборка.Порядок + 1)
	КонецЕсли; 

КонецФункции

// Процедура вызывается перед записью объекта, для которого необходимо
// контролировать порядок элементов.
// 
// Параметры
//  Отказ - Булево, отказ от записи объекта
//  ЭтотОбъект - СправочникОбъект
//  КонтролироватьПорядок - Булево, контролировать порядок при записи объекта или нет
//
Процедура ПередЗаписьюОбъектаПорядка(Отказ, ЭтотОбъект, КонтролироватьПорядок) Экспорт

	Если ЭтотОбъект.ЭтоНовый() Тогда
		ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
	Иначе
		Если ЭтотОбъект.Ссылка.Родитель <> ЭтотОбъект.Родитель ИЛИ ЭтотОбъект.Ссылка.Владелец <> ЭтотОбъект.Владелец Тогда
			ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
		КонецЕсли;
	КонецЕсли;
	
	Если КонтролироватьПорядок Тогда
	
		ИмяТаблицы = ЭтотОбъект.Метаданные().Имя;
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ЭтотОбъект.Порядок);
		
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Порядок
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок = &ТекущийПорядок
		|";
		
		Если НЕ ЭтотОбъект.ЭтоНовый() Тогда
			Запрос.УстановитьПараметр("ТекущаяСсылка", ЭтотОбъект.Ссылка);
			Запрос.Текст = Запрос.Текст + "
			|И
			|	СправочникПорядка.Ссылка <> &ТекущаяСсылка
			|";
		КонецЕсли; 
		
		Запрос.Текст = Запрос.Текст + ПолучитьДополнениеЗапроса(ЭтотОбъект, Запрос);
		
		Если НЕ Запрос.Выполнить().Пустой() Тогда
			Отказ = Истина;
			#Если Клиент Тогда
				Сообщить("Не уникальный порядок элемента справочника.");
			#КонецЕсли
		КонецЕсли;
	
	КонецЕсли; 

КонецПроцедуры

// Процедура изменяет порядок следования объектов с настраиваемым из ВЯ
// порядком следования.
// 
// Параметры:
//  ЭлементСсылка - СправочникСсылка, элемент для которого необходимо изменить порядок
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
Процедура ИзменитьПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг = Истина) Экспорт
	
	ЭлементЗамены = ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг);
	
	Если ЭлементЗамены = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НовыйПорядокЗамены   = ЭлементЗамены.Порядок;
	НовыйПорядокЭлемента = ЭлементСсылка.Порядок;
	
	Если НаправлениеПорядка = "Вверх" Тогда
		Если НовыйПорядокЗамены < НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены + 1;
		КонецЕсли; 
	Иначе
		Если НовыйПорядокЗамены > НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены - 1;
		КонецЕсли;
	КонецЕсли;
	
	НачатьТранзакцию();
	
	ФиксироватьТранзакцию = Истина;
	
	Если НовыйПорядокЗамены <> ЭлементЗамены.Порядок Тогда
		ОбъектЗамены = ЭлементЗамены.ПолучитьОбъект();
		ОбъектЗамены.Порядок = НовыйПорядокЗамены;
		ОбъектЗамены.КонтролироватьПорядок = Ложь;
		Попытка
			ОбъектЗамены.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли; 
	
	Если ФиксироватьТранзакцию Тогда
		ОбъектЭлемента = ЭлементСсылка.ПолучитьОбъект();
		ОбъектЭлемента.Порядок = НовыйПорядокЭлемента;
		Попытка
			ОбъектЭлемента.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Если ФиксироватьТранзакцию Тогда
		ЗафиксироватьТранзакцию();
	Иначе
		ОтменитьТранзакцию();
	КонецЕсли; 
	
КонецПроцедуры

// Функция определяет элемент справочника, с которым необходимо
// произвести "рокировку" текущего элемента
//
// Параметры
//  ЭлементСсылка - СпраовочникСсылка, элемент для изменения порядка
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
// Возвращаемое значение:
//   СправочникСсылка
//
Функция ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг)

	ТекущийПорядок = ЭлементСсылка.Порядок;
	
	ИмяТаблицы = ЭлементСсылка.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	СправочникПорядка.Ссылка
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
	|ГДЕ
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "<", ">") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
		
	ИначеЕсли ЦиклическийСдвиг Тогда
		// Текущий элемент или первый (при движении вверх)
		// или последний (при движении вниз)
		// или вообще единственный
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Ссылка
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", ">", "<") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
		|УПОРЯДОЧИТЬ ПО
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
		|";
		
		РезультатЗапроса = Запрос.Выполнить();
		
		Если РезультатЗапроса.Пустой() Тогда
			Возврат Неопределено;
		Иначе
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			Возврат Выборка.Ссылка;
		КонецЕсли; 
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ВАЛЮТАМИ

// Эта функция пересчитывает сумму из валюты ВалютаНач по курсу ПоКурсуНач 
// в валюту ВалютаКон по курсу ПоКурсуКон
//
// Параметры:      
//	Сумма          - сумма, которую следует пересчитать;
//	ВалютаНач      - ссылка на элемент справочника Валют;
//                   определяет валюты из которой надо пересчитвать;
//	ВалютаКон      - ссылка на элемент справочника Валют;
//                   определяет валюты в которую надо пересчитвать;
// 	ПоКурсуНач     - курс из которого надо пересчитать;
// 	ПоКурсуКон     - курс в который надо пересчитать;
// 	ПоКратностьНач - кратность из которого надо пересчитать (по умолчанию = 1);
// 	ПоКратностьКон - кратность в который надо пересчитать  (по умолчанию = 1);
//
// Возвращаемое значение: 
//  Сумма, пересчитанная в другую валюту
//
Функция ПересчитатьИзВалютыВВалюту(Сумма, ВалютаНач, ВалютаКон, ПоКурсуНач, ПоКурсуКон, 
	               ПоКратностьНач =1, ПоКратностьКон = 1 ) Экспорт

	Если (ВалютаНач = ВалютаКон) Тогда

		// Считаем, что пересчет не нужен.
		Возврат Сумма;
	КонецЕсли;

	Если (ПоКурсуНач = ПоКурсуКон) 
	   и (ПоКратностьНач = ПоКратностьКон) Тогда

		// ну, тут и считать нечего...
		Возврат Сумма;
	КонецЕсли;

	Если ПоКурсуНач     = 0 
	 или ПоКурсуКон     = 0 
	 или ПоКратностьНач = 0 
	 или ПоКратностьКон = 0 Тогда
		СообщитьОбОшибке("При пересчете суммы из валюты """ + СокрЛП(ВалютаНач) + """ в валюту """ + СокрЛП(ВалютаКон) + """ обнаружен нулевой курс. Пересчет не произведен!");
		Возврат 0;
	КонецЕсли;

	Возврат Окр((Сумма * ПоКурсуНач * ПоКратностьКон) / (ПоКурсуКон * ПоКратностьНач), 2);
	
КонецФункции //ПересчитатьИзВалютыВВалюту()

// Возвращает курс валюты на дату
//
// Параметры:
//  Валюта     - Валюта (элемент справочника "Валюты")
//  ДатаКурса  - Дата, на которую следует получить курс
//
// Возвращаемое значение: 
//  Структура, содержащая:
//   Курс      - курс валюты
//   Кратность - кратность валюты
//
Функция ПолучитьКурсВалюты(Валюта, ДатаКурса) Экспорт

	Структура = РегистрыСведений.КурсыВалют.ПолучитьПоследнее(ДатаКурса, Новый Структура("Валюта", Валюта));
	Возврат Структура;
	
КонецФункции // ПолучитьКурсВалюты()

// Проверяет наличие установленного курс аи кратности валюты на 1 января 1980 года.
// В случае отсутствия устанавливает курс и кратность равными единице.
//
// Параметры:
//  Валюта - ссылка на элемент справочника Валют
//
Процедура ПроверитьКорректностьКурсаНа01_01_1980(Валюта) Экспорт

	ДатаКурса = Дата(1980, 1, 1);
	СтруктураКурса = ПолучитьКурсВалюты(Валюта, ДатаКурса);

	Если (СтруктураКурса.Курс = 0) Или (СтруктураКурса.Кратность = 0) Тогда

		// установим курс и кратность = 1 на 01.01.1980, чтобы не было ошибок при создании документов

		РегистрКурсыВалют = РегистрыСведений.КурсыВалют.СоздатьМенеджерЗаписи();

		РегистрКурсыВалют.Период    = ДатаКурса;
		РегистрКурсыВалют.Валюта    = Валюта;
		РегистрКурсыВалют.Курс      = 1;
		РегистрКурсыВалют.Кратность = 1;
		РегистрКурсыВалют.Записать();
		
		РегистрКурсыВалют = РегистрыСведений.КурсыВалютДляРасчетовСПерсоналом.СоздатьМенеджерЗаписи();

		РегистрКурсыВалют.Период    = ДатаКурса;
		РегистрКурсыВалют.Валюта    = Валюта;
		РегистрКурсыВалют.Курс      = 1;
		РегистрКурсыВалют.Кратность = 1;
		РегистрКурсыВалют.Записать();

	КонецЕсли;

КонецПроцедуры // ПроверитьКорректностьКурсаНа01_01_1980()

//округляет результат вычислений до указанного разряда
Функция ОкруглитьРезультат(РезультатРасчетов, ПараметрОкругления) Экспорт
	
	Результат = РезультатРасчетов;
	
	Если РезультатРасчетов <> 0 тогда
		Если Не ЗначениеНеЗаполнено(ПараметрОкругления) тогда
			
			Если ПараметрОкругления = Перечисления.ПорядкиОкругления.Окр5 тогда
				СуммаОстатка = (РезультатРасчетов%10);
				Результат=РезультатРасчетов-?(Суммаостатка>=5,СуммаОстатка-5,СуммаОстатка);
			ИначеЕсли ПараметрОкругления = Перечисления.ПорядкиОкругления.Окр10 тогда
				СуммаОстатка = (РезультатРасчетов%10);
				Результат=РезультатРасчетов-СуммаОстатка;
			ИначеЕсли ПараметрОкругления = Перечисления.ПорядкиОкругления.Окр50 тогда
				СуммаОстатка = (РезультатРасчетов%100);
				Результат=РезультатРасчетов-?(Суммаостатка>=50,СуммаОстатка-50,СуммаОстатка);
			ИначеЕсли ПараметрОкругления = Перечисления.ПорядкиОкругления.Окр100 тогда
				СуммаОстатка = (РезультатРасчетов%100);
				Результат=РезультатРасчетов-СуммаОстатка;
			ИначеЕсли ПараметрОкругления = Перечисления.ПорядкиОкругления.Окр1 тогда
				Результат=Окр(РезультатРасчетов, 0, 1);
			ИначеЕсли ПараметрОкругления = Перечисления.ПорядкиОкругления.БезОкругления тогда
				Результат=РезультатРасчетов;
			КонецЕсли;	
				
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

//округляет результат вычислений по математичесским правилам
Функция Округлить(РезультатРасчетов, ПараметрОкругления) Экспорт
	
	Результат = РезультатРасчетов;
	
	Если РезультатРасчетов <> 0 тогда
		Если Не ЗначениеНеЗаполнено(ПараметрОкругления) тогда
			
			Если ПараметрОкругления = Перечисления.ПорядкиОкругления.Окр5 тогда
				ПорядокОкругления = -1;
				Результат=Окр(РезультатРасчетов, ПорядокОкругления, 1);
			ИначеЕсли ПараметрОкругления = Перечисления.ПорядкиОкругления.Окр10 тогда
				ПорядокОкругления = -1;
				Результат=Окр(РезультатРасчетов, ПорядокОкругления, 1);
			ИначеЕсли ПараметрОкругления = Перечисления.ПорядкиОкругления.Окр50 тогда
				ПорядокОкругления = -2;
				Результат=Окр(РезультатРасчетов, ПорядокОкругления, 1);;
			ИначеЕсли ПараметрОкругления = Перечисления.ПорядкиОкругления.Окр100 тогда
				ПорядокОкругления = -2;
				Результат=Окр(РезультатРасчетов, ПорядокОкругления, 1);
			ИначеЕсли ПараметрОкругления = Перечисления.ПорядкиОкругления.Окр1 тогда
				Результат=Окр(РезультатРасчетов, 0, 1);
			ИначеЕсли ПараметрОкругления = Перечисления.ПорядкиОкругления.БезОкругления тогда
				Результат=РезультатРасчетов;
			КонецЕсли;	
				
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции



// Функция округляет сумму в соответствии с количеством знаков в дробной части ,
//указанных в справочнике "Валюты"
//Параметры:
//Валюта - тип СправочникСсылка.Валюты
//Сумма  - тип число,сумма ,которую необходимо округлить
//Возвращаемое значение:
//число
//
Функция ОкруглитьПоВалюте(Сумма,Валюта) Экспорт
	
	ЧислоЗнаковДрЧасти = Валюта.ЧислоЗнаковДрЧасти;
	РезСумма           = Окр(Сумма,ЧислоЗнаковДрЧасти,1);
	Возврат РезСумма;	
	
КонецФункции//ОкруглитьПоВалюте()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ

// Определяет заполнено ли переданное значение
//
// Параметры: 
//  Значение - значение, заполенение которого надо проверить
//
// Возвращаемое значение:
//  Истина - значение не заполнено, ложь - иначе.
//
Функция ЗначениеНеЗаполнено(Значение) Экспорт

	Результат = Ложь;
	ТипЗначения = ТипЗнч(Значение);

	// Сначала примитивные типы
	Если Значение = Неопределено Тогда
		Результат = Истина;
	ИначеЕсли Значение = NULL Тогда
		Результат = Истина;
	ИначеЕсли ТипЗначения = Тип("Строка") Тогда
		Если СокрЛП(Значение) = "" Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Число") Тогда
		Если Значение = 0 Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		Если Значение = Дата('00010101') Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Булево") Тогда
		Результат = Ложь; // Булево будем считать не пустым
		
	//Отдельное определение, так как конструкторов данного типа не существует	
	ИначеЕсли ТипЗначения = Тип("РежимПроведенияДокумента") Тогда
		Если Значение = РежимПроведенияДокумента.Неоперативный или Значение = РежимПроведенияДокумента.Оперативный тогда
			Результат = Ложь;
		КонецЕсли;
		
	// Для остальных будем считать значение пустым, если оно равно
	// дефолтному значению своего типа
	Иначе
		Если Значение = Новый(ТипЗначения) Тогда
			Результат = Истина;
		КонецЕсли; 
	КонецЕсли; 

	Возврат Результат;
	
КонецФункции // ЗначениеНеЗаполнено()

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	Иначе
		Возврат Новый (ЗаданныйТип);
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт
	
	Возврат МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) <> Неопределено

КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли среди реквизитов шапки отчета
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита     - строковое имя искомого реквизита, 
//  МетаданныеОтчета - метаданные отчета, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитОтчета(ИмяРеквизита, МетаданныеОтчета) Экспорт

	Возврат МетаданныеОтчета.Реквизиты.Найти(ИмяРеквизита) <> Неопределено

КонецФункции // ЕстьРеквизитОтчета()

// Позволяет определить есть ли среди реквизитов справочника
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита     - строковое имя искомого реквизита, 
//  МетаданныеСправочника - метаданные справочника, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитСправочника (ИмяРеквизита, МетаданныеСправочника) Экспорт

	Возврат МетаданныеСправочника.Реквизиты.Найти(ИмяРеквизита) <> Неопределено

КонецФункции // ЕстьРеквизитОтчета()

// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
	// есть таб. часть в документе
	Возврат ТабЧасть <> Неопределено И ТабЧасть.Реквизиты.Найти(ИмяРеквизита) <> Неопределено

КонецФункции // ЕстьРеквизитТабЧастиДокумента()

// Процедура предназначена для заполнения общих реквизитов документов,
// вызывается в обработчиках событий "ПриОткрытии" в модулех форм всех документов.
//
// Параметры:
//  ДокументОбъект                 - объект редактируемого документа,
//  ТекПользователь                - ссылка на справочник, определяет текущего пользователя  
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//  ТипОперации                    - необязаетельный, строка вида операции ("Покупка" или "Продажа"),
//                                   если не передан, то реквизиты, зависящие от вида операции, не заполняются
//
Процедура ЗаполнитьШапкуДокумента(ДокументОбъект, ТекПользователь, ВалютаРегламентированногоУчета = Неопределено, ТипОперации = "") Экспорт

	Перем ТипЦен;

	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если ЕстьРеквизитДокумента("Ответственный", МетаданныеДокумента) Тогда
		ДокументОбъект.Ответственный = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойОтветственный");
	КонецЕсли;

	// Флаги принадлежности к учету заполняем, только если оба не заполнены
	Если ЕстьРеквизитДокумента("ОтражатьВУправленческомУчете", МетаданныеДокумента) 
	   И ЕстьРеквизитДокумента("ОтражатьВБухгалтерскомУчете", МетаданныеДокумента) Тогда
		Если Не (ДокументОбъект.ОтражатьВУправленческомУчете 
		 или ДокументОбъект.ОтражатьВБухгалтерскомУчете) Тогда

			ДокументОбъект.ОтражатьВУправленческомУчете = Ложь;
			ДокументОбъект.ОтражатьВБухгалтерскомУчете  = Истина;

			Если ЕстьРеквизитДокумента("ОтражатьВНалоговомУчете", МетаданныеДокумента) Тогда
				ДокументОбъект.ОтражатьВНалоговомУчете = Истина;
			КонецЕсли;

		КонецЕсли;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("Подразделение", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.Подразделение)) Тогда
		ДокументОбъект.Подразделение = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновноеПодразделение");
	КонецЕсли;
	
	Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) 
	  И (НЕ ЗначениеЗаполнено(ДокументОбъект.Организация)) Тогда
		ДокументОбъект.Организация = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнаяОрганизация");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ВидОперации", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.ВидОперации)) Тогда
		ДокументОбъект.ВидОперации = Перечисления[ДокументОбъект.ВидОперации.Метаданные().Имя][0];
	КонецЕсли;

	Если ЕстьРеквизитДокумента("СчетОрганизации", МетаданныеДокумента)
		И (НЕ ЗначениеЗаполнено(ДокументОбъект.СчетОрганизации))
		И (ЗначениеЗаполнено(ДокументОбъект.Организация.ЮрФизЛицо)) Тогда
		СчетПоУмолчанию = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
		ДокументОбъект.СчетОрганизации = СчетПоУмолчанию;
		Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента)
			И (НЕ ЗначениеЗаполнено(ДокументОбъект.ВалютаДокумента)) Тогда
			ДокументОбъект.ВалютаДокумента =  СчетПоУмолчанию.ВалютаДенежныхСредств;
		КонецЕсли;
	КонецЕсли;
	
	Если ЕстьРеквизитДокумента("ПодразделениеОрганизации", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.ПодразделениеОрганизации)) Тогда
		ДокументОбъект.ПодразделениеОрганизации = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновноеПодразделениеОрганизации");;
	КонецЕсли;
		
	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.ВалютаДокумента)) Тогда
		ДокументОбъект.ВалютаДокумента = ВалютаРегламентированногоУчета;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.КурсДокумента)) Тогда
	    СтруктураКурсаДокумента      = ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента, ДокументОбъект.Дата);
		ДокументОбъект.КурсДокумента = СтруктураКурсаДокумента.Курс;

		Если ЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
			ДокументОбъект.КратностьДокумента = СтруктураКурсаДокумента.Кратность;
		КонецЕсли;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ДатаОплаты", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.ДатаОплаты)) Тогда
		ДокументОбъект.ДатаОплаты = ДокументОбъект.Дата;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ЗанимаемыхСтавок", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.ЗанимаемыхСтавок)) Тогда
		ДокументОбъект.ЗанимаемыхСтавок = 1;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ПериодРегистрации", МетаданныеДокумента)
	   И (НЕ ЗначениеЗаполнено(ДокументОбъект.ПериодРегистрации)) Тогда
		ДокументОбъект.ПериодРегистрации = НачалоМесяца(ПолучитьРабочуюДату());
	КонецЕсли;
	
КонецПроцедуры // ЗаполнитьШапкуДокумента()

// Процедура предназначена для заполнения общих реквизитов документов по документу основанию,
//	вызывается в обработчиках событий "ОбработкаЗаполнения" в модулях документов.
//
// Параметры:
//  ДокументОбъект  - объект редактируемого документа,
//  ДокументОснование - объект документа основания
//
Процедура ЗаполнитьШапкуДокументаПоОснованию(ДокументОбъект, ДокументОснование) Экспорт

	МетаданныеДокумента          = ДокументОбъект.Метаданные();
	МетаданныеДокументаОснования = ДокументОснование.Метаданные();

	// Организация.
	Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("Организация", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Организация = ДокументОснование.Организация;
	КонецЕсли;

	// Подразделение.
	Если ЕстьРеквизитДокумента("Подразделение", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("Подразделение", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Подразделение = ДокументОснование.Подразделение;
	КонецЕсли;

	// Подразделение.
	Если ЕстьРеквизитДокумента("ПодразделениеОрганизации", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ПодразделениеОрганизации", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.ПодразделениеОрганизации = ДокументОснование.ПодразделениеОрганизации;
	КонецЕсли;

	// Банковский счет 
	Если ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента) 
        И ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокументаОснования) Тогда
		
			Если ЗначениеЗаполнено(ДокументОснование.БанковскийСчет) Тогда
				ДокументОбъект.БанковскийСчет = ДокументОснование.БанковскийСчет;
			КонецЕсли;

	КонецЕсли;

	// ВалютаДокумента.
	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокументаОснования) Тогда

		// Если есть банковский счет, то валюта должна браться только оттуда
		Если ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента) Тогда
			Если ЗначениеЗаполнено(ДокументОбъект.БанковскийСчет) Тогда
				ДокументОбъект.ВалютаДокумента = ДокументОбъект.БанковскийСчет.ВалютаДенежныхСредств;
		    КонецЕсли;
		Иначе
			ДокументОбъект.ВалютаДокумента = ДокументОснование.ВалютаДокумента;
		КонецЕсли;

		// КурсДокумента.
		Если ЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента) Тогда
			СтруктураКурсаДокумента = ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента, ТекущаяДата());
			ДокументОбъект.КурсДокумента = СтруктураКурсаДокумента.Курс;

			// КратностьДокумента.
			Если ЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
				ДокументОбъект.КратностьДокумента = СтруктураКурсаДокумента.Кратность;
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;

	// ОтражатьВУправленческомУчете.
	// Если есть в основании, копируем из основания, иначе - Истина.
	Если ЕстьРеквизитДокумента("ОтражатьВУправленческомУчете", МетаданныеДокумента) Тогда
		Если ЕстьРеквизитДокумента("ОтражатьВУправленческомУчете", МетаданныеДокументаОснования) Тогда
			ДокументОбъект.ОтражатьВУправленческомУчете = ДокументОснование.ОтражатьВУправленческомУчете;
		Иначе
			ДокументОбъект.ОтражатьВУправленческомУчете = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если ЕстьРеквизитДокумента("ОтражатьВБухгалтерскомУчете", МетаданныеДокумента) Тогда
		Если ЕстьРеквизитДокумента("ОтражатьВБухгалтерскомУчете", МетаданныеДокументаОснования) Тогда
			ДокументОбъект.ОтражатьВБухгалтерскомУчете = ДокументОснование.ОтражатьВБухгалтерскомУчете;
		Иначе
			ДокументОбъект.ОтражатьВБухгалтерскомУчете = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если ЕстьРеквизитДокумента("ОтражатьВНалоговомУчете", МетаданныеДокумента) Тогда
		Если ЕстьРеквизитДокумента("ОтражатьВНалоговомУчете", МетаданныеДокументаОснования) Тогда
			ДокументОбъект.ОтражатьВНалоговомУчете = ДокументОснование.ОтражатьВНалоговомУчете;
		Иначе
			ДокументОбъект.ОтражатьВНалоговомУчете = Истина;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры // ЗаполнитьШапкуДокументаПоОснованию()

// Процедура устанавливает номер документа.
//
// Параметры:
//  ДокументОбъект  - ДокументОбъект. Экземпляр документа, которому 
//                    необходимо присвоить новый номер
//
Процедура УстановитьНомерДокумента(ДокументОбъект) Экспорт

	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если Не ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
	 Или НЕ ЗначениеЗаполнено(ДокументОбъект.Организация.Префикс) Тогда

		ДокументОбъект.УстановитьНовыйНомер("00");

	Иначе

		ДокументОбъект.УстановитьНовыйНомер(ДокументОбъект.Организация.Префикс);

	КонецЕсли;

КонецПроцедуры // УстановитьНомерДокумента()

Процедура ДобавитьПрефиксОрганизации(Источник, Префикс) Экспорт
	
	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = Источник.Метаданные();

	Если Не ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
		 ИЛИ НЕ ЗначениеЗаполнено(Источник.Организация.Префикс)  Тогда
		Префикс = "0";
	Иначе
                                
		Префикс = Источник.Организация.Префикс;
        		
	КонецЕсли;
Конецпроцедуры

// процедура формирования номера документа
Процедура ПриУстановкеНовогоНомераДляДокументов(Источник, СтандартнаяОбработка, Префикс) Экспорт
	ДобавитьПрефиксОрганизации(Источник, Префикс);
	ДобавитьПрефиксУзла(Префикс);
КонецПроцедуры

Процедура ПриУстановкеНовогоКодаСправочникаПриУстановкеНовогоКода(Источник, СтандартнаяОбработка, Префикс) Экспорт
	ДобавитьПрефиксУзла(Префикс);
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт
	
	Массив = Новый Массив; 
	Массив.Добавить(Тип("Строка"));
	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);
	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);
	
КонецФункции // ПолучитьОписаниеТиповСтроки()	 

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность,РазрядностьДробнойЧасти=0) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Число"));
	КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность,РазрядностьДробнойЧасти);
	Возврат Новый ОписаниеТипов(Массив, КвалификаторЧисла);
	
КонецФункции	// ПолучитьОписаниеТиповЧисла() 

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));
	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);
	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);
	
КонецФункции	// ПолучитьОписаниеТиповДаты() 

// Служебная функция - возвращает принадлежность объекта метаданных определенному классу
// 
// Параметры:
//	Класс  - класс
//	Объект - объект метаданных
// 
Функция ПринадлежностьКлассуМетаданных(Класс, Объект) Экспорт
	Для Каждого МДОбъект Из Метаданные[Класс] Цикл
		Если МДОбъект = Объект Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции // ПринадлежностьКлассуМетаданных()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СВОЙСТВАМИ И КАТЕГОРИЯМИ ОБЪЕКТОВ

//Функция возвращает список доступных назначений для "Свойств и категорий объектов" 
//по переданной ссылке
// Параметры:
//	Ссылка - Ссылка на справочник или документ
//
// Возвращаемое значение:
// Список значений: доступные назначения для свойств и категорий
Функция ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке(Ссылка) Экспорт

	Результат = Новый СписокЗначений;

	ТипСсылки = ТипЗнч(Ссылка);

	Запрос = Новый Запрос;

	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Назначения.Ссылка КАК Ссылка,
	|	Назначения.ТипЗначения КАК ТипЗначения
	|ИЗ
	|	ПланВидовХарактеристик.НазначенияСвойствКатегорийОбъектов КАК Назначения
	|ГДЕ
	|	НЕ Назначения.ЭтоГруппа
	|";

	Запрос.Текст = ТекстЗапроса;

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если Выборка.ТипЗначения.СодержитТип(ТипСсылки) Тогда
			Результат.Добавить(Выборка.Ссылка);
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции // ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ

// Сравнивает два массива однотипных значений (кроме коллекций значений)
//
// Параметры: 
//  ПервыйМассив,ВторойМассив - сравниваемые массивы
//
// Возвращаемое значение:
//  булево.
//
Функция МассивыИдентичны(ПервыйМассив,ВторойМассив) Экспорт

    ЭлементовМассива = ПервыйМассив.Количество();
	МассивыСовпадают = (ЭлементовМассива = ВторойМассив.Количество()); 
	  
	Если МассивыСовпадают Тогда
		Для Сч = 1 По ЭлементовМассива Цикл
			Если ПервыйМассив[Сч-1] <> ВторойМассив[Сч-1] Тогда
				Возврат Ложь
			КонецЕсли;
		КонецЦикла; 		
	КонецЕсли;

	Возврат МассивыСовпадают

КонецФункции // МассивыИдентичны()

// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1
Функция ВернутьИндексВМассиве(МассивДанные, Элемент) Экспорт 
	
	Если МассивДанные = Неопределено Тогда
		Возврат -1;
	КонецЕсли;
	
	Для ИндексЭлемента = 0 По МассивДанные.ВГраница() Цикл
		
		Если  (МассивДанные[ИндексЭлемента] = Элемент) Тогда
			Возврат ИндексЭлемента;
		КонецЕсли;	
		
	КонецЦикла;
	
	// не нашли элемент
	Возврат -1;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
//  ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УНИВЕРСАЛЬНЫМИ КОЛЛЕКЦИЯМИ ЗНАЧЕНИЙ

// Создает копию переданного массива, структуры или соответствия
//
// Параметры:
//  КоллекцияИсходная: тип Массив, Структура, Соответствие - исходная коллекция
// Возвращаемое значение:
//  КоллекцияКопия:  тип Массив, Структура, Соответствие - копия исходной коллекции
//
Функция СкопироватьУниверсальнуюКоллекцию(КоллекцияИсходная) Экспорт
	
	Если ТипЗнч(КоллекцияИсходная)=Тип("Массив") Тогда
		
		КоллекцияКопия=Новый Массив;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Добавить(Элемент);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Структура") Тогда
		
		КоллекцияКопия=Новый Структура;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия; 
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Соответствие") Тогда
		
		КоллекцияКопия=Новый Соответствие;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	Иначе
		
		Сообщить("Неверный тип универсальной коллекции для копирования");
		Возврат Неопределено
		
	КонецЕсли;
	
КонецФункции // СкопироватьУниверсальнуюКоллекцию()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте вывобит сообщение в обработку комментирования
// на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения  - строка, текст сообщения.
//					  Строка может содержать символы %%, которые при формировании 
//					  сообщения заменяются на представления элементов расшифровки
//  Отказ           - булево, признак отказа (необязательный).
//  Заголовок	    - Заголовок сообщения, для вывода сообщения если работа на сервере или внешнее соединение
//	Расшифровки 	- массив расшифровок для переданного ТекстСообщения
//					  Представляет собой массив структур с полями Представление и Расшифровка
//					  Поле Представление - текст, дополняющий ТекстСообщения
//					  Поле Расшифровка - действие, выполняемое по расшифровке
//
Процедура ВывестиИнформациюОбОшибке(Знач ТекстСообщения, Отказ = Истина, Заголовок = "", ВидСообщения = Неопределено, Расшифровки = Неопределено, РодительскаяСтрока = НеОпределено, РаскрытьСообщение = Истина) Экспорт
	
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#ИначеЕсли Клиент Тогда
	
	    Если ВидСообщения = Неопределено Тогда
			ВидСообщения = Перечисления.ВидыСообщений.Ошибка;
		КонецЕсли;
		Обработка = глЗначениеПеременной("глОбработкаСообщений");
		Обработка.ДобавитьСообщение(ТекстСообщения, ВидСообщения, Расшифровки, РодительскаяСтрока, РаскрытьСообщение);
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
		Сообщить(ТекстСообщения, СтатусСообщения.Важное);
		
	#КонецЕсли
	
КонецПроцедуры // ВывестиИнформациюОбОшибке()

// Функция убирает из текста сообщения слущебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции // ()

Процедура СообщитьИнформациюПользователю(СтрокаСообщенияПользователю) Экспорт
	
	#Если Клиент Тогда
	Сообщить(СтрокаСообщенияПользователю);
	#КонецЕсли
	
КонецПроцедуры

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//
Процедура СообщитьОбОшибке(Знач ТекстСообщения, Отказ = Ложь, Заголовок = "") Экспорт

	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		Если НЕ ПустаяСтрока(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#Иначе
		
		Если НЕ ПустаяСтрока(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
		Сообщить(ТекстСообщения, СтатусСообщения.Важное);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

// Формирует строку представления документа для сообщений при проведении.
//
// Параметры
//  Документ - ссылка на проводимый документ.
//
// Возвращаемое значение
//  Строка с представлением документа.
//
Функция ПредставлениеДокументаПриПроведении(Документ) Экспорт

	МетаданныеДокумента = Документ.Метаданные();

	ВидОперацииСтр = "";
	Если ЕстьРеквизитДокумента("ВидОперации", МетаданныеДокумента) Тогда
		ВидОперацииСтр = " (" + Документ.ВидОперации + ")";
	КонецЕсли;

	Возврат "Проведение документа: " + СокрЛП(Документ) + ВидОперацииСтр;

КонецФункции // ПредставлениеДокументаПриПроведении()

// Проверяет принадлежность документа к видам учета
//
// Параметры: 
//  СтруктураШапкиДокумента - структура, содержащая реквизиты шапки документа
//  Отказ                   - флаг отказа в проведении.
//  Заголовок               - строка, заголовок сообщения об ошибке проведения.
//  МожетБытьТолькоНалоговый- строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь) Экспорт
	
	Перем Упр, Бух, Нал;
	
	ЕстьУпр = СтруктураШапкиДокумента.Свойство("ОтражатьВУправленческомУчете", Упр);
	ЕстьБух = СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете", Бух);
	ЕстьНал = СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете", Нал);
	
	Если ЕстьУпр ИЛИ ЕстьБух ИЛИ ЕстьНал Тогда
		Если НЕ МожетБытьТолькоНалоговый Тогда
			Если Упр <> Истина И Бух <> Истина  Тогда
				СообщитьОбОшибке("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"" и (или)  ""Бухгалтерский"".", Отказ, Заголовок);
			ИначеЕсли Бух <> Истина И Нал = Истина Тогда
				СообщитьОбОшибке("Документ не может проводиться  по налоговому учету, если он не проводится по бухгалтерскому учету." , Отказ, Заголовок);
			КонецЕсли;
		Иначе
			Если Упр <> Истина И Бух <> Истина И Нал <> Истина Тогда
				СообщитьОбОшибке("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"", ""Бухгалтерский"", ""Налоговый"".", Отказ, Заголовок);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

// Проверяет правильность заполнения шапки документа.
// Если какой-то из реквизтов шапки, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
//
// Параметры: 
//  ДокументОбъект             - объект проводимого документа, 
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеШапкиДокумента(ДокументОбъект, СтруктураОбязательныхПолей, Отказ, Заголовок) Экспорт
	
	//ПроверитьПринадлежностьКВидамУчета();

	МетаданныеРеквизиты = ДокументОбъект.Метаданные().Реквизиты;
	
	Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

		Значение = ДокументОбъект[КлючЗначение.Ключ];
		Если НЕ ЗначениеЗаполнено(Значение) Тогда

			Если НЕ ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
				ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
				СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";
			Иначе
				СтрокаСообщения = КлючЗначение.Значение;
			КонецЕсли;
			СообщитьОбОшибке(СтрокаСообщения, Отказ, Заголовок);

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ПроверитьЗаполнениеШапкиДокумента()

Процедура ПоказатьДиалогСИнформациейОбОшибке(ИнформацияОбОшибке) Экспорт
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		ПоказатьИнформациюОбОшибке(ИнформацияОбОшибке);
	#Иначе
		СообщитьОбОшибке(ПолучитьПричинуОшибки(ИнформацияОбОшибке).Описание);
	#КонецЕсли
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТАБЛИЦАМИ

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт

	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл

		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);

	КонецЦикла;

КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ

// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт

	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;

КонецФункции // ПолучитьСписокЭлементовПеречисления()

// Предназначена для получения имени элемента перечисления по значению.
//
// Параметры:
//	Элемент перечисления.
//
// Возвращаемое значение:
//	Строка - имя элемента перечисления в метаданных.
//
Функция ПолучитьИмяЭлементаПеречисленияПоЗначению(ЗначениеПеречисления) Экспорт
	
	ИмяЭлемента = Строка(ЗначениеПеречисления);
	Для каждого ЭлементПеречисления Из Метаданные.Перечисления[ЗначениеПеречисления.Метаданные().Имя].ЗначенияПеречисления Цикл
		Если ЭлементПеречисления.Синоним = Строка(ЗначениеПеречисления) Тогда
			ИмяЭлемента = ЭлементПеречисления.Имя;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат ИмяЭлемента;
	
КонецФункции // ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()

// сравнение значений перечислений на больше/меньше
// применяется для перечислений, для которых последовательность 
// значений имеет определяющее значение
//
// Параметры:
//  Значение1, Значение2 - сравниваемые значения перечислений
//
// Возвращаемое значение: число
//   1 - если Значение1 > Значение2
//  -1 - если Значение1 < Значение2
//   0 - если Значение1 = Значение2
//
Функция СравнениеПеречислений(Значение1, Значение2) Экспорт
    ИмяПеречисления = Метаданные.НайтиПоТипу(ТипЗнч(Значение1)).Имя;
    Менеджер = Перечисления[ИмяПеречисления];
    Если Менеджер.Индекс(Значение1) > Менеджер.Индекс(Значение2) Тогда
        Возврат 1;
    ИначеЕсли Менеджер.Индекс(Значение1) < Менеджер.Индекс(Значение2) Тогда
        Возврат -1;
    Иначе
        Возврат 0;
    КонецЕсли;
    
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт
	
	СтруктураШапкиДокумента = Новый Структура;
	СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Дата", ДокументОбъект.Дата);
	ИмяДокумента = ДокументОбъект.Метаданные().Имя;
	Для каждого Реквизит из Метаданные.Документы[ИмяДокумента].Реквизиты Цикл
		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
		Если Реквизит.Имя = "Организация" Тогда
			СтруктураШапкиДокумента.Вставить("ГоловнаяОрганизация", ОбщегоНазначения.ГоловнаяОрганизация(ДокументОбъект[Реквизит.Имя]));
		КонецЕсли;	
	КонецЦикла;

	Возврат СтруктураШапкиДокумента;
	
КонецФункции // СформироватьСтруктуруШапкиДокумента()

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений               - набор движений регистра,
//  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
//  реквизитов составного типа, которые могут содержать пустые ссылки.
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено,
	                                  ПустыеКолонкиСоставногоТипа = Неопределено) Экспорт

	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
		ПустыеКолонкиСоставногоТипа = Новый Структура;
	КонецЕсли;
	
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если (МетаИзм.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
		Если (МетаРек.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРек.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если (МетаРес.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРес.Имя);
		КонецЕсли;
	КонецЦикла;
	
	// Откопируем остальные колонки (структура таблиц совпадает).
	ПерваяКолонка = Истина;
	МассивСтрок   = Новый Массив(ТаблицаДвижений.Количество());
	Для каждого Колонка Из ТаблицаДвижений.Колонки Цикл

		ИмяКолонки = Колонка.Имя;
		Если ИмяКолонки <> "Период"
		   И ИмяКолонки <> "Активность"
		   И ИмяКолонки <> "НомерСтроки"
		   И ИмяКолонки <> ""
		   И ИмяКолонки <> "ВидДвижения" 
		   И ИмяКолонки <> "МоментВремени" Тогда
		   
			Если ИзмеренияСостТипа.Свойство(ИмяКолонки) Тогда
				ФлагКолонкиСостТипа = Истина;
			Иначе
				ФлагКолонкиСостТипа = Ложь;
			КонецЕсли;
			
			Индекс = 0;
			Для каждого СтрокаТаблицы Из ТаблицаДвижений Цикл

				Если ПерваяКолонка Тогда
					
					Если ВидДвижения = ВидДвиженияНакопления.Приход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьПриход();
					ИначеЕсли ВидДвижения = ВидДвиженияНакопления.Расход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьРасход();
					Иначе
						СтрокаДвижения = НаборДвижений.Добавить(); // Для оборотных регистров
					КонецЕсли;
					
					МассивСтрок[Индекс] = СтрокаДвижения;
					СтрокаДвижения.Период = НаборДвижений.мПериод;
					
				Иначе
					
					СтрокаДвижения = МассивСтрок[Индекс];
					
				КонецЕсли;
				
				Индекс = Индекс + 1;
				
				ЗначКолонки = СтрокаТаблицы[ИмяКолонки];
				Если ФлагКолонкиСостТипа Тогда

					Очистить = Ложь;
					Если ТипЗнч(ЗначКолонки) = Тип("Число")Тогда
						Если ЗначКолонки = 0 Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Строка") Тогда
						Если ЗначКолонки = "" Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Дата") Тогда
						Если ЗначКолонки = '00010101000000' Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ЗначКолонки = Неопределено Или ЗначКолонки.Пустая() Тогда
						Очистить = Истина;
					КонецЕсли;

					Если Очистить Тогда
						СтрокаДвижения[ИмяКолонки] = Неопределено;
					Иначе
						СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
					КонецЕсли;
				Иначе
					СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
				КонецЕсли;
				
			КонецЦикла;
			
			ПерваяКолонка = Ложь;
			
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Процедура удаления существующих движений документа при перепроведении (отмене проведения)
Процедура УдалитьДвиженияРегистратора(ДокументОбъект, Отказ, ОчищатьКоллекциюДвижений = ИСТИНА, РегистрыКБезусловномуУдалению = Неопределено) Экспорт
	
	// получение списка регистров, по которым существуют движения
	ТаблицаДвижений = ПолныеПрава.ОпределитьНаличиеДвиженийПоРегистратору(ДокументОбъект.Ссылка);
	ТаблицаДвижений.Колонки.Добавить("НаборЗаписей");
	ТаблицаДвижений.Колонки.Добавить("БезусловноеУдаление", Новый ОписаниеТипов("Булево"));
		
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		// имя регистра передается как значение, полученное с помощью
		// функции ПолноеИмя() метаданных регистра
		ПозицияТочки = Найти(СтрокаДвижения.Имя, ".");
		ТипРегистра = Лев(СтрокаДвижения.Имя, ПозицияТочки - 1);
		ИмяРегистра = СокрП(Сред(СтрокаДвижения.Имя, ПозицияТочки + 1));
		
		Если (НЕ РегистрыКБезусловномуУдалению = Неопределено) И РегистрыКБезусловномуУдалению.Свойство(ИмяРегистра) Тогда
			СтрокаДвижения.БезусловноеУдаление = Истина;
			Набор = ИмяРегистра;
			
		Иначе
			ЕСли ТипРегистра = "РегистрНакопления" Тогда
				МетаданныеНабора = Метаданные.РегистрыНакопления[ИмяРегистра];
				Набор = РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
				
			ИначеЕсли ТипРегистра = "РегистрБухгалтерии" Тогда
				МетаданныеНабора = Метаданные.РегистрыБухгалтерии[ИмяРегистра];
				Набор = РегистрыБухгалтерии[ИмяРегистра].СоздатьНаборЗаписей();
				
			ИначеЕсли ТипРегистра = "РегистрСведений" Тогда
				МетаданныеНабора = Метаданные.РегистрыСведений[ИмяРегистра];
				Набор = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
				
			ИначеЕсли ТипРегистра = "РегистрРасчета" Тогда
				МетаданныеНабора = Метаданные.РегистрыРасчета[ИмяРегистра];
				Набор = РегистрыРасчета[ИмяРегистра].СоздатьНаборЗаписей();
				
			КонецЕсли;
				
			Если НЕ ПравоДоступа("Изменение", МетаданныеНабора) Тогда
				// отсутствуют права на всю таблицу регистра
				СообщитьОбОшибке("Нарушение прав доступа", Отказ, СтрокаДвижения.Имя);
				Возврат;
			КонецЕсли;
				
			Набор.Отбор.Регистратор.Установить(ДокументОбъект.Ссылка);
		КонецЕсли;
		// набор не записывается сразу, чтобы не откатывать транзакцию, если впоследствии
		// выяснится, что на один из регистров не хватает прав.
		СтрокаДвижения.НаборЗаписей = Набор;
		
	КонецЦикла;
	
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		Если СтрокаДвижения.БезусловноеУдаление Тогда
			ПолныеПрава.ЗаписатьНаборЗаписейНаСервере(СтрокаДвижения.НаборЗаписей, ДокументОбъект.Ссылка);
			
		Иначе
			Попытка
				СтрокаДвижения.НаборЗаписей.Записать();
			Исключение
				// возможно «сработал» RLS или механизм даты запрета изменения
				СообщитьОбОшибке(ОписаниеОшибки(), Отказ, СтрокаДвижения.Имя);
				ВызватьИсключение "Операция не выполнена";
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	
	Если ОчищатьКоллекциюДвижений Тогда
		Для Каждого Движение ИЗ ДокументОбъект.Движения Цикл
			Если Движение.Количество() > 0 Тогда
				Движение.Очистить();
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// МАТЕМАТИКА

// возвращает "количество полных и неполных рублей"
// Параметры:
//	Сумма - число
// Возвращаемое значение:
//  число, равное ближайшему целому "сверху"
Функция ЦелМаксимальное(Сумма) Экспорт
	Возврат ?(Цел(Сумма) = Сумма, Сумма, Цел(Сумма) + 1);
	
КонецФункции // ЦелМаксимальное()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(СтрокаПроверки, а);
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(СтрокаПроверки, а);
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 

	Возврат Истина;
	
КонецФункции

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//		ИсхСумма - распределяемая сумма
//		МассивКоэф - массив коэффициентов распределения
//		Точность - точность округления при распределении. Необязателен.
//
//	Возврат:
//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
//vvv меняем точность по умолчанию на 2
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт
	
	Если МассивКоэф.Количество() = 0 Или ИсхСумма = 0 Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		
		МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);
		
		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач = МодульЧисла;
			ИндексМакс = К;
		КонецЕсли;
		
		СуммаКоэф = СуммаКоэф + МассивКоэф[К];
		
	КонецЦикла;
	
	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСумм = Новый Массив(МассивКоэф.Количество());
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		РаспрСумма = РаспрСумма + МассивСумм[К];
	КонецЦикла;
	
	// Погрешности округления отнесем на коэффицент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;
	
	Возврат МассивСумм;
	
КонецФункции // РаспределитьПропорционально()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ИНТЕРНЕТ-ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

#Если Клиент Тогда

// Производит проверку наличия комплекта обновления и 
// открывает форму для просмотра результатов проверки
Процедура ПроверкаНаличияКомплектаОбновлений() Экспорт

	Обозреватель = Обработки.Обозреватель.Создать();
	Форма        = Обозреватель.ПолучитьФорму("ПроверкаНаличияОбновления");

	Обозреватель.Проверить(Форма.ЭлементыФормы);

	Форма.Открыть();

КонецПроцедуры

// Процедура выполняет открытие HTML-страницы 
// по указанному URL
Процедура Интерфейс1Действие() Экспорт
	Форма = Обработки.Обозреватель.ПолучитьФорму("Форма",,"Опрос");
	Форма.Заголовок = "Отзыв о программе";
	Форма.СтартоваяСтраница = "www.1c.ru/usability/inquirer/hr.jsp";
	Форма.Открыть();
КонецПроцедуры

#КонецЕсли

// Получаем из полного номера версии конфигурации номер релиза без номера сборки.
//
// Параметры
//  НомерВерсии  – Строка – полный номер версии
//
// Возвращаемое значение:
//  Строка – номер релиза без номера сборки
//
Функция ПолучитьНомерРелиза(НомерВерсии) Экспорт

	КоличествоТочек = 0;
	ДлинаОписанияНомераРелиза = 0;

	Для х = 1 По СтрДлина(НомерВерсии) Цикл

		Если Сред(НомерВерсии, х, 1) = "." Тогда
			КоличествоТочек = КоличествоТочек + 1;
		КонецЕсли;

		Если КоличествоТочек = 3 Тогда
			ДлинаОписанияНомераРелиза = х - 1;
			Прервать;
		КонецЕсли;

	КонецЦикла;

	Возврат Лев(НомерВерсии, ДлинаОписанияНомераРелиза);

КонецФункции // ПолучитьНомерРелиза()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Функнция проверяет заполнения обязательных параметров для отправки сообщения
//  в отдел технической поддержки.
//
// Параметры
//  ТаблицаДанных - Таблица значений
//
// Возвращаемое значение:
//   Булево - результат корректости проверки
//
Функция ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(ТаблицаДанных, ПубликоватьСообщения = Истина) Экспорт

	ЗначениеПроверки = Истина;
	СтрокаЗаголовкаОшибки = "Не заполнены настройки для отправки сообщения.";
	
	СписокИменОбязательныхРеквизитов = Новый СписокЗначений;
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");
	СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");
	СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");
	
	Для каждого СтрокаРаздела Из ТаблицаДанных Цикл
		Для каждого ЭлементЗначения Из СтрокаРаздела.ДанныеРаздела Цикл
			Если СписокИменОбязательныхРеквизитов.НайтиПоЗначению(ЭлементЗначения.Ключ) <> Неопределено И НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
				Если ПубликоватьСообщения Тогда
					СообщитьОбОшибке("Не указан """ + Лев(ЭлементЗначения.Значение[0], (СтрДлина(ЭлементЗначения.Значение[0]) - 1)) + """.",, СтрокаЗаголовкаОшибки);
				КонецЕсли; 
				ЗначениеПроверки = Ложь;
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
	Возврат ЗначениеПроверки;

КонецФункции // ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()

// Процедура формирует таблицу значений со структурой для заполнения данными
// с информацией обращения в отдел технической поддержки
//
// Параметры:
//  ТаблицаДанных - таблица значений для заполнения
//  ФормаНастройкиПараметров - общая форма настройки параметров для отправки в отдел технической поддержки
//
Процедура ЗаполнитьСтруктуруДанныхНастройкиОбращенияВОтделТехподдержкиПоУмолчанию(ТаблицаДанных, ФормаНастройкиПараметров = Неопределено) Экспорт

	// Структура данных - таблица значений:
	//  Колонки:
	//   ИмяРездела
	//   ПредставлениеРаздела
	//   ДанныеРаздела
	
	// Структура данных раздела
	//  Ключ - Имя значения настройки, как оно задано в форме настройки параметров обращения
	//  Значение - Массив значений
	// 
	// Массив значений:
	//  [0] - Представление наименования параметра для печати
	//  [1] - Значение параметра

	Если ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений") Тогда
		ТаблицаДанных = Новый ТаблицаЗначений;
	КонецЕсли;
	
	Если ТаблицаДанных.Колонки.Количество() = 0 Тогда
		ТаблицаДанных.Колонки.Добавить("ИндексСортировки"    , Новый ОписаниеТипов("Число"));
		ТаблицаДанных.Колонки.Добавить("ИмяРаздела"          , Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ПредставлениеРаздела", Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ДанныеРаздела"       , Новый ОписаниеТипов("Структура"));
	КонецЕсли; 
	
	ТаблицаДанных.Индексы.Добавить("ИмяРаздела");
	
	Если ФормаНастройкиПараметров = Неопределено Тогда
		ФормаНастройкиПараметров = ПолучитьОбщуюФорму("НастройкаПараметровОбращенияВОтделТехническойПоддержки");
	КонецЕсли;
	
	Для каждого ЭлементФормы Из ФормаНастройкиПараметров.ЭлементыФормы Цикл
		
		Если ТипЗнч(ЭлементФормы) <> Тип("ПолеВвода")
		   И ТипЗнч(ЭлементФормы) <> Тип("ПолеВыбора")
		   И ТипЗнч(ЭлементФормы) <> Тип("Флажок") Тогда
			Продолжить;
		КонецЕсли;
		
		ПозицияРазделителяРаздела = Найти(ЭлементФормы.Имя, "_");
		Если ПозицияРазделителяРаздела = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяРаздела = Сред(ЭлементФормы.Имя, 1, (ПозицияРазделителяРаздела - 1));
		СтрокаРаздела = ТаблицаДанных.Найти(ИмяРаздела, "ИмяРаздела");
		Если СтрокаРаздела = Неопределено Тогда
			СтрокаРаздела = ТаблицаДанных.Добавить();
			СтрокаРаздела.ИмяРаздела           = ИмяРаздела;
			Попытка
				СтрокаРаздела.ПредставлениеРаздела = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела].Заголовок;
				СтрокаРаздела.ИндексСортировки     = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы.Индекс(ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела]);
			Исключение
				СтрокаРаздела.ПредставлениеРаздела = ИмяРаздела;
			КонецПопытки;
		КонецЕсли;
		
		МассивЗначений = Новый Массив;
		Попытка
			Если ТипЗнч(ЭлементФормы) = Тип("Флажок") Тогда
				МассивЗначений.Добавить((ЭлементФормы.Заголовок + ":"));
			Иначе
				МассивЗначений.Добавить(ФормаНастройкиПараметров.ЭлементыФормы["Надпись_" + ЭлементФормы.Имя].Заголовок);
			КонецЕсли; 
		Исключение
			МассивЗначений.Добавить(ЭлементФормы.Имя);
		КонецПопытки;
		МассивЗначений.Добавить("");
		
		СтрокаРаздела.ДанныеРаздела.Вставить(ЭлементФормы.Имя, МассивЗначений);
		
	КонецЦикла;
	
	ТаблицаДанных.Сортировать("ИндексСортировки ВОЗР");
	
КонецПроцедуры

// Функция формирует текст сообщения на линию техподдержки
//
// Параметры
//  НЕТ
//
// Возвращаемое значение:
//   Текст сообщения
//
Функция ПолучитьТекстСообщенияВОтделТехническойПоддержки() Экспорт

	ТекстВозврата = "";
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "============ Сведения об использовании ПП 1С:Предприятие 8.0 ============";
	
	ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();
	
	// Сформируем обязательный информационный раздел
	
	СистемИнфо = Новый СистемнаяИнформация;
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8.0: " + СистемИнфо.ВерсияПриложения;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия конфигурации: "       + Метаданные.Версия;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;

	НомерСтрокиРаздела = 1;
	
	Если ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицыРаздела Из ТаблицаДанных Цикл
			
			СтрокаРаздела = "";
			
			Если СтрокаТаблицыРаздела.ИмяРаздела = "ПараметрыОтправкиЭлектронногоСообщения" Тогда
				Продолжить;
			КонецЕсли;
			
			Для каждого ЭлементЗначения Из СтрокаТаблицыРаздела.ДанныеРаздела Цикл
				Если НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
					Продолжить;
				КонецЕсли; 
				СтрокаРаздела = СтрокаРаздела + Символы.ПС + ЭлементЗначения.Значение[0] + " " + ?(ТипЗнч(ЭлементЗначения.Значение[1]) = Тип("Булево"), ?(ЭлементЗначения.Значение[1], "Да", "Нет"), ЭлементЗначения.Значение[1]);
			КонецЦикла; 
			
			Если НЕ ЗначениеЗаполнено(СтрокаРаздела) Тогда
				Продолжить;
			КонецЕсли;
			
			НомерСтрокиРаздела = НомерСтрокиРаздела + 1;
			
			СтрокаРаздела = Строка(НомерСтрокиРаздела) + ". " + ВРег(СтрокаТаблицыРаздела.ПредставлениеРаздела) + СтрокаРаздела;
			
			ТекстВозврата = ТекстВозврата + Символы.ПС;
			ТекстВозврата = ТекстВозврата + Символы.ПС + СтрокаРаздела;
		
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ТекстВозврата;

КонецФункции // ПолучитьТекстСообщенияВОтделТехническойПоддержки()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ФАЙЛАМИ


// функция возвращает часть строки после последнего встреченного символа в строке
Функция ПолучитьЧастьСтрокиОтделеннойСимволом(Знач ИсходнаяСтрока, Знач СимволПоиска)
	
	ПозицияСимвола = СтрДлина(ИсходнаяСтрока);
	Пока ПозицияСимвола >= 1 Цикл
		
		Если Сред(ИсходнаяСтрока, ПозицияСимвола, 1) = СимволПоиска Тогда
						
			Возврат Сред(ИсходнаяСтрока, ПозицияСимвола + 1); 
			
		КонецЕсли;
		
		ПозицияСимвола = ПозицияСимвола - 1;	
	КонецЦикла;

	Возврат "";
  	
КонецФункции

// Выделяет из имени файла его расширение (набор символов после последней точки).
//
// Параметры
//  ИмяФайла     – Строка, содержащая имя файла, неважно с именем каталога или без.
//
// Возвращаемое значение:
//   Строка – расширение файла.
//
Функция ПолучитьРасширениеФайла(Знач ИмяФайла) Экспорт
	
	Расширение = ПолучитьЧастьСтрокиОтделеннойСимволом(ИмяФайла, ".");
	Возврат Расширение;
	
КонецФункции

// Выделяет из полного пути к файлу его имя (набор символов после последней \).
//
// Параметры
//  ПутьКФайлу     – Строка, содержащая имя файла, неважно с именем каталога или без.
//
// Возвращаемое значение:
//   Строка – расширение файла.
//
Функция ПолучитьИмяФайлаИзПолногоПути(Знач ПутьКФайлу) Экспорт
	
	ИмяФайла = ПолучитьЧастьСтрокиОтделеннойСимволом(ПутьКФайлу, "\");
	Возврат ИмяФайла;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
	
	Если ПараметрыСеанса.ИспользованиеРИБ Тогда
		Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;
	КонецЕсли;
	
КонецПроцедуры

Функция ОпределитьТекущийРежимРаботыМонопольный() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл
		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Процедура СообщитьИнформацияОПрефиксации() Экспорт
	
	Если ПустаяСтрока(ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы) Тогда
		
		Сообщить("Для задействования механизма установки префиксов объектов необходимо установить константу ""Префикс узла для распределенной информационной базы"" 
			| и перезапустить текущий сеанс работы 1С:Предприятия.");
		Сообщить("Текущее значение префикса: " + ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы);
		
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА КОНТРОЛЯ ПЕРИОДОВ

// Функция возвращает текст запроса для получения периодов использования ресурсов
// Параметры:
//	ИмяРегистра		- имя регистра
//	ДатаНачала		- имя параметра "дата начала" интревала за который необходимо получить периоды, 
//					  если не задана - то "от самого начала"
//	ДатаОкончания	- имя параметра "дата окончания" интервала за который необходимо получить периоды, 
//					  если не задана - то "до самомго конца"
//	Условие			- условие, по которому отбираются перичные записи регистра. Условия пишется на поля 
//					  регистра периодов с применением алиаса "Периоды". Например: "Периоды.Физлицо В (&Физлица)"
//
// Возвращает:
//	Текст запроса, содержащий поля:
//		Регистратор1	- ссылка на регистратор, который определяет период
//		Регистратор2	- ссылка на второй регистратор, который определяет период (для 
//						  периодов, которые определяются двумя событиями)
//		<Измерение>		- все измерения регистра кроме ДатаНачала и ДатаОкончания
//		ДатаНачала		- начало полученного виртуального периода
//		ДатаОкончания	- окончание полученного виртуального периода
//
Функция ПериодыИспользованияРесурсов(ИмяРегистра, ДатаНачала = Неопределено, ДатаОкончания = Неопределено, Условие = "", УчитыватьРегистратор = Истина) Экспорт
	
	ИмяТаблицы = "РегистрСведений." + ИмяРегистра;
	РегистрМД = Метаданные.НайтиПоПолномуИмени(ИмяТаблицы);
	Измерения = Новый Массив;
	Для Каждого Измерение Из РегистрМД.Измерения Цикл
		Имя = Измерение.Имя;
		Если Имя = "ДатаНачала" или Имя = "ДатаОкончания" Тогда
			Продолжить;
		КонецЕсли;
		Измерения.Добавить(Имя);
	КонецЦикла;
		
	Текст =
	"ВЫБРАТЬ";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "
		|	Периоды." + Измерение + " КАК " + Измерение + ",";
	КонецЦикла;
	Текст = Текст + "            
	|	Периоды.Регистратор КАК Регистратор1,
	|	NULL КАК Регистратор2,
	|	Периоды.ДатаНачала КАК ДатаНачала,
	|	ВЫБОР
	|		КОГДА МИНИМУМ(ПериодыВсп.ДатаНачала) ЕСТЬ NULL 
	|			ТОГДА Периоды.ДатаОкончания
	|		ИНАЧЕ МИНИМУМ(ПериодыВсп.ДатаНачала)
	|	КОНЕЦ КАК ДатаОкончания
	|ИЗ
	|	" + ИмяТаблицы + " КАК Периоды
	|	ЛЕВОЕ СОЕДИНЕНИЕ " + ИмяТаблицы + " КАК ПериодыВсп
	|	ПО ";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "
		|	Периоды." + Измерение + " = ПериодыВсп." + Измерение + "
		|   И ";
	КонецЦикла;
	Текст = Текст + "ПериодыВсп.ДатаНачала > Периоды.ДатаНачала
	|			И ПериодыВсп.ДатаНачала < Периоды.ДатаОкончания
	|	ЛЕВОЕ СОЕДИНЕНИЕ " + ИмяТаблицы + " КАК Проверка
	|	ПО ";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "
		|	Периоды." + Измерение + " = Проверка." + Измерение + "
		|   И ";
	КонецЦикла;
	Текст = Текст + "Проверка.ДатаОкончания > Периоды.ДатаНачала
	|		И Проверка.ДатаОкончания < Периоды.ДатаОкончания
	|		И (Проверка.ДатаНачала = ДАТАВРЕМЯ(1, 1, 1))
	|ГДЕ";
	Если Не ПустаяСтрока(Условие) Тогда
		Текст = Текст + "
		|" + Условие + "
		|	И ";
	КонецЕсли;
	Если Не УчитыватьРегистратор Тогда
		Текст = Текст + "
		|Периоды.Регистратор <> &Регистратор
		|	И ";
	КонецЕсли;		
	Если ДатаНачала <> Неопределено Тогда
		Текст = Текст + "ВЫБОР КОГДА Периоды.ДатаНачала = ДАТАВРЕМЯ(1,1,1) ТОГДА Периоды.ДатаОкончания ИНАЧЕ Периоды.ДатаНачала КОНЕЦ >= &" + ДатаНачала + "
		|	И ";
	КонецЕсли;
	Если ДатаОкончания <> Неопределено Тогда
		Текст = Текст + "ВЫБОР КОГДА Периоды.ДатаНачала = ДАТАВРЕМЯ(1,1,1) ТОГДА Периоды.ДатаОкончания ИНАЧЕ Периоды.ДатаНачала КОНЕЦ <= &" + ДатаОкончания + "
		|	И ";
	КонецЕсли;
	Текст = Текст + "Периоды.ДатаНачала <> ДАТАВРЕМЯ(1,1,1)
	|	И Периоды.ДатаОкончания <> ДАТАВРЕМЯ(1,1,1)
	|	И Проверка.ДатаНачала ЕСТЬ NULL
	|
	|	СГРУППИРОВАТЬ ПО";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "
		|	Периоды." + Измерение + ",";
	КонецЦикла;
	Текст = Текст + "
	|		Периоды.Регистратор,
	|		Периоды.ДатаНачала,
	|		Периоды.ДатаОкончания
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ РАЗЛИЧНЫЕ";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "
		|   Периоды." + Измерение + " КАК " + Измерение + ",";
	КонецЦикла;
	Текст = Текст + "
	|	Периоды.Регистратор1,
	|	Периоды.Регистратор2,
	|	Периоды.ДатаНачала,
	|	Периоды.ДатаОкончания
	|ИЗ
	|	(ВЫБРАТЬ";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "
		|		МаксимальныеПериоды." + Измерение +" КАК " + Измерение +",";
	КонецЦикла;
	Текст = Текст + "
	|		Периоды.Регистратор КАК Регистратор1,
	|		ВЫБОР КОГДА МаксимальныеПериоды.Регистратор <> Периоды.Регистратор ТОГДА МаксимальныеПериоды.Регистратор КОНЕЦ КАК Регистратор2,
	|		ЕСТЬNULL(Периоды.ДатаНачала, ДАТАВРЕМЯ(1,1,1)) КАК ДатаНачала,
	|		МаксимальныеПериоды.ДатаОкончания КАК ДатаОкончания
	|	ИЗ
	|		(ВЫБРАТЬ
	|			Периоды.Регистратор КАК Регистратор,";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "
		|			Периоды." + Измерение +" КАК " + Измерение +",";
	КонецЦикла;
	Текст = Текст + "
	|			Периоды.ДатаОкончания КАК ДатаОкончания,
	|			МАКСИМУМ(ПериодыПредыдущие.ДатаНачала) КАК МаксДата
	|		ИЗ
	|			" + ИмяТаблицы + " КАК Периоды
	|				ЛЕВОЕ СОЕДИНЕНИЕ " + ИмяТаблицы + " КАК ПериодыПредыдущие
	|				ПО ";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "Периоды." + Измерение +" = ПериодыПредыдущие." + Измерение +"
		|				И ";
	КонецЦикла;
	Если Не УчитыватьРегистратор Тогда
		Текст = Текст + "
		|ПериодыПредыдущие.Регистратор <> &Регистратор
		|	И ";
	КонецЕсли;		
	Текст = Текст + "Периоды.ДатаОкончания > ПериодыПредыдущие.ДатаНачала
	|		ГДЕ";
	Если Не ПустаяСтрока(Условие) Тогда
		Текст = Текст + "
		|" + Условие + "
		|	И ";
	КонецЕсли;
	Если Не УчитыватьРегистратор Тогда
		Текст = Текст + "
		|Периоды.Регистратор <> &Регистратор
		|	И ";
	КонецЕсли;		
	Если ДатаНачала <> Неопределено Тогда
		Текст = Текст + "ВЫБОР КОГДА Периоды.ДатаНачала = ДАТАВРЕМЯ(1,1,1) ТОГДА Периоды.ДатаОкончания ИНАЧЕ Периоды.ДатаНачала КОНЕЦ >= &" + ДатаНачала + "
		|	И ";
	КонецЕсли;
	Если ДатаОкончания <> Неопределено Тогда
		Текст = Текст + "ВЫБОР КОГДА Периоды.ДатаНачала = ДАТАВРЕМЯ(1,1,1) ТОГДА Периоды.ДатаОкончания ИНАЧЕ Периоды.ДатаНачала КОНЕЦ <= &" + ДатаОкончания + "
		|	И ";
	КонецЕсли;
	Текст = Текст + "Периоды.ДатаНачала = ДАТАВРЕМЯ(1,1,1)
	|		
	|		СГРУППИРОВАТЬ ПО
	|			Периоды.Регистратор,";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "
		|			Периоды." + Измерение +",";
	КонецЦикла;
	Текст = Текст + "
	|			Периоды.ДатаОкончания) КАК МаксимальныеПериоды
	|			ЛЕВОЕ СОЕДИНЕНИЕ " + ИмяТаблицы + " КАК Периоды
	|			ПО ";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "Периоды." + Измерение +" = МаксимальныеПериоды." + Измерение +"
		|				И ";
	КонецЦикла;
	Текст = Текст + "МаксимальныеПериоды.МаксДата = Периоды.ДатаНачала
	|				И (Периоды.ДатаНачала <> ДАТАВРЕМЯ(1,1,1))
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ВЫБРАТЬ";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "
		|		МинимальныеПериоды." + Измерение +",";
	КонецЦикла;
	Текст = Текст + "
	|		МинимальныеПериоды.Регистратор КАК Регистратор1,
	|		ВЫБОР КОГДА Периоды.Регистратор <> МинимальныеПериоды.Регистратор ТОГДА Периоды.Регистратор КОНЕЦ КАК Регистратор2,
	|		МинимальныеПериоды.ДатаНачала,
	|		ЕСТЬNULL(Периоды.ДатаОкончания, ДАТАВРЕМЯ(1,1,1))
	|	ИЗ
	|		(ВЫБРАТЬ
	|			Периоды.Регистратор КАК Регистратор,";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "
		|			Периоды." + Измерение +" КАК " + Измерение +",";
	КонецЦикла;
	Текст = Текст + "
	|			Периоды.ДатаНачала КАК ДатаНачала,
	|			МИНИМУМ(ПериодыСледующие.ДатаОкончания) КАК МинДата
	|		ИЗ
	|			" + ИмяТаблицы + " КАК Периоды
	|				ЛЕВОЕ СОЕДИНЕНИЕ " + ИмяТаблицы + " КАК ПериодыСледующие
	|				ПО ";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "Периоды." + Измерение +" = ПериодыСледующие." + Измерение +"
		|				И ";
	КонецЦикла;
	Если Не УчитыватьРегистратор Тогда
		Текст = Текст + "
		|ПериодыСледующие.Регистратор <> &Регистратор
		|	И ";
	КонецЕсли;		
	Текст = Текст + "Периоды.ДатаНачала < ПериодыСледующие.ДатаОкончания
	|		И ПериодыСледующие.ДатаНачала = ДАТАВРЕМЯ(1,1,1)
	|		ГДЕ";
	Если Не ПустаяСтрока(Условие) Тогда
		Текст = Текст + "
		|" + Условие + "
		|	И ";
	КонецЕсли;
	Если Не УчитыватьРегистратор Тогда
		Текст = Текст + "
		|Периоды.Регистратор <> &Регистратор
		|	И ";
	КонецЕсли;		
	Если ДатаНачала <> Неопределено Тогда
		Текст = Текст + "ВЫБОР КОГДА Периоды.ДатаНачала = ДАТАВРЕМЯ(1,1,1) ТОГДА Периоды.ДатаОкончания ИНАЧЕ Периоды.ДатаНачала КОНЕЦ >= &" + ДатаНачала + "
		|	И ";
	КонецЕсли;
	Если ДатаОкончания <> Неопределено Тогда
		Текст = Текст + "ВЫБОР КОГДА Периоды.ДатаНачала = ДАТАВРЕМЯ(1,1,1) ТОГДА Периоды.ДатаОкончания ИНАЧЕ Периоды.ДатаНачала КОНЕЦ <= &" + ДатаОкончания + "
		|	И ";
	КонецЕсли;
	Текст = Текст + "Периоды.ДатаОкончания = ДАТАВРЕМЯ(1,1,1)
	|		
	|		СГРУППИРОВАТЬ ПО
	|			Периоды.Регистратор,";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "
		|			Периоды." + Измерение +",";
	КонецЦикла;
	Текст = Текст + "
	|			Периоды.ДатаНачала) КАК МинимальныеПериоды
	|			ЛЕВОЕ СОЕДИНЕНИЕ " + ИмяТаблицы + " КАК Периоды
	|			ПО ";
	Для Каждого Измерение Из Измерения Цикл
		Текст = Текст + "Периоды." + Измерение +" = МинимальныеПериоды." + Измерение +"
		|				И ";
	КонецЦикла;
	Текст = Текст + "МинимальныеПериоды.МинДата = Периоды.ДатаОкончания
	|				И (Периоды.ДатаОкончания <> ДАТАВРЕМЯ(1,1,1))) КАК Периоды";
	Возврат Текст;
	
КонецФункции


Процедура ПолучитьОшибкиПериодовРаботыСотрудникаПоОсновномуМестуРаботы(Регистратор, УчитыватьРегистратор, МассивФизлица, СообщенияОбОшибках, ОшибкиПериодов) Экспорт
	
	Запрос = Новый Запрос;
	
	ТаблицаПериодов = ПериодыИспользованияРесурсов("ПериодыРаботыРаботниковОрганизацийПоОсновномуМестуРаботы", , , "Периоды.Физлицо В (&Физлица)", УчитыватьРегистратор);
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Регистратор1,
	|	Регистратор2,
	|	ПРЕДСТАВЛЕНИЕ(Регистратор1) КАК ПредставлениеРегистратор1,
	|	ПРЕДСТАВЛЕНИЕ(Регистратор2) КАК ПредставлениеРегистратор2,
	|	Физлицо,
	|	Физлицо.Наименование КАК ФизлицоНаименование,
	|	ДатаНачала,
	|	ДатаОкончания
	|ИЗ
	|	(" + ТаблицаПериодов + ") КАК Периоды
	|УПОРЯДОЧИТЬ ПО
	|	ФизлицоНаименование,
	|	ДатаНачала";
	
	Запрос.УстановитьПараметр("Регистратор",	Регистратор);
	Запрос.УстановитьПараметр("Физлица",		МассивФизлица);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	// обработаем периоды
	ТекущееФизлицо						= Неопределено;
	ПоследняяДатаНачала					= '0001-01-01';
	ПоследняяДатаОкончания				= '0001-01-01';
	ПоследнийРегистратор1				= Неопределено;
	ПоследнийРегистратор2				= Неопределено;
	ПоследнийПредставлениеРегистратор1	= "";
	ПоследнийПредставлениеРегистратор2	= "";
	
	Пока Выборка.Следующий() Цикл
		
		Если ТекущееФизлицо <> Выборка.Физлицо Тогда
			ТекущееФизлицо = Выборка.Физлицо;
			
		ИначеЕсли (ПоследняяДатаОкончания > Выборка.ДатаНачала) ИЛИ (ПоследняяДатаОкончания = '0001-01-01') Тогда
			Если ОшибкиПериодов <> НеОпределено Тогда
				ОшибкиПериодов[Выборка.Физлицо] = 0;
			КонецЕсли;
			// сообщения формируем для переданного регистратора или все, если регистратор не задан 
			Если СообщенияОбОшибках <> НеОпределено и
				(	Регистратор = НеОпределено ИЛИ
					ПоследнийРегистратор1 = Регистратор ИЛИ
					ПоследнийРегистратор2 = Регистратор ИЛИ
					Выборка.Регистратор1 = Регистратор ИЛИ
					Выборка.Регистратор2 = Регистратор) Тогда
				СообщениеОбОшибке = Новый Структура("Физлицо, 
													|ДатаНачала, 
													|ДатаОкончания, 
													|ДатаНачалаПред, 
													|ДатаОкончанияПред, 
													|Регистратор1, 
													|Регистратор2, 
													|ПослРегистратор1, 
													|ПослРегистратор2,
													|Регистратор1Ссылка, 
													|Регистратор2Ссылка, 
													|ПослРегистратор1Ссылка, 
													|ПослРегистратор2Ссылка");
				СообщениеОбОшибке.Физлицо			= Выборка.ФизлицоНаименование;
				СообщениеОбОшибке.ДатаНачала		= Выборка.ДатаНачала;
				СообщениеОбОшибке.ДатаОкончания		= Выборка.ДатаОкончания;
				СообщениеОбОшибке.ДатаНачалаПред	= ПоследняяДатаНачала;
				СообщениеОбОшибке.ДатаОкончанияПред	= ПоследняяДатаОкончания;
				
				СообщениеОбОшибке.Регистратор1Ссылка 		= Выборка.Регистратор1;
				СообщениеОбОшибке.Регистратор2Ссылка 		= Выборка.Регистратор2;
				СообщениеОбОшибке.ПослРегистратор1Ссылка 	= ПоследнийРегистратор1;
				СообщениеОбОшибке.ПослРегистратор2Ссылка 	= ПоследнийРегистратор2;
				
				Если Выборка.Регистратор1 = Регистратор Тогда
					СообщениеОбОшибке.Регистратор1 = Выборка.ПредставлениеРегистратор1 + " (текущий документ)";
				Иначе
					СообщениеОбОшибке.Регистратор1 = "" + Выборка.ПредставлениеРегистратор1;
				КонецЕсли;
				
				Если Выборка.Регистратор2 = Регистратор Тогда
					СообщениеОбОшибке.Регистратор2 = Выборка.ПредставлениеРегистратор2 + " (текущий документ)";
				Иначе
					СообщениеОбОшибке.Регистратор2 = "" + Выборка.ПредставлениеРегистратор2;
				КонецЕсли;
				
				Если Выборка.Регистратор1 <> ПоследнийРегистратор1 
					и Выборка.Регистратор2 <> ПоследнийРегистратор1 Тогда
					Если ПоследнийРегистратор1 = Регистратор Тогда
						СообщениеОбОшибке.ПослРегистратор1 = ПоследнийПредставлениеРегистратор1 + " (текущий документ)";
					Иначе
						СообщениеОбОшибке.ПослРегистратор1 = "" + ПоследнийПредставлениеРегистратор1;
					КонецЕсли;
				КонецЕсли;
				
				Если Выборка.Регистратор1 <> ПоследнийРегистратор2 
					и Выборка.Регистратор2 <> ПоследнийРегистратор2 Тогда
					Если ПоследнийРегистратор2 = Регистратор Тогда
						СообщениеОбОшибке.ПослРегистратор2 = ПоследнийПредставлениеРегистратор2 + " (текущий документ)";
					Иначе
						СообщениеОбОшибке.ПослРегистратор2 = "" + ПоследнийПредставлениеРегистратор2;
					КонецЕсли;
				КонецЕсли;
				
				СообщенияОбОшибках.Добавить(СообщениеОбОшибке);
				
			КонецЕсли;
		КонецЕсли;
		
		ПоследнийРегистратор1				= Выборка.Регистратор1;
		ПоследнийРегистратор2				= Выборка.Регистратор2;
		ПоследнийПредставлениеРегистратор1	= Выборка.ПредставлениеРегистратор1;;
		ПоследнийПредставлениеРегистратор2	= Выборка.ПредставлениеРегистратор2;
		ПоследняяДатаНачала					= Выборка.ДатаНачала;
		ПоследняяДатаОкончания				= Выборка.ДатаОкончания;
	КонецЦикла;
	
КонецПроцедуры

Процедура ПолучитьОшибкиПериодовРаботыСотрудникаПоСовместительству(Регистратор, УчитыватьРегистратор, МассивФизлица, Организация, СообщенияОбОшибках, ОшибкиПериодов) Экспорт
	
	Запрос = Новый Запрос;
	
	ТаблицаПериодов = ПериодыИспользованияРесурсов("ПериодыРаботыРаботниковОрганизацийПоСовместительству", , , "Периоды.Физлицо В (&Физлица) И Периоды.Организация = &Организация", УчитыватьРегистратор);
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Регистратор1,
	|	Регистратор2,
	|	ПРЕДСТАВЛЕНИЕ(Регистратор1) КАК ПредставлениеРегистратор1,
	|	ПРЕДСТАВЛЕНИЕ(Регистратор2) КАК ПредставлениеРегистратор2,
	|	Физлицо,
	|	Физлицо.Наименование КАК ФизлицоНаименование,
	|	ДатаНачала,
	|	ДатаОкончания
	|ИЗ
	|	(" + ТаблицаПериодов + ") КАК Периоды
	|УПОРЯДОЧИТЬ ПО
	|	ФизлицоНаименование,
	|	ДатаНачала";
	
	Запрос.УстановитьПараметр("Регистратор",	Регистратор);
	Запрос.УстановитьПараметр("Организация",	Организация);
	Запрос.УстановитьПараметр("Физлица",		МассивФизлица);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	// обработаем периоды
	ТекущееФизлицо						= Неопределено;
	ПоследняяДатаНачала					= '0001-01-01';
	ПоследняяДатаОкончания				= '0001-01-01';
	ПоследнийРегистратор1				= Неопределено;
	ПоследнийРегистратор2				= Неопределено;
	ПоследнийПредставлениеРегистратор1	= "";
	ПоследнийПредставлениеРегистратор2	= "";
	
	Пока Выборка.Следующий() Цикл
		
		Если ТекущееФизлицо <> Выборка.Физлицо Тогда
			ТекущееФизлицо = Выборка.Физлицо;
			
		ИначеЕсли (ПоследняяДатаОкончания > Выборка.ДатаНачала) ИЛИ (ПоследняяДатаОкончания = '0001-01-01') Тогда
			Если ОшибкиПериодов <> НеОпределено Тогда
				ОшибкиПериодов[Выборка.Физлицо] = 0;
			КонецЕсли;
			// сообщения формируем для переданного регистратора или все, если регистратор не задан 
			Если СообщенияОбОшибках <> НеОпределено и
				(	Регистратор = НеОпределено ИЛИ
					ПоследнийРегистратор1 = Регистратор ИЛИ
					ПоследнийРегистратор2 = Регистратор ИЛИ
					Выборка.Регистратор1 = Регистратор ИЛИ
					Выборка.Регистратор2 = Регистратор) Тогда
				СообщениеОбОшибке = Новый Структура("Физлицо, 
													|ДатаНачала, 
													|ДатаОкончания, 
													|ДатаНачалаПред, 
													|ДатаОкончанияПред, 
													|Регистратор1, 
													|Регистратор2, 
													|ПослРегистратор1, 
													|ПослРегистратор2,
													|Регистратор1Ссылка, 
													|Регистратор2Ссылка, 
													|ПослРегистратор1Ссылка, 
													|ПослРегистратор2Ссылка");
				СообщениеОбОшибке.Физлицо			= Выборка.ФизлицоНаименование;
				СообщениеОбОшибке.ДатаНачала		= Выборка.ДатаНачала;
				СообщениеОбОшибке.ДатаОкончания		= Выборка.ДатаОкончания;
				СообщениеОбОшибке.ДатаНачалаПред	= ПоследняяДатаНачала;
				СообщениеОбОшибке.ДатаОкончанияПред	= ПоследняяДатаОкончания;
				
				СообщениеОбОшибке.Регистратор1Ссылка 		= Выборка.Регистратор1;
				СообщениеОбОшибке.Регистратор2Ссылка 		= Выборка.Регистратор2;
				СообщениеОбОшибке.ПослРегистратор1Ссылка 	= ПоследнийРегистратор1;
				СообщениеОбОшибке.ПослРегистратор2Ссылка 	= ПоследнийРегистратор2;
				
				Если Выборка.Регистратор1 = Регистратор Тогда
					СообщениеОбОшибке.Регистратор1 = Выборка.ПредставлениеРегистратор1 + " (текущий документ)";
				Иначе
					СообщениеОбОшибке.Регистратор1 = "" + Выборка.ПредставлениеРегистратор1;
				КонецЕсли;
				
				Если Выборка.Регистратор2 = Регистратор Тогда
					СообщениеОбОшибке.Регистратор2 = Выборка.ПредставлениеРегистратор2 + " (текущий документ)";
				Иначе
					СообщениеОбОшибке.Регистратор2 = "" + Выборка.ПредставлениеРегистратор2;
				КонецЕсли;
				
				Если Выборка.Регистратор1 <> ПоследнийРегистратор1 
					и Выборка.Регистратор2 <> ПоследнийРегистратор1 Тогда
					Если ПоследнийРегистратор1 = Регистратор Тогда
						СообщениеОбОшибке.ПослРегистратор1 = ПоследнийПредставлениеРегистратор1 + " (текущий документ)";
					Иначе
						СообщениеОбОшибке.ПослРегистратор1 = "" + ПоследнийПредставлениеРегистратор1;
					КонецЕсли;
				КонецЕсли;
				
				Если Выборка.Регистратор1 <> ПоследнийРегистратор2 
					и Выборка.Регистратор2 <> ПоследнийРегистратор2 Тогда
					Если ПоследнийРегистратор2 = Регистратор Тогда
						СообщениеОбОшибке.ПослРегистратор2 = ПоследнийПредставлениеРегистратор2 + " (текущий документ)";
					Иначе
						СообщениеОбОшибке.ПослРегистратор2 = "" + ПоследнийПредставлениеРегистратор2;
					КонецЕсли;
				КонецЕсли;
				
				СообщенияОбОшибках.Добавить(СообщениеОбОшибке);
				
			КонецЕсли;
		КонецЕсли;
		
		ПоследнийРегистратор1				= Выборка.Регистратор1;
		ПоследнийРегистратор2				= Выборка.Регистратор2;
		ПоследнийПредставлениеРегистратор1	= Выборка.ПредставлениеРегистратор1;;
		ПоследнийПредставлениеРегистратор2	= Выборка.ПредставлениеРегистратор2;
		ПоследняяДатаНачала					= Выборка.ДатаНачала;
		ПоследняяДатаОкончания				= Выборка.ДатаОкончания;
	КонецЦикла;
	
КонецПроцедуры

Процедура ПолучитьОшибкиПериодовРаботыСотрудникаБезДоговора(Регистратор, УчитыватьРегистратор, МассивФизлица, СообщенияОбОшибках, ОшибкиПериодов) Экспорт
	
	Запрос = Новый Запрос;
	
	ТаблицаПериодов = ПериодыИспользованияРесурсов("ПериодыРаботыРаботников", , , "Периоды.Физлицо В (&Физлица)", УчитыватьРегистратор);
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Регистратор1,
	|	Регистратор2,
	|	ПРЕДСТАВЛЕНИЕ(Регистратор1) КАК ПредставлениеРегистратор1,
	|	ПРЕДСТАВЛЕНИЕ(Регистратор2) КАК ПредставлениеРегистратор2,
	|	Физлицо,
	|	Физлицо.Наименование КАК ФизлицоНаименование,
	|	ДатаНачала,
	|	ДатаОкончания
	|ИЗ
	|	(" + ТаблицаПериодов + ") КАК Периоды
	|УПОРЯДОЧИТЬ ПО
	|	ФизлицоНаименование,
	|	ДатаНачала";
	
	Запрос.УстановитьПараметр("Регистратор",	Регистратор);
	Запрос.УстановитьПараметр("Физлица",		МассивФизлица);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	// обработаем периоды
	ТекущееФизлицо						= Неопределено;
	ПоследняяДатаНачала					= '0001-01-01';
	ПоследняяДатаОкончания				= '0001-01-01';
	ПоследнийРегистратор1				= Неопределено;
	ПоследнийРегистратор2				= Неопределено;
	ПоследнийПредставлениеРегистратор1	= "";
	ПоследнийПредставлениеРегистратор2	= "";
	
	Пока Выборка.Следующий() Цикл
		
		Если ТекущееФизлицо <> Выборка.Физлицо Тогда
			ТекущееФизлицо = Выборка.Физлицо;
			
		ИначеЕсли (ПоследняяДатаОкончания > Выборка.ДатаНачала) ИЛИ (ПоследняяДатаОкончания = '0001-01-01') Тогда
			Если ОшибкиПериодов <> НеОпределено Тогда
				ОшибкиПериодов[Выборка.Физлицо] = 0;
			КонецЕсли;
			// сообщения формируем для переданного регистратора или все, если регистратор не задан 
			Если СообщенияОбОшибках <> НеОпределено и
				(	Регистратор = НеОпределено ИЛИ
					ПоследнийРегистратор1 = Регистратор ИЛИ
					ПоследнийРегистратор2 = Регистратор ИЛИ
					Выборка.Регистратор1 = Регистратор ИЛИ
					Выборка.Регистратор2 = Регистратор) Тогда
				СообщениеОбОшибке = Новый Структура("Физлицо, 
													|ДатаНачала, 
													|ДатаОкончания, 
													|ДатаНачалаПред, 
													|ДатаОкончанияПред, 
													|Регистратор1, 
													|Регистратор2, 
													|ПослРегистратор1, 
													|ПослРегистратор2,
													|Регистратор1Ссылка, 
													|Регистратор2Ссылка, 
													|ПослРегистратор1Ссылка, 
													|ПослРегистратор2Ссылка");
				СообщениеОбОшибке.Физлицо			= Выборка.ФизлицоНаименование;
				СообщениеОбОшибке.ДатаНачала		= Выборка.ДатаНачала;
				СообщениеОбОшибке.ДатаОкончания		= Выборка.ДатаОкончания;
				СообщениеОбОшибке.ДатаНачалаПред	= ПоследняяДатаНачала;
				СообщениеОбОшибке.ДатаОкончанияПред	= ПоследняяДатаОкончания;
				
				СообщениеОбОшибке.Регистратор1Ссылка 		= Выборка.Регистратор1;
				СообщениеОбОшибке.Регистратор2Ссылка 		= Выборка.Регистратор2;
				СообщениеОбОшибке.ПослРегистратор1Ссылка 	= ПоследнийРегистратор1;
				СообщениеОбОшибке.ПослРегистратор2Ссылка 	= ПоследнийРегистратор2;
				
				Если Выборка.Регистратор1 = Регистратор Тогда
					СообщениеОбОшибке.Регистратор1 = Выборка.ПредставлениеРегистратор1 + " (текущий документ)";
				Иначе
					СообщениеОбОшибке.Регистратор1 = "" + Выборка.ПредставлениеРегистратор1;
				КонецЕсли;
				
				Если Выборка.Регистратор2 = Регистратор Тогда
					СообщениеОбОшибке.Регистратор2 = Выборка.ПредставлениеРегистратор2 + " (текущий документ)";
				Иначе
					СообщениеОбОшибке.Регистратор2 = "" + Выборка.ПредставлениеРегистратор2;
				КонецЕсли;
				
				Если Выборка.Регистратор1 <> ПоследнийРегистратор1 
					и Выборка.Регистратор2 <> ПоследнийРегистратор1 Тогда
					Если ПоследнийРегистратор1 = Регистратор Тогда
						СообщениеОбОшибке.ПослРегистратор1 = ПоследнийПредставлениеРегистратор1 + " (текущий документ)";
					Иначе
						СообщениеОбОшибке.ПослРегистратор1 = "" + ПоследнийПредставлениеРегистратор1;
					КонецЕсли;
				КонецЕсли;
				
				Если Выборка.Регистратор1 <> ПоследнийРегистратор2 
					и Выборка.Регистратор2 <> ПоследнийРегистратор2 Тогда
					Если ПоследнийРегистратор2 = Регистратор Тогда
						СообщениеОбОшибке.ПослРегистратор2 = ПоследнийПредставлениеРегистратор2 + " (текущий документ)";
					Иначе
						СообщениеОбОшибке.ПослРегистратор2 = "" + ПоследнийПредставлениеРегистратор2;
					КонецЕсли;
				КонецЕсли;
				
				СообщенияОбОшибках.Добавить(СообщениеОбОшибке);
				
			КонецЕсли;
		КонецЕсли;
		
		ПоследнийРегистратор1				= Выборка.Регистратор1;
		ПоследнийРегистратор2				= Выборка.Регистратор2;
		ПоследнийПредставлениеРегистратор1	= Выборка.ПредставлениеРегистратор1;;
		ПоследнийПредставлениеРегистратор2	= Выборка.ПредставлениеРегистратор2;
		ПоследняяДатаНачала					= Выборка.ДатаНачала;
		ПоследняяДатаОкончания				= Выборка.ДатаОкончания;
	КонецЦикла;
	
КонецПроцедуры

Процедура ПолучитьОшибкиПериодовСостоянияСотрудника(Регистратор, УчитыватьРегистратор, МассивСотрудники, СообщенияОбОшибках, ОшибкиПериодов) Экспорт
	
	Запрос = Новый Запрос;
	
	ТаблицаПериодов = ПериодыИспользованияРесурсов("ПериодыСостоянийРаботниковОрганизаций", , , "Периоды.Сотрудник В (&Сотрудники)", УчитыватьРегистратор);
	
	Запрос.Текст =
	//vvv
	//"ВЫБРАТЬ
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	//
	|	Регистратор1,
	|	Регистратор2,
	|	ПРЕДСТАВЛЕНИЕ(Регистратор1) КАК ПредставлениеРегистратор1,
	|	ПРЕДСТАВЛЕНИЕ(Регистратор2) КАК ПредставлениеРегистратор2,
	|	Сотрудник,
	|	Сотрудник.Наименование КАК СотрудникНаименование,
	|	ДатаНачала,
	|	ДатаОкончания
	|ИЗ
	|	(" + ТаблицаПериодов + ") КАК Периоды
	|УПОРЯДОЧИТЬ ПО
	|	СотрудникНаименование,
	|	ДатаНачала";
	
	Запрос.УстановитьПараметр("Регистратор",	Регистратор);
	Запрос.УстановитьПараметр("Сотрудники",		МассивСотрудники);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	// обработаем периоды
	ТекущийСотрудник						= Неопределено;
	ПоследняяДатаНачала					= '0001-01-01';
	ПоследняяДатаОкончания				= '0001-01-01';
	ПоследнийРегистратор1				= Неопределено;
	ПоследнийРегистратор2				= Неопределено;
	ПоследнийПредставлениеРегистратор1	= "";
	ПоследнийПредставлениеРегистратор2	= "";
	
	Пока Выборка.Следующий() Цикл
		
		Если ТекущийСотрудник <> Выборка.Сотрудник Тогда
			ТекущийСотрудник = Выборка.Сотрудник;
			
		ИначеЕсли (ПоследняяДатаОкончания > Выборка.ДатаНачала) ИЛИ (ПоследняяДатаОкончания = '0001-01-01') Тогда
			Если ОшибкиПериодов <> НеОпределено Тогда
				ОшибкиПериодов[Выборка.Сотрудник] = 0;
			КонецЕсли;
			// сообщения формируем для переданного регистратора или все, если регистратор не задан 
			Если СообщенияОбОшибках <> НеОпределено и
				(	Регистратор = НеОпределено ИЛИ
					ПоследнийРегистратор1 = Регистратор ИЛИ
					ПоследнийРегистратор2 = Регистратор ИЛИ
					Выборка.Регистратор1 = Регистратор ИЛИ
					Выборка.Регистратор2 = Регистратор) Тогда
				СообщениеОбОшибке = Новый Структура("Сотрудник, 
													|ДатаНачала, 
													|ДатаОкончания, 
													|ДатаНачалаПред, 
													|ДатаОкончанияПред, 
													|Регистратор1, 
													|Регистратор2, 
													|ПослРегистратор1, 
													|ПослРегистратор2,
													|Регистратор1Ссылка, 
													|Регистратор2Ссылка, 
													|ПослРегистратор1Ссылка, 
													|ПослРегистратор2Ссылка");
				СообщениеОбОшибке.Сотрудник			= Выборка.СотрудникНаименование;
				СообщениеОбОшибке.ДатаНачала		= Выборка.ДатаНачала;
				СообщениеОбОшибке.ДатаОкончания		= Выборка.ДатаОкончания;
				СообщениеОбОшибке.ДатаНачалаПред	= ПоследняяДатаНачала;
				СообщениеОбОшибке.ДатаОкончанияПред	= ПоследняяДатаОкончания;
				
				СообщениеОбОшибке.Регистратор1Ссылка 		= Выборка.Регистратор1;
				СообщениеОбОшибке.Регистратор2Ссылка 		= Выборка.Регистратор2;
				СообщениеОбОшибке.ПослРегистратор1Ссылка 	= ПоследнийРегистратор1;
				СообщениеОбОшибке.ПослРегистратор2Ссылка 	= ПоследнийРегистратор2;
				
				Если Выборка.Регистратор1 = Регистратор Тогда
					СообщениеОбОшибке.Регистратор1 = Выборка.ПредставлениеРегистратор1 + " (текущий документ)";
				Иначе
					СообщениеОбОшибке.Регистратор1 = "" + Выборка.ПредставлениеРегистратор1;
				КонецЕсли;
				
				Если Выборка.Регистратор2 = Регистратор Тогда
					СообщениеОбОшибке.Регистратор2 = Выборка.ПредставлениеРегистратор2 + " (текущий документ)";
				Иначе
					СообщениеОбОшибке.Регистратор2 = "" + Выборка.ПредставлениеРегистратор2;
				КонецЕсли;
				
				Если Выборка.Регистратор1 <> ПоследнийРегистратор1 
					и Выборка.Регистратор2 <> ПоследнийРегистратор1 Тогда
					Если ПоследнийРегистратор1 = Регистратор Тогда
						СообщениеОбОшибке.ПослРегистратор1 = ПоследнийПредставлениеРегистратор1 + " (текущий документ)";
					Иначе
						СообщениеОбОшибке.ПослРегистратор1 = "" + ПоследнийПредставлениеРегистратор1;
					КонецЕсли;
				КонецЕсли;
				
				Если Выборка.Регистратор1 <> ПоследнийРегистратор2 
					и Выборка.Регистратор2 <> ПоследнийРегистратор2 Тогда
					Если ПоследнийРегистратор2 = Регистратор Тогда
						СообщениеОбОшибке.ПослРегистратор2 = ПоследнийПредставлениеРегистратор2 + " (текущий документ)";
					Иначе
						СообщениеОбОшибке.ПослРегистратор2 = "" + ПоследнийПредставлениеРегистратор2;
					КонецЕсли;
				КонецЕсли;
				
				СообщенияОбОшибках.Добавить(СообщениеОбОшибке);
				
			КонецЕсли;
		КонецЕсли;
		
		ПоследнийРегистратор1				= Выборка.Регистратор1;
		ПоследнийРегистратор2				= Выборка.Регистратор2;
		ПоследнийПредставлениеРегистратор1	= Выборка.ПредставлениеРегистратор1;;
		ПоследнийПредставлениеРегистратор2	= Выборка.ПредставлениеРегистратор2;
		ПоследняяДатаНачала					= Выборка.ДатаНачала;
		ПоследняяДатаОкончания				= Выборка.ДатаОкончания;
	КонецЦикла;
	
КонецПроцедуры	

Процедура ПолучитьОшибкиПериодовСостоянияСотрудникаБезДоговора(Регистратор, УчитыватьРегистратор, МассивФизлица, СообщенияОбОшибках, ОшибкиПериодов) Экспорт
	
	Запрос = Новый Запрос;
	
	ТаблицаПериодов = ПериодыИспользованияРесурсов("ПериодыСостоянийРаботников", , , "Периоды.Физлицо В (&Физлица)", УчитыватьРегистратор);
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Регистратор1,
	|	Регистратор2,
	|	ПРЕДСТАВЛЕНИЕ(Регистратор1) КАК ПредставлениеРегистратор1,
	|	ПРЕДСТАВЛЕНИЕ(Регистратор2) КАК ПредставлениеРегистратор2,
	|	Физлицо,
	|	Физлицо.Наименование КАК ФизлицоНаименование,
	|	ДатаНачала,
	|	ДатаОкончания
	|ИЗ
	|	(" + ТаблицаПериодов + ") КАК Периоды
	|УПОРЯДОЧИТЬ ПО
	|	ФизлицоНаименование,
	|	ДатаНачала";
	
	Запрос.УстановитьПараметр("Регистратор",	Регистратор);
	Запрос.УстановитьПараметр("Физлица",		МассивФизлица);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	// обработаем периоды
	ТекущееФизлицо						= Неопределено;
	ПоследняяДатаНачала					= '0001-01-01';
	ПоследняяДатаОкончания				= '0001-01-01';
	ПоследнийРегистратор1				= Неопределено;
	ПоследнийРегистратор2				= Неопределено;
	ПоследнийПредставлениеРегистратор1	= "";
	ПоследнийПредставлениеРегистратор2	= "";
	
	Пока Выборка.Следующий() Цикл
		
		Если ТекущееФизлицо <> Выборка.Физлицо Тогда
			ТекущееФизлицо = Выборка.Физлицо;
			
		ИначеЕсли (ПоследняяДатаОкончания > Выборка.ДатаНачала) ИЛИ (ПоследняяДатаОкончания = '0001-01-01') Тогда
			Если ОшибкиПериодов <> НеОпределено Тогда
				ОшибкиПериодов[Выборка.Физлицо] = 0;
			КонецЕсли;
			// сообщения формируем для переданного регистратора или все, если регистратор не задан 
			Если СообщенияОбОшибках <> НеОпределено и
				(	Регистратор = НеОпределено ИЛИ
					ПоследнийРегистратор1 = Регистратор ИЛИ
					ПоследнийРегистратор2 = Регистратор ИЛИ
					Выборка.Регистратор1 = Регистратор ИЛИ
					Выборка.Регистратор2 = Регистратор) Тогда
				СообщениеОбОшибке = Новый Структура("Физлицо, 
													|ДатаНачала, 
													|ДатаОкончания, 
													|ДатаНачалаПред, 
													|ДатаОкончанияПред, 
													|Регистратор1, 
													|Регистратор2, 
													|ПослРегистратор1, 
													|ПослРегистратор2,
													|Регистратор1Ссылка, 
													|Регистратор2Ссылка, 
													|ПослРегистратор1Ссылка, 
													|ПослРегистратор2Ссылка");
				СообщениеОбОшибке.Физлицо			= Выборка.ФизлицоНаименование;
				СообщениеОбОшибке.ДатаНачала		= Выборка.ДатаНачала;
				СообщениеОбОшибке.ДатаОкончания		= Выборка.ДатаОкончания;
				СообщениеОбОшибке.ДатаНачалаПред	= ПоследняяДатаНачала;
				СообщениеОбОшибке.ДатаОкончанияПред	= ПоследняяДатаОкончания;
				
				СообщениеОбОшибке.Регистратор1Ссылка 		= Выборка.Регистратор1;
				СообщениеОбОшибке.Регистратор2Ссылка 		= Выборка.Регистратор2;
				СообщениеОбОшибке.ПослРегистратор1Ссылка 	= ПоследнийРегистратор1;
				СообщениеОбОшибке.ПослРегистратор2Ссылка 	= ПоследнийРегистратор2;
				
				Если Выборка.Регистратор1 = Регистратор Тогда
					СообщениеОбОшибке.Регистратор1 = Выборка.ПредставлениеРегистратор1 + " (текущий документ)";
				Иначе
					СообщениеОбОшибке.Регистратор1 = "" + Выборка.ПредставлениеРегистратор1;
				КонецЕсли;
				
				Если Выборка.Регистратор2 = Регистратор Тогда
					СообщениеОбОшибке.Регистратор2 = Выборка.ПредставлениеРегистратор2 + " (текущий документ)";
				Иначе
					СообщениеОбОшибке.Регистратор2 = "" + Выборка.ПредставлениеРегистратор2;
				КонецЕсли;
				
				Если Выборка.Регистратор1 <> ПоследнийРегистратор1 
					и Выборка.Регистратор2 <> ПоследнийРегистратор1 Тогда
					Если ПоследнийРегистратор1 = Регистратор Тогда
						СообщениеОбОшибке.ПослРегистратор1 = ПоследнийПредставлениеРегистратор1 + " (текущий документ)";
					Иначе
						СообщениеОбОшибке.ПослРегистратор1 = "" + ПоследнийПредставлениеРегистратор1;
					КонецЕсли;
				КонецЕсли;
				
				Если Выборка.Регистратор1 <> ПоследнийРегистратор2 
					и Выборка.Регистратор2 <> ПоследнийРегистратор2 Тогда
					Если ПоследнийРегистратор2 = Регистратор Тогда
						СообщениеОбОшибке.ПослРегистратор2 = ПоследнийПредставлениеРегистратор2 + " (текущий документ)";
					Иначе
						СообщениеОбОшибке.ПослРегистратор2 = "" + ПоследнийПредставлениеРегистратор2;
					КонецЕсли;
				КонецЕсли;
				
				СообщенияОбОшибках.Добавить(СообщениеОбОшибке);
				
			КонецЕсли;
		КонецЕсли;
		
		ПоследнийРегистратор1				= Выборка.Регистратор1;
		ПоследнийРегистратор2				= Выборка.Регистратор2;
		ПоследнийПредставлениеРегистратор1	= Выборка.ПредставлениеРегистратор1;;
		ПоследнийПредставлениеРегистратор2	= Выборка.ПредставлениеРегистратор2;
		ПоследняяДатаНачала					= Выборка.ДатаНачала;
		ПоследняяДатаОкончания				= Выборка.ДатаОкончания;
	КонецЦикла;
	
КонецПроцедуры

Процедура ПолучитьОшибкиПериодовЗанятостиПомещения(Регистратор, УчитыватьРегистратор, МассивПомешения, СообщенияОбОшибках, ОшибкиПериодов) Экспорт
	
	Запрос = Новый Запрос;
	
	ТаблицаПериодов = ПериодыИспользованияРесурсов("ПериодыЗанятостиПомещений", , , "Периоды.Помещение В (&Помещения)", УчитыватьРегистратор);
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Регистратор1,
	|	Регистратор2,
	|	ПРЕДСТАВЛЕНИЕ(Регистратор1) КАК ПредставлениеРегистратор1,
	|	ПРЕДСТАВЛЕНИЕ(Регистратор2) КАК ПредставлениеРегистратор2,
	|	Помещение,
	|	Помещение.Наименование КАК ПомещениеНаименование,
	|	ДатаНачала,
	|	ДатаОкончания
	|ИЗ
	|	(" + ТаблицаПериодов + ") КАК Периоды
	|УПОРЯДОЧИТЬ ПО
	|	ПомещениеНаименование,
	|	ДатаНачала";
	
	Запрос.УстановитьПараметр("Регистратор",	Регистратор);
	Запрос.УстановитьПараметр("Помещения",		МассивПомешения);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	// обработаем периоды
	ТекущееПомещение						= Неопределено;
	ПоследняяДатаНачала					= '0001-01-01';
	ПоследняяДатаОкончания				= '0001-01-01';
	ПоследнийРегистратор1				= Неопределено;
	ПоследнийРегистратор2				= Неопределено;
	ПоследнийПредставлениеРегистратор1	= "";
	ПоследнийПредставлениеРегистратор2	= "";
	
	Пока Выборка.Следующий() Цикл
		
		Если ТекущееПомещение <> Выборка.Помещение Тогда
			ТекущееПомещение = Выборка.Помещение;
			
		ИначеЕсли (ПоследняяДатаОкончания > Выборка.ДатаНачала) ИЛИ (ПоследняяДатаОкончания = '0001-01-01') Тогда
			Если ОшибкиПериодов <> НеОпределено Тогда
				ОшибкиПериодов[Выборка.Помещение] = 0;
			КонецЕсли;
			// сообщения формируем для переданного регистратора или все, если регистратор не задан 
			Если СообщенияОбОшибках <> НеОпределено и
				(	Регистратор = НеОпределено ИЛИ
					ПоследнийРегистратор1 = Регистратор ИЛИ
					ПоследнийРегистратор2 = Регистратор ИЛИ
					Выборка.Регистратор1 = Регистратор ИЛИ
					Выборка.Регистратор2 = Регистратор) Тогда
				СообщениеОбОшибке = Новый Структура("Помещение, 
													|ДатаНачала, 
													|ДатаОкончания, 
													|ДатаНачалаПред, 
													|ДатаОкончанияПред, 
													|Регистратор1, 
													|Регистратор2, 
													|ПослРегистратор1, 
													|ПослРегистратор2,
													|Регистратор1Ссылка, 
													|Регистратор2Ссылка, 
													|ПослРегистратор1Ссылка, 
													|ПослРегистратор2Ссылка");
				СообщениеОбОшибке.Помещение			= Выборка.ПомещениеНаименование;
				СообщениеОбОшибке.ДатаНачала		= Выборка.ДатаНачала;
				СообщениеОбОшибке.ДатаОкончания		= Выборка.ДатаОкончания;
				СообщениеОбОшибке.ДатаНачалаПред	= ПоследняяДатаНачала;
				СообщениеОбОшибке.ДатаОкончанияПред	= ПоследняяДатаОкончания;
				
				СообщениеОбОшибке.Регистратор1Ссылка 		= Выборка.Регистратор1;
				СообщениеОбОшибке.Регистратор2Ссылка 		= Выборка.Регистратор2;
				СообщениеОбОшибке.ПослРегистратор1Ссылка 	= ПоследнийРегистратор1;
				СообщениеОбОшибке.ПослРегистратор2Ссылка 	= ПоследнийРегистратор2;
				
				Если Выборка.Регистратор1 = Регистратор Тогда
					СообщениеОбОшибке.Регистратор1 = Выборка.ПредставлениеРегистратор1 + " (текущий документ)";
				Иначе
					СообщениеОбОшибке.Регистратор1 = "" + Выборка.ПредставлениеРегистратор1;
				КонецЕсли;
				
				Если Выборка.Регистратор2 = Регистратор Тогда
					СообщениеОбОшибке.Регистратор2 = Выборка.ПредставлениеРегистратор2 + " (текущий документ)";
				Иначе
					СообщениеОбОшибке.Регистратор2 = "" + Выборка.ПредставлениеРегистратор2;
				КонецЕсли;
				
				Если Выборка.Регистратор1 <> ПоследнийРегистратор1 
					и Выборка.Регистратор2 <> ПоследнийРегистратор1 Тогда
					Если ПоследнийРегистратор1 = Регистратор Тогда
						СообщениеОбОшибке.ПослРегистратор1 = ПоследнийПредставлениеРегистратор1 + " (текущий документ)";
					Иначе
						СообщениеОбОшибке.ПослРегистратор1 = "" + ПоследнийПредставлениеРегистратор1;
					КонецЕсли;
				КонецЕсли;
				
				Если Выборка.Регистратор1 <> ПоследнийРегистратор2 
					и Выборка.Регистратор2 <> ПоследнийРегистратор2 Тогда
					Если ПоследнийРегистратор2 = Регистратор Тогда
						СообщениеОбОшибке.ПослРегистратор2 = ПоследнийПредставлениеРегистратор2 + " (текущий документ)";
					Иначе
						СообщениеОбОшибке.ПослРегистратор2 = "" + ПоследнийПредставлениеРегистратор2;
					КонецЕсли;
				КонецЕсли;
				
				СообщенияОбОшибках.Добавить(СообщениеОбОшибке);
				
			КонецЕсли;
		КонецЕсли;
		
		ПоследнийРегистратор1				= Выборка.Регистратор1;
		ПоследнийРегистратор2				= Выборка.Регистратор2;
		ПоследнийПредставлениеРегистратор1	= Выборка.ПредставлениеРегистратор1;;
		ПоследнийПредставлениеРегистратор2	= Выборка.ПредставлениеРегистратор2;
		ПоследняяДатаНачала					= Выборка.ДатаНачала;
		ПоследняяДатаОкончания				= Выборка.ДатаОкончания;
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРИОДАМИ

// Функция определяет границу периода, вторую, по отношению к переданному параметру
//
// Параметры
//  ПериодСсылка  - тип периода, ПеречислениеСсылка
//  НачалоПериода - Булево, если истина то определяем начало периода, иначе конец
//  ДатаПериода   - Дата, относительно которой будет определяться вторая граница
//
// Возвращаемое значение:
//  Дата - вторая граница периода
//
Функция ОпределитьВторуюГраницуПериода(ПериодСсылка, НачалоПериода, ДатаПериода) Экспорт

	Если НачалоПериода Тогда
		ДатаПериода = КонецДня(ДатаПериода);
	Иначе
		ДатаПериода = НачалоДня(ДатаПериода);
	КонецЕсли; 
	
	Если ПериодСсылка = Перечисления.Периодичность.День Тогда

		Если НачалоПериода Тогда
			Возврат (ДатаПериода - 60*60*24 + 1);
		Иначе
			Возврат (ДатаПериода + 60*60*24 - 1);
		КонецЕсли; 

	ИначеЕсли ПериодСсылка = Перечисления.Периодичность.Неделя Тогда

		Если НачалоПериода Тогда
			Возврат (ДатаПериода - 60*60*24*7 + 1);
		Иначе
			Возврат (ДатаПериода + 60*60*24*7 - 1);
		КонецЕсли; 

	ИначеЕсли ПериодСсылка = Перечисления.Периодичность.Месяц Тогда

		Если НачалоПериода Тогда
			Возврат ДобавитьМесяц(ДатаПериода, -1) + 1;
		Иначе
			Возврат ДобавитьМесяц(ДатаПериода, 1) - 1;
		КонецЕсли; 

	ИначеЕсли ПериодСсылка = Перечисления.Периодичность.Квартал Тогда

		Если НачалоПериода Тогда
			Возврат ДобавитьМесяц(ДатаПериода, -3) + 1;
		Иначе
			Возврат ДобавитьМесяц(ДатаПериода, 3) - 1;
		КонецЕсли; 

	ИначеЕсли ПериодСсылка = Перечисления.Периодичность.Год Тогда

		Если НачалоПериода Тогда
			Возврат ДобавитьМесяц(ДатаПериода, -12) + 1;
		Иначе
			Возврат ДобавитьМесяц(ДатаПериода, 12) - 1;
		КонецЕсли; 

	Иначе

		Возврат '00010101000000';

	КонецЕсли; 

КонецФункции // ОпределитьВторуюГраницуПериода()

// Функция определяет начало или окончание периода по дате
//
// Параметры
//  ПериодСсылка - тип периода, ПеречислениеСсылка
//  НачалоПериода - Булево, если истина то определяем начало периода, иначе конец
//  ДатаПериода - Дата, период для которой будет определяться
//
// Возвращаемое значение:
//  Дата - дата начала или окончания периода
//
Функция ОпределитьБлижайшуюГраницуПериода(ПериодСсылка, НачалоПериода, ДатаПериода) Экспорт

	Если НачалоПериода Тогда
		ДатаПериода = КонецДня(ДатаПериода);
	Иначе
		ДатаПериода = НачалоДня(ДатаПериода);
	КонецЕсли; 
	
	Если ПериодСсылка = Перечисления.Периодичность.День Тогда

		Если НачалоПериода Тогда
			Возврат НачалоДня(ДатаПериода);
		Иначе
			Возврат КонецДня(ДатаПериода);
		КонецЕсли; 

	ИначеЕсли ПериодСсылка = Перечисления.Периодичность.Неделя Тогда

		Если НачалоПериода Тогда
			Возврат НачалоНедели(ДатаПериода);
		Иначе
			Возврат КонецНедели(ДатаПериода);
		КонецЕсли; 

	ИначеЕсли ПериодСсылка = Перечисления.Периодичность.Месяц Тогда

		Если НачалоПериода Тогда
			Возврат НачалоМесяца(ДатаПериода);
		Иначе
			Возврат КонецМесяца(ДатаПериода);
		КонецЕсли; 

	ИначеЕсли ПериодСсылка = Перечисления.Периодичность.Квартал Тогда

		Если НачалоПериода Тогда
			Возврат НачалоКвартала(ДатаПериода);
		Иначе
			Возврат КонецКвартала(ДатаПериода);
		КонецЕсли; 

	ИначеЕсли ПериодСсылка = Перечисления.Периодичность.Год Тогда

		Если НачалоПериода Тогда
			Возврат НачалоГода(ДатаПериода);
		Иначе
			Возврат КонецГода(ДатаПериода);
		КонецЕсли; 

	Иначе

		Возврат '00010101000000';

	КонецЕсли; 

КонецФункции // ОпределитьБлижайшуюГраницуПериода()

// Функция определяет дату начала периода определяемого количеством месяцев и датой окончания
//
// Параметры
//  
//  ДатаОкончания - Дата, дата окончания периода
//  КолМесяцев    - Число, количество месяцев периода
//
// Возвращаемое значение:
//   Дата
//
Функция НайтиНачальнуюДатуПериодаМесяцев(ДатаОкончания, КолМесяцев) Экспорт
	
	НомерМесяца = Месяц(ДатаОкончания);
	
	НомерНовогоМесяца = НомерМесяца - КолМесяцев + 1;
	Если НомерНовогоМесяца <= 0 Тогда
		ЧислоГода = Год(ДатаОкончания) - 1;
		НомерНовогоМесяца = 12 - НомерНовогоМесяца;
	Иначе
		ЧислоГода = Год(ДатаОкончания);
	КонецЕсли;
	
	Попытка
		ДатыНачала = НачалоДня(Дата(СтрЗаменить(Строка(ЧислоГода), Символы.НПП, "") + ?(НомерНовогоМесяца < 10, ("0" + Строка(НомерНовогоМесяца)), Строка(НомерНовогоМесяца)) + "01000000"));
	Исключение
		ДатыНачала = '00010101000000';
	КонецПопытки;
	
	Возврат ДатыНачала;
	
КонецФункции // НайтиНачальнуюДатуПериодаМесяцев()

// Функция формирует представление периода по дате начала и дате окончания.
//
// Параметры
//  ДатаНачала	   – Дата – дата начала периода.
//  ДатаОкончания  – Дата – дата окончания периода.
//  МесяцКратко  - когда Истина, месяц выводится первыми тремя символами
//  СДатами	   – Булево – признак того, что описание периода будет сформирован 
//					 без указания чисел месяца.
//  ГодКратко - когда Истина, год выводится 2-мя знаками
//
// Возвращаемое значение:
//   Строка   – строковое представление периода.
//
Функция ОписаниеПериода(ДатаНачала, ДатаОкончания, МесяцКратко = Истина, СДатами = Истина, ГодКратко = Истина) Экспорт
	
	ЧислоНачала		= День(ДатаНачала);
	ЧислоОкончания	= День(ДатаОкончания);
	
	ФорматГода = ?(ГодКратко, "ДФ = 'гг'", "ДФ = 'гггг'");
	
	Если МесяцКратко Тогда
		ОписаниеМесяцаГода = Лев(Формат(ДатаНачала,   "ДФ = 'MMMM'"),3) + " " + Формат(ДатаНачала,    ФорматГода);
		ОписаниеМесяца2    = Лев(Формат(ДатаОкончания,"ДФ = 'MMMM'"),3) + " " + Формат(ДатаОкончания, ФорматГода);
	Иначе
		Месяц	= Формат(ДатаНачала, "ДФ=MMMM");
		ПроцедурыУправленияПерсоналом.Просклонять(глЗначениеПеременной("глКомпонентаСклоненияФИО"), Месяц, 4, Месяц);
		ОписаниеМесяцаГода = Месяц + " " + Формат(ДатаНачала,    ФорматГода);
		Месяц	= Формат(ДатаОкончания, "ДФ=MMMM");
		ПроцедурыУправленияПерсоналом.Просклонять(глЗначениеПеременной("глКомпонентаСклоненияФИО"), Месяц, 4, Месяц);
		ОписаниеМесяца2    = Месяц + " " + Формат(ДатаОкончания, ФорматГода);
	КонецЕсли;
	
	Если Месяц(ДатаНачала) <> Месяц(ДатаОкончания) Тогда  
		
		Если (ДатаНачала = НачалоМесяца(ДатаНачала)) Или Не СДатами Тогда
			Месяц	= Формат(ДатаНачала, "ДФ=MMMM");
			ПроцедурыУправленияПерсоналом.Просклонять(глЗначениеПеременной("глКомпонентаСклоненияФИО"), Месяц, 1, Месяц);
			Перваяполовинадат = Месяц + " " + Формат(ДатаНачала,    ФорматГода);
		Иначе
			Перваяполовинадат = "" + ЧислоНачала + " " + ОписаниеМесяцаГода; 
		КонецЕсли;
		
		Если (ДатаОкончания = КонецМесяца(ДатаОкончания)) Или Не СДатами Тогда
			Месяц	= Формат(ДатаОкончания, "ДФ=MMMM");
			ПроцедурыУправленияПерсоналом.Просклонять(глЗначениеПеременной("глКомпонентаСклоненияФИО"), Месяц, 1, Месяц);
			ВтораяПоловинаДат = Месяц + " " + Формат(ДатаОкончания,    ФорматГода);
		Иначе
			ВтораяПоловинаДат = "" + ЧислоОкончания + " " + ОписаниеМесяца2;
		КонецЕсли;
		
		Возврат Перваяполовинадат + "-" + ВтораяПоловинаДат;
		
	Иначе
		
		Если ДатаНачала = НачалоМесяца(ДатаНачала) И ДатаОкончания + 86399 = КонецМесяца(ДатаОкончания) Или Не СДатами Тогда
			Месяц	= Формат(ДатаНачала, "ДФ=MMMM");
			ПроцедурыУправленияПерсоналом.Просклонять(глЗначениеПеременной("глКомпонентаСклоненияФИО"), Месяц, 1, Месяц);
			Возврат Месяц + " " + Формат(ДатаНачала,    ФорматГода);
		ИначеЕсли ЧислоНачала = ЧислоОкончания Тогда
			Возврат "" + ЧислоНачала + " " + ОписаниеМесяцаГода;
		Иначе
			Возврат "" + ЧислоНачала + "-" + ЧислоОкончания + " " + ОписаниеМесяцаГода;
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции	// ОписаниеПериода 

#Если Клиент Тогда

Процедура РедактироватьДополнительныеПраваПользователей() Экспорт

	РегистрыСведений.ЗначенияДополнительныхПравПользователя.ПолучитьФорму("ФормаРедактирования").Открыть();

КонецПроцедуры

#КонецЕсли

// Функция определяет наличие клиентских подключений к базе других пользователей
Функция ЕстьДругиеПользователиВБазе() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда			
			Возврат Истина;						
		КонецЕсли;		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ГОЛОВНЫЕ ОРГАНИЗАЦИИ 

// Возвращает головную организацию для заданной организации
// Если для организации реквизит ГоловнаяОрганизация не заполнен 
// это значит, что сама организация является голвной
//
// Параметры
//  Организация – СправочникСсылка.Организации
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   СправочникСсылка.Организации
//
Функция ГоловнаяОрганизация(Организация) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Организация",Организация);
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.ГоловнаяОрганизация
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";
	Выборка = Запрос.Выполнить().Выбрать();
	//vvv
	//Выборка.Следующий();
	Если Не Выборка.Следующий() Тогда
		Возврат Справочники.Организации.ПустаяСсылка()
	КонецЕсли;
	//
	Если Организация.Пустая() или Выборка.ГоловнаяОрганизация.Пустая() Тогда
		Возврат Организация;
	Иначе
		Возврат Выборка.ГоловнаяОрганизация;
	КонецЕсли;
КонецФункции // ГоловнаяОрганизация()

// Формирует список обособленных структурных подразделений организации
Функция ПолучитьСписокОбособленныхПодразделенийОрганизации(Организация) Экспорт

	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.Ссылка,
	|	Организации.Наименование
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.ГоловнаяОрганизация = &Организация");

	Запрос.УстановитьПараметр("Организация", Организация);

	СписокОрганизаций = Новый СписокЗначений;
	
	Выборка = Запрос.Выполнить().Выбрать(); 

	Пока Выборка.Следующий() Цикл
		СписокОрганизаций.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;

	Возврат СписокОрганизаций;
КонецФункции // ПолучитьСписокОбособленныхПодразделенийОрганизации()

// Функция разбирает строку вида
// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
// ТипОбъектаМетаданных должен быть Справочник или Документ.
//
// Параметры:
//  ПутьКДанным - строка.
//
// Возвращаемое значение:
//  Структура - путь к объекту метаданных
//
Функция РазобратьПутьКОбъектуМетаданных(ПутьКДанным) Экспорт
	
	Структура = Новый Структура;
	
	СоответствиеИмен = Новый Массив();
	СоответствиеИмен.Добавить("ТипОбъекта");
	СоответствиеИмен.Добавить("ВидОбъекта");
	СоответствиеИмен.Добавить("ПутьКДанным");
	СоответствиеИмен.Добавить("ИмяТаблЧасти");
	СоответствиеИмен.Добавить("ИмяРеквизита");
	
	Для индекс = 1 по 3 Цикл
		
		Точка = Найти(ПутьКДанным, ".");
		ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
		Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
		ПутьКДанным = Сред(ПутьКДанным, Точка+1);
		
	КонецЦикла;
	
	ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");
	
	Если Структура.ПутьКДанным = "ТабличнаяЧасть" Тогда
		
		Для индекс = 4 по 5  Цикл 
			
			Точка = Найти(ПутьКДанным, ".");
			Если Точка = 0 Тогда
				ТекущееЗначение = ПутьКДанным;
			Иначе
				ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
			КонецЕсли;
			
			Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
			ПутьКДанным = Сред(ПутьКДанным,  Точка+1);
			
		КонецЦикла;
		
	Иначе
		
		Структура.Вставить(СоответствиеИмен[3], "");
		Структура.Вставить(СоответствиеИмен[4], ПутьКДанным);
		
	КонецЕсли;
	
	Если Структура.ТипОбъекта = "Документ" Тогда
		Структура.Вставить("Метаданные", Метаданные.Документы[Структура.ВидОбъекта]);
	Иначе
		Структура.Вставить("Метаданные", Метаданные.Справочники[Структура.ВидОбъекта]);
	КонецЕсли;
	
	Возврат Структура;
	
КонецФункции // РазобратьПутьКОбъектуМетаданных()

// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
//  либо по переданным строкам.
//  Если передан Объект, то извлеченная из него строка считается совокупностью 
//  Фамилия + Имя + Отчество, разделенными пробелами.
//
// Параметры
//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
//  Фамилия		- фамилия физ. лица.
//  Имя			- имя физ. лица.
//  Отчество	- отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
//  отдельным Фамилии,Имени и Отчеству
//
Функция ФамилияИнициалыФизЛица(Объект = "", Фамилия = " ", Имя = " ", Отчество = " ") Экспорт

	ТипОбъекта = ТипЗнч(Объект);
	Если ТипОбъекта = Тип("Строка") Тогда
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
		
	ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") или ТипОбъекта = Тип("СправочникОбъект.ФизическиеЛица") ИЛИ
			  ТипОбъекта = Тип("СправочникСсылка.СотрудникиОрганизаций") или ТипОбъекта = Тип("СправочникОбъект.СотрудникиОрганизаций") Тогда
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
		
	Иначе
		
		// используем возможно переданные отдельные строки
		Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"")
	КонецЕсли;
			
	КоличествоПодстрок = ФИО.Количество();
	Фамилия = ?(КоличествоПодстрок > 0,ФИО[0],"");
	Имя		= ?(КоличествоПодстрок > 1,ФИО[1],"");
	Отчество= ?(КоличествоПодстрок > 2,ФИО[2],"");
	
	Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"");

КонецФункции

// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
//  либо по переданным строкам.
//  Если передан Объект, то извлеченная из него строка считается совокупностью 
//  Фамилия + Имя + Отчество, разделенными пробелами.
//
// Параметры
//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
//  Фамилия		- фамилия физ. лица.
//  Имя			- имя физ. лица.
//  Отчество	- отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
//  отдельным Фамилии,Имени и Отчеству
//
Функция ИнициалыФизЛицаФамилия(Объект = "", Фамилия = " ", Имя = " ", Отчество = " ") Экспорт

	ТипОбъекта = ТипЗнч(Объект);
	
	Если ТипОбъекта = Тип("Строка") и Фамилия = "" Тогда
		
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
		
	ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") или ТипОбъекта = Тип("СправочникОбъект.ФизическиеЛица") ИЛИ
			  ТипОбъекта = Тип("СправочникСсылка.СотрудникиОрганизаций") или ТипОбъекта = Тип("СправочникОбъект.СотрудникиОрганизаций") Тогда
	
		Если ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") или 
			ТипОбъекта = Тип("СправочникСсылка.СотрудникиОрганизаций") Тогда
			Наименование = ПолучитьЗначениеРеквизита(Объект, "Наименование");
		Иначе
			Наименование = Объект.Наименование;
		КонецЕсли;
	
		// Избавление от возможных выражений в скобках, например (осн.), (вн. совм.).
		НачальнаяПозиция	= Найти(Наименование,"(");
		КонечнаяПозиция		= Найти(Наименование,")");
		ДлинаСтроки			= СтрДлина(Наименование);
		Если НачальнаяПозиция > 0 Тогда
			СтрокаДляОбработки = Лев(Наименование, НачальнаяПозиция - 1) + ?(КонечнаяПозиция > 0,Прав(Наименование, ДлинаСтроки - КонечнаяПозиция),"")
		Иначе
			СтрокаДляОбработки = Наименование;
		КонецЕсли; 
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(СтрокаДляОбработки)," ");
		
	Иначе
		
		// используем возможно переданные отдельные строки
		Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				"" + ?(НЕ ПустаяСтрока(Имя),Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), "") + " " + Фамилия ,
				"")
	КонецЕсли;
			
	КоличествоПодстрок = ФИО.Количество();
	Фамилия = ?(КоличествоПодстрок > 0,ФИО[0],"");
	Имя		= ?(КоличествоПодстрок > 1,ФИО[1],"");
	Отчество= ?(КоличествоПодстрок > 2,ФИО[2],"");
	
	Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				"" + ?(НЕ ПустаяСтрока(Имя),Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+". ", ""), "") + " " + Фамилия,
				"");

КонецФункции


// Заменяет одни термины, которые используются в коде, другими - уместными в интерфейсе.
// Позволяет иметь один тот же код при разных названиях объектов.
//
// Параметры
//  СтрокаИзИнтерфейса - строка - заголовок колонки, надпись и т.п.
//
// Возвращаемое значение:
//  Строка - новый заголовок колонки, надпись и т.п. 
//
Функция ПреобразоватьСтрокуИнтерфейса(СтрокаИзИнтерфейса) Экспорт 

	КоллекцияЗначенийЗаголовков = глЗначениеПеременной("глКоллекцияЗначенийЗаголовков");
	
	НоваяСтрока = КоллекцияЗначенийЗаголовков[СтрокаИзИнтерфейса];
	
	Возврат ?(НоваяСтрока = Неопределено, СтрокаИзИнтерфейса, НоваяСтрока)

КонецФункции // ПреобразоватьСтрокуИнтерфейса()

Функция ЭтоДоступнаяОрганизация(Организация) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Организация",Организация);
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.ПометкаУдаления
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";
	
	Возврат Не Запрос.Выполнить().Пустой() // если удалось прочитать закрытое поле - организация доступна
	
КонецФункции // ЭтоДоступнаяОрганизация()

// Функция формирует фамилию и инициалы работника в заданном падеже 
// по переданным данным о работнике.
//  либо по переданным строкам.
//
// Параметры
//  Работник	- строка (Фамилия + Имя + Отчество, разделенными пробелами) 
//                или ссылка на элемент справочника ФизическиеЛица или Сотрудники.
//  Падеж (необязательный), тип число
//   Падеж, в который необходимо поставить ФИО.
//   1 - Именительный
//   2 - Родительный
//   3 - Дательный
//   4 - Винительный
//   5 - Творительный
//   6 - Предложный
//
//  Пол (необязательный), тип ПеречислениеСсылка.ПолФизическихЛиц
//   Данный параметр предназначен для разрешения возможных неоднозначностей
//   В остальных случаях рекомендуется опускать этот параметр.
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой.
//
Функция ПредставлениеРаботника(Работник, Знач Падеж = 1, Знач Пол = Неопределено) Экспорт

	ТипДанных = ТипЗнч(Работник);
	Если ТипДанных = Тип("Строка") Тогда
		РаботникФИО = Работник;
		РаботникПол = Пол;
	Иначе
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Работник", Работник);
		Если ТипДанных = Тип("СправочникСсылка.СотрудникиОрганизаций") Тогда
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	СотрудникиОрганизаций.Наименование,
			|	СотрудникиОрганизаций.Физлицо.Пол КАК Пол
			|ИЗ
			|	Справочник.СотрудникиОрганизаций КАК СотрудникиОрганизаций
			|ГДЕ
			|	СотрудникиОрганизаций.Ссылка = &Работник";
		Иначе
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	ФизическиеЛица.Наименование,
			|	ФизическиеЛица.Пол
			|ИЗ
			|	Справочник.ФизическиеЛица КАК ФизическиеЛица
			|ГДЕ
			|	ФизическиеЛица.Ссылка = &Работник";
		КонецЕсли;
		
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			РаботникФИО = Выборка.Наименование;
			РаботникПол = Выборка.Пол;
		Иначе
			Возврат ""
		КонецЕсли;
	КонецЕсли;
	
	ФИО = ОбщегоНазначения.ФамилияИнициалыФизЛица(РаботникФИО);
	
	ПозицияПервогоПробела = Найти(ФИО + " "," ");
	Фамилия  = Лев(ФИО,ПозицияПервогоПробела-1);
	Инициалы = Сред(ФИО,ПозицияПервогоПробела+1);
	
	РезультатСклонения = "";
	Если УниверсальныеМеханизмы.Просклонять(глЗначениеПеременной("глКомпонентаСклоненияФИО"), Фамилия, Падеж, РаботникПол, РезультатСклонения) Тогда
		ФИО = РезультатСклонения + " " + Инициалы;	
	КонецЕсли;
	
	Возврат ФИО
	
КонецФункции

 // Функция добавляет интервал к дате
//
// Параметры:
//	Периодичность (Перечисления.Периодичность)	- пнриодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//	Смещение (число)							- определяет направление и количество периодов, в котором сдвигается дата
//
// Возвращаемое значение:
//	Дата, отстоящая от исходной на заданное количество периодов 
//
Функция ДобавитьИнтервал(ДатаПериода,Периодичность,Смещение) Экспорт
	
	Если Периодичность = Перечисления.Периодичность.День Тогда
		НоваяДатаПериода = ДатаПериода + Смещение*24*3600;
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		НоваяДатаПериода = ДатаПериода + Смещение*7*24*3600;
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*3);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Год Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*12);
		
	Иначе
		НоваяДатаПериода=НачалоДня(ДатаПериода) + Смещение*24*3600;
		
	КонецЕсли;
	
	Возврат НоваяДатаПериода;
	
КонецФункции // ДобавитьИнтервал()



 ////////////////////////////////////////////////////////////////////////////////
// СИСТЕМНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ 

Процедура ЗапуститьПрограмму(ПутьКПрограмме, РабочийКаталог = Неопределено) Экспорт
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		
		ЗапуститьПриложение(ПутьКПрограмме, РабочийКаталог);
	
	#КонецЕсли
	
КонецПроцедуры // ЗапуститьПрограмму()



////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБНОВЛЕНИЯ КОНФИГУРАЦИИ

Процедура ПредупреждениеОбОшибке(ТекстСообщения) Экспорт
	 
	#Если Клиент Тогда
		
		РаботаСДиалогами.ВывестиПредупреждение(ТекстСообщения);
	
	#Иначе
		
		ВызватьИсключение(ТекстСообщения);
		
	#КонецЕсли
	 
КонецПроцедуры // ПредупреждениеОбОшибке()




#Если Клиент Тогда

// Процедура - обработчик события ПриИзменении поля ввода Организация
//
// Параметры:
//		ДокументОбъект - объект документ в форме которого произошло событие
//
Процедура ПриИзмененииЗначенияОрганизации(ДокументОбъект) Экспорт

	МетаданныеДокумента = ДокументОбъект.Метаданные();
	Если МетаданныеДокумента.Реквизиты.Найти("Организация") <> Неопределено Тогда

		Если МетаданныеДокумента.Реквизиты.Найти("ПодразделениеОрганизации") <> Неопределено
		   И ЗначениеЗаполнено(ДокументОбъект.Организация)
		   И ЗначениеЗаполнено(ДокументОбъект.ПодразделениеОрганизации)
		   И Не ДокументОбъект.ПодразделениеОрганизации.Владелец = ДокументОбъект.Организация Тогда

			ДокументОбъект.ПодразделениеОрганизации = Справочники.ПодразделенияОрганизаций.ПустаяСсылка();
			Предупреждение("Выбранное подразделение не соответствует организации!");

		КонецЕсли;
		//vvv
		Если МетаданныеДокумента.Реквизиты.Найти("ТабельУчетаОрганизации") <> Неопределено
		   И ЗначениеЗаполнено(ДокументОбъект.Организация)
		   И ЗначениеЗаполнено(ДокументОбъект.ТабельУчетаОрганизации)
		   И Не ДокументОбъект.ТабельУчетаОрганизации.Владелец = ДокументОбъект.Организация Тогда

			ДокументОбъект.ТабельУчетаОрганизации = Справочники.ТабеляУчетаОрганизаций.ПустаяСсылка();
			Предупреждение("Выбранный табель учета не соответствует организации!");

		КонецЕсли;
        //
	КонецЕсли;

КонецПроцедуры // ПриИзмененииЗначенияОрганизации()

#КонецЕсли

// Функция предназначена для формирования массива префиксов.
//
// Возвращаемое значение.
//  Массив префиксов
//
Функция ПолучитьМассивПрефиксовРИБ()
	
	МассивПрефиксов = Новый Массив();
	
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ Различные
	               |	ПрефиксыИнформационныхБаз.Префикс КАК Префикс
	               |ИЗ
	               |	РегистрСведений.ПрефиксыИнформационныхБаз КАК ПрефиксыИнформационныхБаз";
	
	ВыборкаУзлов = Запрос.Выполнить().Выбрать();
	Пока ВыборкаУзлов.Следующий() Цикл
		
		Если Не ПустаяСтрока(ВыборкаУзлов.Префикс) Тогда
			
			МассивПрефиксов.Добавить(ВыборкаУзлов.Префикс);
			
		КонецЕсли;
		
	КонецЦикла;	
	
	Возврат МассивПрефиксов;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// КОММЕНТАРИИ РАСЧЕТОВ

Функция КомментарийРасчета(	ТекстСообщения, 
							РодительскаяСтрока = НеОпределено,
							ПредставлениеРасшифровкиКомментария = НеОпределено, 
							РасшифровкаКомментария = НеОпределено, 
							ВидСообщения = НеОпределено,
							РаскрытьКомментарий = Истина) Экспорт
	
	#Если Клиент Тогда
		Обработка = глЗначениеПеременной("глОбработкаСообщений");
		Если ВидСообщения = НеОпределено Тогда
			ВидСообщения = Перечисления.ВидыСообщений.Информация;
		КонецЕсли;
		Если РасшифровкаКомментария <> НеОпределено Тогда
			Расшифровки = Новый Массив;
			// расшифровка сообщений представляет собой массив структур "Представление+Расшифровка"
			Расшифровки.Добавить(Новый Структура("Представление,Расшифровка", ПредставлениеРасшифровкиКомментария, РасшифровкаКомментария));
		Иначе
			Расшифровки = НеОпределено;
		КонецЕсли;
		Возврат Обработка.ДобавитьСообщение(
								ТекстСообщения, 
								ВидСообщения, 
								Расшифровки, 
								РодительскаяСтрока, 
								РаскрытьКомментарий);
	#Иначе
		Сообщить(ТекстСообщения);
	#КонецЕсли
	
КонецФункции

Процедура ОшибкаРасчета(ТекстОшибки) Экспорт
	
	#Если Клиент Тогда
		Обработка = глЗначениеПеременной("глОбработкаСообщений");
		Обработка.ДобавитьСообщение(ТекстОшибки, Перечисления.ВидыСообщений.Ошибка);
	#Иначе
		Сообщить(ТекстОшибки, СтатусСообщения.Важное);
	#КонецЕсли
КонецПроцедуры

// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ
//
// Возвращает выборку со значениями реквизитов переданной ссылки
//
Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	" + ИменаРеквизитов + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	Результат = Новый Структура(ИменаРеквизитов);
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Получить значение одного реквизита по ссылке.
// Например, для элемента справочника нужно получить наименование,
// в этом случае в качестве ИмяРеквизита нужно передать "Наименование".
//
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ПолучитьЗначенияРеквизитов(Ссылка, ИмяРеквизита);
	
	Возврат Результат[ИмяРеквизита];
	
КонецФункции


//Для обмена

Функция ПолучитьВТ(МенеджерВТ, ИмяВТ) Экспорт
 
 // Создаем новый запрос и назначаем переданный
 // менеджер временных таблиц. В тексте запроса
 // указываем получение всех данных из врем. таб.
 Запрос = Новый Запрос;
 Запрос.МенеджерВременныхТаблиц = МенеджерВТ;
 Запрос.Текст = "ВЫБРАТЬ
                | *
                |ИЗ
                | "+ИмяВТ+" КАК ВТ";
 // Результат запроса возвращаем в качестве таблицы
 // значений для удобного просмотра. В случае
 // возникновения ошибки возвращаем ее описание
 //Попытка
  Возврат Запрос.Выполнить().Выгрузить();
 //Исключение
 // Возврат "Ошибка получения временной таблицы: "
 //    + ОписаниеОшибки(); 
 //КонецПопытки;
 
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с данными в базе


// Подставляет параметры в строку. Максимально возможное число параметров - 9.
// Параметры в строке задаются как %<номер параметра>. Нумерация параметров начинается с единицы.
//
// Параметры:
//  СтрокаПодстановки  – Строка – шаблон строки с параметрами (вхождениями вида "%ИмяПараметра");
//  Параметр<n>        - Строка - подставляемый параметр.
//
// Возвращаемое значение:
//  Строка   – текстовая строка с подставленными параметрами.
//
// Пример:
//  ПодставитьПараметрыВСтроку(НСтр("ru='%1 пошел в %2'"), "Вася", "Зоопарк") = "Вася пошел в Зоопарк".
//
Функция ПодставитьПараметрыВСтроку(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено) Экспорт
	
	ИспользоватьАльтернативныйАлгоритм = 
		Найти(Параметр1, "%")
		Или Найти(Параметр2, "%")
		Или Найти(Параметр3, "%")
		Или Найти(Параметр4, "%")
		Или Найти(Параметр5, "%")
		Или Найти(Параметр6, "%")
		Или Найти(Параметр7, "%")
		Или Найти(Параметр8, "%")
		Или Найти(Параметр9, "%");
		
	Если ИспользоватьАльтернативныйАлгоритм Тогда
		СтрокаПодстановки = ПодставитьПараметрыВСтрокуАльтернативныйАлгоритм(СтрокаПодстановки, Параметр1,
			Параметр2, Параметр3, Параметр4, Параметр5, Параметр6, Параметр7, Параметр8, Параметр9);
	Иначе
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%1", Параметр1);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%2", Параметр2);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%3", Параметр3);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%4", Параметр4);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%5", Параметр5);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%6", Параметр6);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%7", Параметр7);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%8", Параметр8);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%9", Параметр9);
	КонецЕсли;
	
	Возврат СтрокаПодстановки;
КонецФункции

// Вставляет параметры в строку, учитывая, что в параметрах могут использоваться подстановочные слова %1, %2 и т.д.
Функция ПодставитьПараметрыВСтрокуАльтернативныйАлгоритм(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено)
	
	Результат = "";
	Позиция = Найти(СтрокаПодстановки, "%");
	Пока Позиция > 0 Цикл 
		Результат = Результат + Лев(СтрокаПодстановки, Позиция - 1);
		СимволПослеПроцента = Сред(СтрокаПодстановки, Позиция + 1, 1);
		ПодставляемыйПараметр = "";
		Если СимволПослеПроцента = "1" Тогда
			ПодставляемыйПараметр =  Параметр1;
		ИначеЕсли СимволПослеПроцента = "2" Тогда
			ПодставляемыйПараметр =  Параметр2;
		ИначеЕсли СимволПослеПроцента = "3" Тогда
			ПодставляемыйПараметр =  Параметр3;
		ИначеЕсли СимволПослеПроцента = "4" Тогда
			ПодставляемыйПараметр =  Параметр4;
		ИначеЕсли СимволПослеПроцента = "5" Тогда
			ПодставляемыйПараметр =  Параметр5;
		ИначеЕсли СимволПослеПроцента = "6" Тогда
			ПодставляемыйПараметр =  Параметр6;
		ИначеЕсли СимволПослеПроцента = "7" Тогда
			ПодставляемыйПараметр =  Параметр7
		ИначеЕсли СимволПослеПроцента = "8" Тогда
			ПодставляемыйПараметр =  Параметр8;
		ИначеЕсли СимволПослеПроцента = "9" Тогда
			ПодставляемыйПараметр =  Параметр9;
		КонецЕсли;
		Если ПодставляемыйПараметр = "" Тогда
			Результат = Результат + "%";
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 1);
		Иначе
			Результат = Результат + ПодставляемыйПараметр;
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 2);
		КонецЕсли;
		Позиция = Найти(СтрокаПодстановки, "%");
	КонецЦикла;
	Результат = Результат + СтрокаПодстановки;
	
	Возврат Результат;
КонецФункции

//vvv
Функция ПолучитьДатуДеноминации() Экспорт
	
	Возврат Дата(2016,7,1);
	
КонецФункции

//vvv
Функция ДеноминироватьЗначение(Значение, ДатаЗначения, ДатаПолученияЗначения) Экспорт
	
	Если (ДатаЗначения < ПолучитьДатуДеноминации()) и (ДатаПолученияЗначения >= ПолучитьДатуДеноминации()) Тогда   
		Значение = Окр(Значение / 10000, 2);
	КонецЕсли;                      
	
	Возврат Значение;
	
КонецФункции
//vvv
Функция ПолучитьПоследнееДеноминированное(ИмяРегистра,ИмяИзмерения,ИмяРесурса,ЗначениеИзмерения,ДатаЗначения,ДатаПолученияЗначения) Экспорт
	
	Значение="";
	
	//т.к. не во всех РС есть индексирование по измерению, отбор при выборке установить нельзя.
	Выборка=РегистрыСведений[ИмяРегистра].Выбрать(,ДатаЗначения,,"Убыв");		
	
	Пока Выборка.Следующий()>0 Цикл
		
		Если Выборка[ИмяИзмерения]<>ЗначениеИзмерения Тогда Продолжить; КонецЕсли;
		
		Значение=Выборка[ИмяРесурса];
		Значение=ДеноминироватьЗначение(Значение,Выборка.Период,ДатаПолученияЗначения);	
		
		Прервать;
		
	КонецЦикла;
	
	Возврат Значение;
	
КонецФункции
//vvv
Функция ПолучитьСписокОбрабатываемыхПоказателей() Экспорт
	
	СписокОбрабатываемыхПоказателей=Новый СписокЗначений;
	
	СписокОбрабатываемыхПоказателей.Добавить(Справочники.ПоказателиСхемМотивации.ТарифнаяСтавкаМесячная);
	СписокОбрабатываемыхПоказателей.Добавить(Справочники.ПоказателиСхемМотивации.ТарифнаяСтавкаДневная);
	СписокОбрабатываемыхПоказателей.Добавить(Справочники.ПоказателиСхемМотивации.ТарифнаяСтавкаЧасовая);
	СписокОбрабатываемыхПоказателей.Добавить("Тарифная ставка");
	СписокОбрабатываемыхПоказателей.Добавить("Сумма");
	СписокОбрабатываемыхПоказателей.Добавить("Оклад замещающего");
	СписокОбрабатываемыхПоказателей.Добавить("Оклад замещаемого");
	СписокОбрабатываемыхПоказателей.Добавить("Cтавка фактическая");
	СписокОбрабатываемыхПоказателей.Добавить("Ставка расчетная");
	СписокОбрабатываемыхПоказателей.Добавить("Месячная тарифная ставка замещаемог");
	СписокОбрабатываемыхПоказателей.Добавить("Часовая тарифная ставка замещаемого");
	СписокОбрабатываемыхПоказателей.Добавить("Фиксированная сумма");
	
	Возврат СписокОбрабатываемыхПоказателей; 
КонецФункции

// СтандартныеПодсистемы

////////////////////////////////////////////////////////////////////////////////
// Подсистема "Базовая функциональность".
// Серверные процедуры и функции общего назначения:
// - для работы с данными в базе;
// - для работы с прикладными типами и коллекциями значений;
// - математические процедуры и функции;
// - для работы с внешним соединением;
// - для работы с формами;
// - для работы с типами, объектами метаданных и их строковыми представлениями;
// - функции определения типов объектов метаданных;
// - сохранение, чтение и удаление настроек из хранилищ;
// - для работы с табличными документами;
// - для работы с журналом регистрации;
// - для работы в режиме разделения данных;
// - версионирование программных интерфейсов;
// - вспомогательные процедуры и функции.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с данными в базе

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка    - Ссылка на объект - элемент справочника, документ, ...
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
// 
Функция ЗначенияРеквизитовОбъекта(Ссылка, Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		СтруктураРеквизитов = Новый Структура(Реквизиты);
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Структура")
	      ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		
		СтруктураРеквизитов = Реквизиты;
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив")
	      ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		
		СтруктураРеквизитов = Новый Структура;
		Для каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"),
			Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Ключ));
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[ИмяРеквизита];
	
КонецФункции 

// Возвращает структуру, содержащую значения реквизитов, прочитанные из информационной базы
// для нескольких объектов.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИменаРеквизитов - Строка, имена реквизитов перечисленные через запятую,
//				в формате требований к свойствам структуры.
//				Например, "Код, Наименование, Родитель".
// 
// Возвращаемое значение:
//  Соответствие, где ключ - ссылка на объект, а Значение - структура, которая 
//				содержит список свойств, как список имен в строке
//				ИменаРеквизитов, со значениям реквизитов, прочитанными
//				из информационной базы.
// 
Функция ЗначенияРеквизитовОбъектов(МассивСсылок, ИменаРеквизитов) Экспорт
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если МассивСсылок.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Ссылка КАК Ссылка, " + ИменаРеквизитов + "
		|ИЗ
		|	" + МассивСсылок[0].Метаданные().ПолноеИмя() + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка В (&МассивСсылок)";
	Запрос.УстановитьПараметр("МассивСсылок", МассивСсылок);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(ИменаРеквизитов);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Соответствие, где ключ - ссылка на объект, Значение - значение прочитанного реквизита
// 
Функция ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита) Экспорт
	
	ЗначенияРеквизитов = ЗначенияРеквизитовОбъектов(МассивСсылок, ИмяРеквизита);
	Для Каждого Элемент Из ЗначенияРеквизитов Цикл
		ЗначенияРеквизитов[Элемент.Ключ] = Элемент.Значение[ИмяРеквизита];
	КонецЦикла;
		
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Проверяет проведенность документов
//
// Параметры:
//  Документы - Массив - документы, проведенность которых необходимо проверить
//
// Возвращаемое значение:
//  Массив - непроведенные документы из массива Документы
//
Функция ПроверитьПроведенностьДокументов(знач Документы) Экспорт
	
	Результат = Новый Массив;
	
	ШаблонЗапроса = 	
		"ВЫБРАТЬ
		|	Документ.Ссылка КАК Ссылка
		|ИЗ
		|	&ИмяДокумента КАК Документ
		|ГДЕ
		|	Документ.Ссылка В(&МассивДокументов)
		|	И (НЕ Документ.Проведен)";
	
	ТекстОбъединитьВсе =
		"
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";
		
	ИменаДокументов = Новый Массив;
	Для Каждого Документ Из Документы Цикл
		ИмяДокумента = Документ.Метаданные().ПолноеИмя();
		Если ИменаДокументов.Найти(ИмяДокумента) = Неопределено
		   и Метаданные.Документы.Содержит(Метаданные.НайтиПоПолномуИмени(ИмяДокумента)) Тогда	
			ИменаДокументов.Добавить(ИмяДокумента);
		КонецЕсли;
	КонецЦикла;
	
	ТекстЗапроса = "";
	Для Каждого ИмяДокумента Из ИменаДокументов Цикл
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			ТекстЗапроса = ТекстЗапроса + ТекстОбъединитьВсе;
		КонецЕсли;
		ТекстПодзапроса = СтрЗаменить(ШаблонЗапроса, "&ИмяДокумента", ИмяДокумента);
		ТекстЗапроса = ТекстЗапроса + ТекстПодзапроса;
	КонецЦикла;
		
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("МассивДокументов", Документы);
	
	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
		Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Выполняет попытку проведения документов.
//
// Параметры:
//	Документы                - Массив - документы, которые необходимо провести.
//
// Возвращаемое значение:
//	Массив - массив структур с полями:
//									Ссылка         - документ, который не удалось провести;
//									ОписаниеОшибки - текст описания ошибки при проведении.
//
Функция ПровестиДокументы(Документы) Экспорт
	
	НепроведенныеДокументы = Новый Массив;
	
	Для Каждого ДокументСсылка Из Документы Цикл
		
		ВыполненоУспешно = Ложь;
		ДокументОбъект = ДокументСсылка.ПолучитьОбъект();
		Если ДокументОбъект.ПроверитьЗаполнение() Тогда
			Попытка
				ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
				ВыполненоУспешно = Истина;
			Исключение
				ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
				ЗаписьЖурналаРегистрации(НСтр("ru = 'Проведение документов при печати'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					УровеньЖурналаРегистрации.Информация, ДокументОбъект.Метаданные(), ДокументСсылка, 
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			КонецПопытки;
		Иначе
			ПредставлениеОшибки = НСтр("ru = 'Поля документа не заполнены.'");
		КонецЕсли;
		
		Если Не ВыполненоУспешно Тогда
			НепроведенныеДокументы.Добавить(Новый Структура("Ссылка,ОписаниеОшибки", ДокументСсылка, ПредставлениеОшибки));
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НепроведенныеДокументы;
	
КонецФункции 

// Проверяет наличие ссылок на объект в базе данных.
//
// Параметры:
//  Ссылка       - ЛюбаяСсылка
//               - Массив значений типа ЛюбаяСсылка
//
//  ИскатьСредиСлужебныхОбъектов - Булево - начальное значение Ложь,
//                 когда установлено Истина, тогда не будет учитываться
//                 исключения поиска ссылок, заданные при разработке конфигурации.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьСсылкиНаОбъект(Знач СсылкаИлиМассивСсылок, Знач ИскатьСредиСлужебныхОбъектов = Ложь) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	Если ТипЗнч(СсылкаИлиМассивСсылок) = Тип("Массив") Тогда
		МассивСсылок = СсылкаИлиМассивСсылок;
	Иначе
		МассивСсылок = Новый Массив;
		МассивСсылок.Добавить(СсылкаИлиМассивСсылок);
	КонецЕсли;
	
	ТаблицаСсылок = НайтиПоСсылкам(МассивСсылок);
	ТаблицаСсылок.Колонки[0].Имя = "ИсходнаяСсылка";
	ТаблицаСсылок.Колонки[1].Имя = "ОбнаруженныйСсылка";
	ТаблицаСсылок.Колонки[2].Имя = "ОбнаруженныйМетаданные";
	
	Если НЕ ИскатьСредиСлужебныхОбъектов Тогда
		ИсключенияПоискаСсылок = ПолучитьОбщийСписокИсключенийПоискаСсылок();
		Исключения = Новый Массив;
		
		Для Каждого СтрокаТаблицы Из ТаблицаСсылок Цикл
			ИсключениеПоиска = ИсключенияПоискаСсылок[СтрокаТаблицы.ОбнаруженныйМетаданные];
			Если ИсключениеПоиска = "*" Тогда
				Исключения.Добавить(СтрокаТаблицы);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из Исключения Цикл
			ТаблицаСсылок.Удалить(СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТаблицаСсылок.Количество() > 0;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с прикладными типами и коллекциями значений

// Получает имя значения перечисления как объекта метаданных
//
// Параметры:
//  Значение - значение перечисления для которого необходимо получить имя перечисления
//
// Возвращаемое значение:
//  Строка - имя значения перечисления как объекта метаданных
//
Функция ИмяЗначенияПеречисления(Значение) Экспорт
	
	ОбъектМетаданных = Значение.Метаданные();
	
	ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);
	
	Возврат ОбъектМетаданных.ЗначенияПеречисления[ИндексЗначения].Имя;
	
КонецФункции 

// Заполняет массив-приемник уникальными значениями из массива-источника.
// Если элемент в массиве-приемнике уже существует, то добавления нового элемента не происходит.
//
// Параметры:
//  МассивПриемник – Массив – массив, который заполняется уникальными значениями
//  МассивИсточник – Массив – массив, из которого подбираются элементы в массив-приемник.
// 
Процедура ЗаполнитьМассивУникальнымиЗначениями(МассивПриемник, МассивИсточник) Экспорт
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого Значение Из МассивПриемник Цикл
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла;
	
	Для каждого Значение Из МассивИсточник Цикл
		Если УникальныеЗначения[Значение] = Неопределено Тогда
			МассивПриемник.Добавить(Значение);
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам 
// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
//
// Параметры:
//	МассивРеквизитов              - Массив - массив строк с именами реквизитов объекта.
//	МассивНепроверяемыхРеквизитов - Массив строк с именами реквизитов объекта, не требующих проверки.
//
Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл
	
		ПорядковыйНомер = МассивРеквизитов.Найти(ЭлементМассива);
		Если ПорядковыйНомер <> Неопределено Тогда
			МассивРеквизитов.Удалить(ПорядковыйНомер);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

//	Преобразует таблицу значений в массив.
//	Может использоваться для передачи на клиента данных, полученных
//	на сервере в виде таблицы значений в том случае, если таблица
//	значений содержит только такие значения, которые могут
//  быть переданы на клиента
//
//	Полученный массив содержит структуры, каждая из которых повторяет
//	структуру колонок таблицы значений.
//
//	Не рекомендуется использовать для преобразования таблиц значений
//	с большим количеством строк.
//
//	Параметры: ТаблицаЗначений
//	Возвращаемое значение: Массив
//
Функция ТаблицаЗначенийВМассив(ТаблицаЗначений) Экспорт
	
	Массив = Новый Массив();
	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат Массив;

КонецФункции

// Функция СтрокаТаблицыЗначенийВСтруктуру создает
// структуру со свойствами, как колонки таблицы
// значений передаваемой строки
// и устанавливает этим свойствам значения
// из строки таблицы значений
// 
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений
//
// ВозвращаемоеЗначение:
//  Структура
//
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
	
	Структура = Новый Структура;
	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

// Создает структуру аналогичную менеджеру записи регистра сведений
// 
// Параметры:
//	МенеджерЗаписи - РегистрСведенийМенеджерЗаписи,
//	МетаданныеРегистра - метаданные регистра сведений
//
Функция СтруктураПоМенеджеруЗаписи(МенеджерЗаписи, МетаданныеРегистра) Экспорт
	
	ЗаписьКакСтруктура = Новый Структура;
	
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		ЗаписьКакСтруктура.Вставить("Период", МенеджерЗаписи.Период);
	КонецЕсли;
	Для Каждого Поле Из МетаданныеРегистра.Измерения Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Ресурсы Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Реквизиты Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	
	Возврат ЗаписьКакСтруктура;
	
КонецФункции

// Создает массив и копирует в него значения, содержащиеся в колонке коллекции строк
//
// Параметры:
//	КоллекцияСтрок - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл
//	ИмяКолонки - строка с именем поля коллекции, значения которого нужно выгрузить
//	ТолькоУникальныеЗначения - булево, необязательный, если истина, 
//		то в массив будут включены только различающиеся значения 
//
Функция ВыгрузитьКолонку(КоллекцияСтрок, ИмяКолонки, ТолькоУникальныеЗначения = Ложь) Экспорт

	МассивЗначений = Новый Массив;
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого СтрокаКоллекции Из КоллекцияСтрок Цикл
		Значение = СтрокаКоллекции[ИмяКолонки];
		Если ТолькоУникальныеЗначения И УникальныеЗначения[Значение] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивЗначений.Добавить(Значение);
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла; 
	
	Возврат МассивЗначений;
	
КонецФункции

// Преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
//
// Параметры:
//  XML     - текст в формате XML или ЧтениеXML.
//
// Схема XML:
//<?xml version="1.0" encoding="utf-8"?>
//<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
//  <xs:element name="Items">
//	<xs:complexType>
//	  <xs:sequence>
//		<xs:element maxOccurs="unbounded" name="Item">
//		  <xs:complexType>
//			<xs:attribute name="Code" type="xs:integer" use="required" />
//			<xs:attribute name="Name" type="xs:string" use="required" />
//			<xs:attribute name="Socr" type="xs:string" use="required" />
//			<xs:attribute name="Index" type="xs:string" use="required" />
//		  </xs:complexType>
//		</xs:element>
//	  </xs:sequence>
//	  <xs:attribute name="Description" type="xs:string" use="required" />
//	  <xs:attribute name="Columns" type="xs:string" use="required" />
//	</xs:complexType>
//  </xs:element>
//</xs:schema>
//
// Примеры XML-файлов см. в демонстрационной конфигурации.
// 
// Пример использования:
//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(РегистрыСведений.АдресныйКлассификатор.
//       ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст());
//
// Возвращаемое значение:
//  Структура с полями 
//   ИмяТаблицы - Строка
//   Данные - ТаблицаЗначений.
//
Функция ПрочитатьXMLВТаблицу(Знач XML) Экспорт
	
	Если ТипЗнч(XML) <> Тип("ЧтениеXML") Тогда
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(XML);
	Иначе
		Чтение = XML;
	КонецЕсли;
	
	// Прочитаем первый узел и проверим его
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение("Пустой XML");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение("Ошибка в структуре XML");
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла = ТипУзлаXML.КонецЭлемента И Чтение.Имя = "Items" Тогда
			Прервать;
		ИначеЕсли Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение("Ошибка в структуре XML");
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции // ПрочитатьXMLВТаблицу()

// Читает из строки XML или ЧтенияXML и возвращает структуру с описанием и данными таблицы значений.
//
//    Параметры:
//        Текст - строка, или ЧтениеXML с данными. 
//
//    Ожидаемый XML:
//        - типовая сериализация таблицы значений ( {http://v8.1c.ru/8.1/data/core}, ValueTable )
//
//        - старый формат: 
//                <Items Description="<Описание>" Columns="<ИмяКолонки1>, <ИмяКолонки2>... <ИмяКолонки3>" >
//                    <Item <ИмяКолонки1>="<Значение1>" <ИмяКолонки2>="<Значение2>" ... />
//                    ...
//                </Items>
//
//        - новый, упрощенный формат: 
//                <ТегКорня <ПервыйАтрибут>="<ОписаниеКолонок" Description="<Описание>">
//                    <ТегСтроки <ИмяКолонки1>="<Значение1>" <ИмяКолонки2>="<Значение2>" ... />
//                    ...
//                </ТегКорня>
//            При этом ТегКорня и ТегСтроки могут быть произвольными, Описание таблицы считывается из необязательного
//        атрибута Description корня, описание колонок - из первого атрибута корня. Описание колонок состоит из 
//        разделенных запятыми данных одиночной колонки. Для одиночной колонки указывается имя, необязательный тип
//        и необязательные квалификаторы. Например, описание колонок может быть таким:
//        "Код (Строка, 3, Фиксированная), Наименование (Строка), Порядок(Число, 10, 0, Неотрицательный), Данные"
//            Подробно описание типов см в функции ОписаниеТипаИзСтроки.
//
Функция ТаблицаЗначенийИзXML(Текст) Экспорт
	
	Если ТипЗнч(Текст)=Тип("ЧтениеXML") Тогда
		Чтение = Текст;
	Иначе
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(Текст);
	КонецЕсли;
	
	// Пытаемся читать как стандартную сериализацию
	ТипДанных = СериализаторXDTO.ПолучитьXMLТип(Чтение);
	Если ТипДанных=СериализаторXDTO.XMLТип(Тип("ТаблицаЗначений")) Тогда
		Возврат Новый Структура("Данные, Описание", СериализаторXDTO.ПрочитатьXML(Чтение) );
	КонецЕсли;
	
	// Разбираем формат вручную (стоим на корневом узле - результат попытки чтения)
	ТипУзла = Чтение.ТипУзла;
	Пока Истина Цикл
		Если ТипУзла=ТипУзлаXML.НачалоЭлемента Тогда
			Прервать;
		ИначеЕсли ТипУзла=ТипУзлаXML.Ничего Тогда
			ВызватьИсключение НСтр("ru='Не найден корневой узел XML'");
		КонецЕсли;
		Чтение.Прочитать();
	КонецЦикла;
	
	ИмяКорня = Чтение.Имя;
	
	ИмяАтрибутаОписания = "Description";
	Описание = Чтение.ПолучитьАтрибут(ИмяАтрибутаОписания);
	
	ИменаКолонок = Чтение.ПолучитьАтрибут("Columns");
	Если ИменаКолонок=Неопределено Тогда
		// Читаем из первого подходящего атрибута - не описания
		Пока Чтение.СледующийАтрибут() Цикл
			Если Описание=Неопределено Или Чтение.Имя<>ИмяАтрибутаОписания Тогда
				ИменаКолонок = Чтение.Значение;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Формируем колонки с типом
	ИменаКолонок = СтрЗаменить(СтрЗаменить(ИменаКолонок, " ", "") + ",", "),", Символы.ПС);
	Результат    = Новый ТаблицаЗначений;
	Колонки      = Результат.Колонки;
	
	Для Индекс=1 По СтрЧислоСтрок(ИменаКолонок) Цикл
		СтрокаИмени = СтрПолучитьСтроку(ИменаКолонок, Индекс);
		Поз = Найти(СтрокаИмени, "(");
		Если Поз>0 Тогда 
			// Нашли описание типа
			Результат.Колонки.Добавить(Лев(СтрокаИмени, Поз-1), ОписаниеТипаИзСтроки( Сред(СтрокаИмени, Поз+1) ));
		Иначе
			Для Каждого КлючЗначение Из Новый Структура(СтрокаИмени) Цикл
				Колонки.Добавить(КлючЗначение.Ключ);
			КонецЦикла
		КонецЕсли;
	КонецЦикла;
	
	// Собственно чтение
	Пока Чтение.Прочитать() Цикл
		ТипУзла = Чтение.ТипУзла;
		Если ТипУзла=ТипУзлаXML.КонецЭлемента И Чтение.Имя=ИмяКорня Тогда
			Прервать;
		ИначеЕсли ТипУзла=ТипУзлаXML.НачалоЭлемента Тогда
			СтрокаТаблицы = Результат.Добавить();
			Для Каждого Колонка Из Колонки Цикл
				Имя = Колонка.Имя;
				СтрокаТаблицы[Имя] = Чтение.ПолучитьАтрибут(Имя);
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Описание, Данные", Описание, Результат);
КонецФункции

// Возвращает объект ОписаниеТипов, построенный по строке текста
// 
//    Параметры:
//        Текст - строка, описывающая тип. Состоит из обязательного имени типа и необязательных квалификаторов, 
//                разделенных запятыми.
//
//    Для типа "Строка" распознаются необязательные квалификаторы:
//        - максимальная длина (число, по умолчанию 0 - без ограничений)
//        - допустимая длина (строка "Переменная" или "Фиксированная", по умолчанию - переменная)
//
//    Для типа "Число" распознаются необязательные квалификаторы:
//        - число разрядов (число, по умолчанию 0 - без ограничений)
//        - число разрядов дробной части (число, по умолчанию 0)
//        - допустимый знак (строка "Любой" или "Неотрицательный", по умолчанию - любой)
//
//    Для типа "Дата" распознается необязательный квалификатор части даты (строка "Время" или "Дата" или "ДатаВремя",
//    по умолчанию "ДатаВремя")
//
//    Для типа "ДвоичныеДанные" распознаются необязательные квалификаторы:
//        - максимальная длина (число, по умолчанию 0 - без ограничений)
//        - допустимая длина (строка "Переменная" или "Фиксированная", по умолчанию - переменная)
//
//    Для остальных типов обрабатывается только имя типа
//
Функция ОписаниеТипаИзСтроки(Текст) Экспорт
	ЧастиОписания = СтрЗаменить(СтрЗаменить(Текст, Символы.ПС, ""), ",", Символы.ПС);
	КоличествоЧастей = СтрЧислоСтрок(ЧастиОписания);
	
	ИмяИсходногоТипа = СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 1));
	Если КоличествоЧастей=1 Тогда
		Возврат Новый ОписаниеТипов(ИмяИсходногоТипа);
	КонецЕсли;
	
	ИсходныйТип = Тип(ИмяИсходногоТипа);
	Если ИсходныйТип=Тип("Строка") Или ИсходныйТип=Тип("ДвоичныеДанные") Тогда
		МаксимальнаяДлинаСтроки = "0" + СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 2));
		ДопустимаяДлинаСтроки   = СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 3));
		Если ПустаяСтрока(ДопустимаяДлинаСтроки) Тогда
			ДопустимаяДлинаСтроки = "Переменная";
		КонецЕсли;
		Возврат Новый ОписаниеТипов("Строка", Новый КвалификаторыСтроки(
			Число(МаксимальнаяДлинаСтроки), ДопустимаяДлина[ДопустимаяДлинаСтроки]
		));
		
	ИначеЕсли ИсходныйТип=Тип("Число") Тогда
		ДлинаЧисла          = "0" + СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 2));
		ДлинаДробнойЧасти   = "0" + СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 3));
		ДопустимыйЗнакЧисла = СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 4));
		Если ПустаяСтрока(ДопустимыйЗнакЧисла) Тогда
			ДопустимыйЗнакЧисла = "Любой";
		КонецЕсли;
		Возврат Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(
			Число(ДлинаЧисла), Число(ДлинаДробнойЧасти), ДопустимыйЗнак[ДопустимыйЗнакЧисла]
		));
			
	ИначеЕсли ИсходныйТип=Тип("Дата") Тогда
		СоставДаты = СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 2));
		Если ПустаяСтрока(СоставДаты) Тогда
			СоставДаты = "ДатаВремя";
		КонецЕсли;
		Возврат Новый ОписаниеТипов("Дата", Новый КвалификаторыДаты( 
			ЧастиДаты[СоставДаты]
		));
		
	КонецЕсли;

	Возврат Новый ОписаниеТипов(ИмяИсходногоТипа);
КонецФункции

// Функция выполняет сравнение двух коллекций строк, для которых доступен обход 
// посредством оператора Для каждого … Из … Цикл.
// Сравниваемые коллекции должны отвечать следующим требованиям:
//	- доступен обход посредством оператора Для каждого … Из … Цикл,
//	- наличие в обеих коллекциях всех колонок, перечисленных в параметре ИменаКолонок 
//  (если ИменаКолонок не заполнен - всех колонок)
//
// Параметры:
//	КоллекцияСтрок1 - коллекция, отвечающая вышеописанным требованиям
//	КоллекцияСтрок2 - коллекция, отвечающая вышеописанным требованиям
//	ИменаКолонок 	- строка, разделенная запятыми - имена колонок, 
//						по которым производится сравнение. 
//						Не является обязательным для коллекций, 
//						состав колонок которых можно выявить: 
//						ТаблицаЗначений, СписокЗначений, Соответствие, Структура,
//						если не указан - сравнение производится по всем колонкам.
//						Для коллекций других типов является обязательным
//	ИсключаяКолонки	- имена колонок, которые игнорируются при сравнении, необязательный
//	УчитыватьПоследовательностьСтрок - булево, если Истина, то коллекции признаются 
//						идентичными только если одинаковые строки размещены 
//						в коллекциях на одинаковых местах
//
Функция КоллекцииИдентичны(КоллекцияСтрок1, КоллекцияСтрок2, ИменаКолонок = "", ИсключаяКолонки = "", УчитыватьПоследовательностьСтрок = Ложь) Экспорт
	
	// Типы коллекций, для которых доступен состав колонок, 
	// и можно выявить, если он не задан
	ТипыОсобыхКоллекций = Новый Массив;
	ТипыОсобыхКоллекций.Добавить(Тип("ТаблицаЗначений"));
	ТипыОсобыхКоллекций.Добавить(Тип("СписокЗначений"));
	
	ТипыКоллекцийКлючИЗначение = Новый Массив;
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("Соответствие"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("Структура"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированноеСоответствие"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированнаяСтруктура"));
	
	Если ПустаяСтрока(ИменаКолонок) Тогда
		Если ТипыОсобыхКоллекций.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено 
			Или ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
			СравниваемыеКолонки = Новый Массив;
			Если ТипЗнч(КоллекцияСтрок1) = Тип("ТаблицаЗначений") Тогда
				Для Каждого Колонка Из КоллекцияСтрок1.Колонки Цикл
					СравниваемыеКолонки.Добавить(Колонка.Имя);
				КонецЦикла;
			ИначеЕсли ТипЗнч(КоллекцияСтрок1) = Тип("СписокЗначений") Тогда
				СравниваемыеКолонки.Добавить("Значение");
				СравниваемыеКолонки.Добавить("Картинка");
				СравниваемыеКолонки.Добавить("Пометка");
				СравниваемыеКолонки.Добавить("Представление");
			ИначеЕсли ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
				СравниваемыеКолонки.Добавить("Ключ");
				СравниваемыеКолонки.Добавить("Значение");
			КонецЕсли;
		Иначе
			ТекстИсключения = НСтр("ru = 'Для коллекции типа %1 необходимо указать имена полей, по которым производится сравнение'");
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИсключения, ТипЗнч(КоллекцияСтрок1));
		КонецЕсли;
	Иначе
		СравниваемыеКолонки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаКолонок);
	КонецЕсли;

	// Вычитаем исключаемые поля
	СравниваемыеКолонки = ОбщегоНазначенияКлиентСервер.СократитьМассив(СравниваемыеКолонки, 
						СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИсключаяКолонки));
						
	Если УчитыватьПоследовательностьСтрок Тогда
		
		// Параллельный обход обеих коллекций
		НомерСтрокиКоллекции1 = 0;
		Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
			// Спозиционируемся на аналогичную строку второй коллекции
			НомерСтрокиКоллекции2 = 0;
			ЕстьСтрокиКоллекции2 = Ложь;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				ЕстьСтрокиКоллекции2 = Истина;
				Если НомерСтрокиКоллекции2 = НомерСтрокиКоллекции1 Тогда
					Прервать;
				КонецЕсли;
				НомерСтрокиКоллекции2 = НомерСтрокиКоллекции2 + 1;
			КонецЦикла;
			Если Не ЕстьСтрокиКоллекции2 Тогда
				// Во второй коллекции вообще нет строк
				Возврат Ложь;
			КонецЕсли;
			// Сравниваем значения полей двух строк
			Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
				Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаКоллекции2[ИмяКолонки] Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
			НомерСтрокиКоллекции1 = НомерСтрокиКоллекции1 + 1;
		КонецЦикла;
		
		КоличествоСтрокКоллекции1 = НомерСтрокиКоллекции1;
		
		// Отдельно подсчитаем количество строк второй коллекции
		КоличествоСтрокКоллекции2 = 0;
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			КоличествоСтрокКоллекции2 = КоличествоСтрокКоллекции2 + 1;
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй
		Если КоличествоСтрокКоллекции1 = 0 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
			КоличествоСтрокКоллекции2 = 0;
		КонецЕсли;
		
		// Количество строк не должно отличаться
		Если КоличествоСтрокКоллекции1 <> КоличествоСтрокКоллекции2 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	Иначе
	
		// Проверяем идентичность состава одинаковых строк без учета их последовательности
		
		// Строки отбора накапливаем по первой коллекции для того, чтобы:
		//  - повторно не искать одинаковые строки,
		//  - убедиться, что во второй коллекции ни одной такой строки, которой нет в накопленных
		
		СтрокиОтбора = Новый ТаблицаЗначений;
		ПараметрыОтбора = Новый Структура;
		Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
			СтрокиОтбора.Колонки.Добавить(ИмяКолонки);
			ПараметрыОтбора.Вставить(ИмяКолонки);
		КонецЦикла;
		
		ЕстьСтрокиКоллекции1 = Ложь;
		Для Каждого СтрокаОтбора Из КоллекцияСтрок1 Цикл
			
			ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаОтбора);
			Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() > 0 Тогда
				// строку с такими полями уже искали
				Продолжить;
			КонецЕсли;
			ЗаполнитьЗначенияСвойств(СтрокиОтбора.Добавить(), СтрокаОтбора);
			
			// Подсчитаем количество таких строк в первой коллекции
			НайденоСтрокКоллекции1 = 0;
			Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
				СтрокаПодходит = Истина;
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
						СтрокаПодходит = Ложь;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если СтрокаПодходит Тогда
					НайденоСтрокКоллекции1 = НайденоСтрокКоллекции1 + 1;
				КонецЕсли;
			КонецЦикла;
			
			// Подсчитаем количество таких строк во второй коллекции
			НайденоСтрокКоллекции2 = 0;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				СтрокаПодходит = Истина;
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции2[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
						СтрокаПодходит = Ложь;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если СтрокаПодходит Тогда
					НайденоСтрокКоллекции2 = НайденоСтрокКоллекции2 + 1;
					// Если количество таких строк во второй коллекции превысило количество в первой, 
					// то уже можно сделать вывод, что коллекции не идентичны
					Если НайденоСтрокКоллекции2 > НайденоСтрокКоллекции1 Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			// Количество таких строк не должно отличаться
			Если НайденоСтрокКоллекции1 <> НайденоСтрокКоллекции2 Тогда
				Возврат Ложь;
			КонецЕсли;
			
			ЕстьСтрокиКоллекции1 = Истина;
			
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй
		Если Не ЕстьСтрокиКоллекции1 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
		КонецЕсли;
		
		// Проверим, что во второй коллекции нет ни одной такой строки, которой нет в накопленных
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаКоллекции2);
			Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() = 0 Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Сравнивает данные сложной структуры с учетом вложенности.
//
// Параметры:
//  Данные1 - Структура,    ФиксированнаяСтруктура.
//          - Соответствие, ФиксированноеСоответствие.
//          - Массив,       ФиксированныйМассив.
//          - ХранилищеЗначения, ТаблицаЗначений.
//          - Простые типы, которые можно сравнивать на равно,
//            например, Строка, Число, Булево.
//
//  Данные2 - те же типы, что и для параметра Данные1.
//
// Возвращаемое значение:
//  Булево.
//
Функция ДанныеСовпадают(Данные1, Данные2) Экспорт
	
	Если ТипЗнч(Данные1) <> ТипЗнч(Данные2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Данные1) = Тип("Структура")
	 ИЛИ ТипЗнч(Данные1) = Тип("ФиксированнаяСтруктура") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			СтароеЗначение = Неопределено;
			
			Если НЕ Данные2.Свойство(КлючИЗначение.Ключ, СтароеЗначение)
			 ИЛИ НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
			
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Соответствие")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированноеСоответствие") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		КлючиНовогоСоответствия = Новый Соответствие;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			КлючиНовогоСоответствия.Вставить(КлючИЗначение.Ключ, Истина);
			СтароеЗначение = Данные2.Получить(КлючИЗначение.Ключ);
			
			Если НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого КлючИЗначение Из Данные2 Цикл
			Если КлючиНовогоСоответствия[КлючИЗначение.Ключ] = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Массив")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированныйМассив") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Индекс = Данные1.Количество()-1;
		Пока Индекс >= 0 Цикл
			Если НЕ ДанныеСовпадают(Данные1.Получить(Индекс), Данные2.Получить(Индекс)) Тогда
				Возврат Ложь;
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ТаблицаЗначений") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если Данные1.Колонки.Количество() <> Данные2.Колонки.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Колонка Из Данные1.Колонки Цикл
			Если Данные2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Индекс = Данные1.Количество()-1;
			Пока Индекс >= 0 Цикл
				Если НЕ ДанныеСовпадают(Данные1[Индекс][Колонка.Имя], Данные2[Индекс][Колонка.Имя]) Тогда
					Возврат Ложь;
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ХранилищеЗначения") Тогда
	
		Если НЕ ДанныеСовпадают(Данные1.Получить(), Данные2.Получить()) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Возврат Истина;
	КонецЕсли;
	
	Возврат Данные1 = Данные2;
	
КонецФункции

// Фиксирует Данные типов Структура, Соответствие, Массив с учетом вложенности.
//
// Параметры:
//  Данные - Структура, Соответствие, Массив, значения которых являются примитивными типами,
//           хранилищем значения или не могут быть изменены. Поддерживаются типы значений:
//           Булево, Строка, Число, Дата, Неопределено, УникальныйИдентификатор, Null, Тип,
//           ХранилищеЗначения, ОбщийМодуль, ОбъектМетаданных, ТипЗначенияXDTO, ТипОбъектаXDTO,
//           ЛюбаяСсылка.
//
//  ВызыватьИсключение - Булево - начальное значение Истина. Когда установлено
//                       Ложь, тогда в случае наличия нефиксируемых данных исключение не будет
//                       вызвано, при этом данные будут зафиксированы на сколько возможно.
//
// Возвращаемое значение:
//  Фиксированные данные, аналогичные переданным в параметре Данные.
// 
Функция ФиксированныеДанные(Данные, ВызыватьИсключение = Истина) Экспорт
	
	Если ТипЗнч(Данные) = Тип("Массив") Тогда
		Массив = Новый Массив;
		
		Индекс = Данные.Количество() - 1;
		
		Для каждого Значение Из Данные Цикл
			
			Если ТипЗнч(Значение) = Тип("Структура")
			 ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
			 ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Массив.Добавить(ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Массив.Добавить(Значение);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Новый ФиксированныйМассив(Массив);
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура")
	      ИЛИ ТипЗнч(Данные) = Тип("Соответствие") Тогда
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Коллекция = Новый Структура;
		Иначе
			Коллекция = Новый Соответствие;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные Цикл
			Значение = КлючИЗначение.Значение;
			
			Если ТипЗнч(Значение) = Тип("Структура")
			 ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
			 ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Коллекция.Вставить(
					КлючИЗначение.Ключ, ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Коллекция.Вставить(КлючИЗначение.Ключ, Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Возврат Новый ФиксированнаяСтруктура(Коллекция);
		Иначе
			Возврат Новый ФиксированноеСоответствие(Коллекция);
		КонецЕсли;
		
	ИначеЕсли ВызыватьИсключение Тогда
		ПроверкаФиксированностиДанных(Данные);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Создает копию объекта XDTO.
//
// Параметры:
//  Фабрика - ФабрикаXDTO - фабрика, которой создан исходный объект
//  Объект - ОбъектXDTO - объект, копию которого требуется создать
//
// Возвращаемое значение:
//  ОбъектXDTO - копия исходного объекта XDTO
Функция СкопироватьXDTO(Знач Фабрика, Знач Объект) Экспорт
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Фабрика.ЗаписатьXML(Запись, Объект, , , , НазначениеТипаXML.Явное);
	
	XMLПредставление = Запись.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(XMLПредставление);
	
	Возврат Фабрика.ПрочитатьXML(Чтение, Объект.Тип());
	
КонецФункции

// Возвращает XML представление типа XDTO.
//
// Параметры:
//  ТипXDTO - ТипОбъектаXDTO, ТипЗначенияXDTO - тип XDTO для которого требуется получить
//   XML представление
//
// Возвращаемое значение:
//  Строка - XML представление типа XDTO
//
Функция ПредставлениеТипаXDTO(ТипXDTO) Экспорт
	
	Возврат СериализаторXDTO.XMLСтрока(Новый РасширенноеИмяXML(ТипXDTO.URIПространстваИмен, ТипXDTO.Имя))
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Математические процедуры и функции

// Выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
//
// Параметры:
//		ИсхСумма   - распределяемая сумма
//		МассивКоэф - массив коэффициентов распределения
//		Точность   - точность округления при распределении. Необязателен.
//
//	Возврат:
//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьСуммуПропорциональноКоэффициентам(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт
	
	Если МассивКоэф.Количество() = 0 Или НЕ ЗначениеЗаполнено(ИсхСумма) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		
		МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);
		
		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач = МодульЧисла;
			ИндексМакс = К;
		КонецЕсли;
		
		СуммаКоэф = СуммаКоэф + МассивКоэф[К];
		
	КонецЦикла;
	
	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСумм = Новый Массив(МассивКоэф.Количество());
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		РаспрСумма = РаспрСумма + МассивСумм[К];
	КонецЦикла;
	
	// Погрешности округления отнесем на коэффициент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;
	
	Возврат МассивСумм;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с внешним соединением

// Возвращает имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
Функция ИмяCOMСоединителя() Экспорт
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	ПодстрокиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		СистемнаяИнфо.ВерсияПриложения, ".");
	Возврат "v" + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + ".COMConnector";
	
КонецФункции	

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
// 
// Параметры:
//  Параметры - Структура - содержит параметры для установки внешнего соединения с информационной базой.
//  Структура должна содержать следующие ключи (см. функция ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//	  ВариантРаботыИнформационнойБазы             - (Число)  Вариант работы информационной базы: 0 – файловый; 1 – клиент-серверный
//	  КаталогИнформационнойБазы                   - (Строка) Каталог информационной базы для файлового режима работы
//	  ИмяСервера1СПредприятия                     - (Строка) Имя сервера1С:Предприятия
//	  ИмяИнформационнойБазыНаСервере1СПредприятия - (Строка) Имя информационной базы на сервере1С:Предприятия
//	  АутентификацияОперационнойСистемы           - (Булево) Признак аутентификации операционной системы при создании внешнего подключения к информационной базе
//	  ИмяПользователя                             - (Строка) Имя пользователя информационной базы
//	  ПарольПользователя                          - (Строка) Пароль пользователя информационной базы
// 
//  СтрокаСообщенияОбОшибке (необязательный) – Строка – если в процессе установки внешнего соединения возникает ошибка,
//                                                     то подробное описание ошибки помещается в этот параметр
//
// Возвращаемое значение:
//  Тип: COM-объект, Неопределенно.
//  в случае успешной установки внешнего соединения возвращается указатель на COM-объект соединения;
//  в случае ошибки возвращается Неопределенно.
//
Функция УстановитьВнешнееСоединение(Параметры, СтрокаСообщенияОбОшибке = "", ОшибкаПодключенияКомпоненты = Ложь) Экспорт
	
	Результат = УстановитьВнешнееСоединениеСБазой(Параметры);
	
	ОшибкаПодключенияКомпоненты = Результат.ОшибкаПодключенияКомпоненты;
	СтрокаСообщенияОбОшибке     = Результат.ПодробноеОписаниеОшибки;
	
	Возврат Результат.Соединение;
КонецФункции

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
// 
// Параметры:
//  Параметры - Структура - содержит параметры для установки внешнего соединения с информационной базой.
//  Структура должна содержать следующие ключи (см. функция ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//	  ВариантРаботыИнформационнойБазы             - (Число)  Вариант работы информационной базы: 0 – файловый; 1 – клиент-серверный
//	  КаталогИнформационнойБазы                   - (Строка) Каталог информационной базы для файлового режима работы
//	  ИмяСервера1СПредприятия                     - (Строка) Имя сервера1С:Предприятия
//	  ИмяИнформационнойБазыНаСервере1СПредприятия - (Строка) Имя информационной базы на сервере1С:Предприятия
//	  АутентификацияОперационнойСистемы           - (Булево) Признак аутентификации операционной системы при создании внешнего подключения к информационной базе
//	  ИмяПользователя                             - (Строка) Имя пользователя информационной базы
//	  ПарольПользователя                          - (Строка) Пароль пользователя информационной базы
// 
// Возвращаемое значение - структура:
//  Соединение                  - (COM-объект) указатель на COM-объект соединения или Неопределено в случае ошибки
//  КраткоеОписаниеОшибки       - (Строка) краткое описание ошибки
//  ПодробноеОписаниеОшибки     - (Строка) подробное описание ошибки
//  ОшибкаПодключенияКомпоненты - (Булево) флаг ошибки подключения COM
//
Функция УстановитьВнешнееСоединениеСБазой(Параметры) Экспорт
	
	Результат = Новый Структура("Соединение, КраткоеОписаниеОшибки, ПодробноеОписаниеОшибки, ОшибкаПодключенияКомпоненты",
	Неопределено, "", "", Ложь
	);
	
	Попытка
		COMConnector = Новый COMObject(ИмяCOMСоединителя()); // "V82.COMConnector"
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр("ru = 'Не удалось подключится к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
		Возврат Результат;
	КонецПопытки;
	
	Если Параметры.ВариантРаботыИнформационнойБазы = 0 Тогда
		// Файловый режим
		Если ПустаяСтрока(Параметры.КаталогИнформационнойБазы) Тогда
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не задано месторасположение каталога информационной базы.'");
			Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
			Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
			Возврат Результат;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			
		Иначе
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",           Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",        Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	Иначе 
		// Клиент-серверный вариант работы информационной базы
		Если ПустаяСтрока(Параметры.ИмяСервера1СПредприятия) Или ПустаяСтрока(Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия) Тогда
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не заданы обязательные параметры подключения: ""Имя сервера""; ""Имя информационной базы на сервере"".'");
			
			Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
			Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
			Возврат Результат;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			СтрокаСоединения = "Srvr = &ИмяСервера1СПредприятия; Ref = &ИмяИнформационнойБазыНаСервере1СПредприятия";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			
		Иначе
			СтрокаСоединения = "Srvr = &ИмяСервера1СПредприятия; Ref = &ИмяИнформационнойБазыНаСервере1СПредприятия; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",                             Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",                          Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Попытка
		Результат.Соединение = COMConnector.Connect(СтрокаСоединения);
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр("ru = 'Не удалось подключится к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
	КонецПопытки;
	
	Возврат Результат;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции

// Выполнить экспортную процедуру по имени.
//
// Параметры
//  ИмяЭкспортнойПроцедуры – Строка – имя экспортной процедуры в формате 
//                                    <имя объекта>.<имя процедуры>, где <имя объекта> - это
//                                    общий модуль или модуль менеджера объекта.
// Параметры               - Массив - параметры передаются в процедуру <ИмяЭкспортнойПроцедуры>
//                                    в порядке расположения элементов массива.
// ОбластьДанных           - Число  - задает область данных, в которой необходимо выполнить процедуру.
// 
// Пример:
//  ВыполнитьБезопасно("МойОбщийМодуль.МояПроцедура");
//
Процедура ВыполнитьБезопасно(ИмяЭкспортнойПроцедуры, Параметры = Неопределено, ОбластьДанных = Неопределено) Экспорт
	
	// Проверка предусловий на формат ИмяЭкспортнойПроцедуры.       
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭкспортнойПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
	КонецЕсли;

	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
	КонецЕсли;
		
	Если ЧастиИмени.Количество() = 3 Тогда
		ДопустимыеИменаТипов = Новый Массив;
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаКонстанты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыСведений()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыНакопления()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыБухгалтерии()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыРасчета()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаСправочники()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаДокументы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаОтчеты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаОбработки()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаБизнесПроцессы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЖурналыДокументов()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЗадачи()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыСчетов()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыОбмена()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовХарактеристик()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовРасчета()));
		ИмяТипа = ВРег(ЧастиИмени[0]);
		Если ДопустимыеИменаТипов.Найти(ИмяТипа) = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);
		КонецЕсли;
	КонецЕсли;
	
	ИмяМетода = ЧастиИмени[ЧастиИмени.ВГраница()];
	ВременнаяСтруктура = Новый Структура;
	Попытка
		// Проверка на то, что ИмяМетода является допустимым идентификатором.
		// Например: МояПроцедура
		ВременнаяСтруктура.Вставить(ИмяМетода);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Безопасное выполнение метода'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);
	КонецПопытки;
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + Индекс + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	
	ВыполненаУстановкаРазделенияСеанса = Ложь;
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Если Не ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
			Если ОбластьДанных = Неопределено Тогда
				ОбластьДанных = ЗначениеРазделителяСеанса();
			Иначе 
				Если ОбластьДанных <> ЗначениеРазделителяСеанса() Тогда
					ВызватьИсключение(НСтр("ru = 'В данном сеансе недопустимо обращение к данным из другой области данных!'"));
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ОбластьДанных <> Неопределено
			И (НЕ ИспользованиеРазделителяСеанса() ИЛИ ОбластьДанных <> ЗначениеРазделителяСеанса()) Тогда
			УстановитьРазделениеСеанса(Истина, ОбластьДанных);
			ВыполненаУстановкаРазделенияСеанса = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Выполнить ИмяЭкспортнойПроцедуры + "(" + ПараметрыСтрока + ")";
	
	Если ВыполненаУстановкаРазделенияСеанса Тогда
		УстановитьРазделениеСеанса(Ложь);
	КонецЕсли;
	
КонецПроцедуры

// Проверяет имя экспортной процедуры на валидность для использования
// в инструкции Выполнить встроенного языка. При некорректном имени
// вызывается исключение.
//
Функция ПроверитьИмяЭкспортнойПроцедуры(Знач ИмяЭкспортнойПроцедуры, ТекстСообщения) Экспорт
	
	// Проверка предусловий на формат ИмяЭкспортнойПроцедуры.
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭкспортнойПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
		Возврат Ложь;
	КонецЕсли;

	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
		Возврат Ложь;
	КонецЕсли;
		
	Если ЧастиИмени.Количество() = 3 Тогда
		ДопустимыеИменаТипов = Новый Массив;
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаКонстанты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыСведений()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыНакопления()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыБухгалтерии()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыРасчета()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаСправочники()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаДокументы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаБизнесПроцессы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЗадачи()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыСчетов()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыОбмена()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовХарактеристик()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовРасчета()));
		ИмяТипа = ВРег(ЧастиИмени[0]);
		Если ДопустимыеИменаТипов.Найти(ИмяТипа) = Неопределено Тогда
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

// Переводит параметры сеанса в состояние "Не установлено". 
// 
// Параметры: 
// ПараметрыДляОчистки - Строка - имена параметров сеанса для очистки, разделенные ","
// Исключения          - Строка - имена параметров сеанса не предназначенные для очистки, разделенные ","
//
Процедура ОчиститьПараметрыСеанса(ПараметрыДляОчистки = "", Исключения = "") Экспорт
	
	МассивИсключений           = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Исключения);
	МассивПараметровДляОчистки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПараметрыДляОчистки);
	
	Если МассивПараметровДляОчистки.Количество() = 0 Тогда
		Для Каждого ПараметрСеанса Из Метаданные.ПараметрыСеанса Цикл
			Если МассивИсключений.Найти(ПараметрСеанса.Имя) = Неопределено Тогда
				МассивПараметровДляОчистки.Добавить(ПараметрСеанса.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Индекс = МассивПараметровДляОчистки.Найти("ПараметрыКлиентаНаСервере");
	Если Индекс > 0 Тогда
		МассивПараметровДляОчистки.Удалить(Индекс);
	КонецЕсли;
	
	ПараметрыСеанса.Очистить(МассивПараметровДляОчистки);
	
КонецПроцедуры

// Возвращает описание предмета в виде текстовой строки.
// 
// Параметры
//  СсылкаНаПредмет  – ЛюбаяСсылка – объект ссылочного типа.
//
// Возвращаемое значение:
//   Строка 
// 
Функция ПредметСтрокой(СсылкаНаПредмет) Экспорт
	
	Результат = "";
	
	ОбработчикиСобытия = ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриОпределенииПредставленияПредмета");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриОпределенииПредставленияПредмета(СсылкаНаПредмет, Результат);
	КонецЦикла;
	
	ОбщегоНазначенияПереопределяемый.УстановитьПредставлениеПредмета(СсылкаНаПредмет, Результат);
	
	Если ПустаяСтрока(Результат) Тогда
		Если СсылкаНаПредмет = Неопределено или СсылкаНаПредмет.Пустая() Тогда
			Результат = НСтр("ru = 'не задан'");
		ИначеЕсли Метаданные.Документы.Содержит(СсылкаНаПредмет.Метаданные()) Тогда
			Результат = Строка(СсылкаНаПредмет);
		Иначе
			ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().ПредставлениеОбъекта;
			Если ПустаяСтрока(ПредставлениеОбъекта) Тогда
				ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().Представление();
			КонецЕсли;
			Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"%1 (%2)", Строка(СсылкаНаПредмет), ПредставлениеОбъекта);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует соответствие для удаления объектов.
//
Функция ПолучитьОбщийСписокИсключенийПоискаСсылок() Экспорт
	
	МассивИсключенийИзСобытия = Новый Массив;
	
	ОбработчикиСобытия = ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииИсключенийПоискаСсылок");
	
	Для Каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриДобавленииИсключенийПоискаСсылок(МассивИсключенийИзСобытия);
	КонецЦикла;
	
	МассивИсключенийИзПереопределяемогоМодуля = ОбщегоНазначенияПереопределяемый.ПолучитьИсключенияПоискаСсылок();
	
	ИсключенияПоискаСсылок = Новый Соответствие;
	
	ДобавитьИсключенияПоискаСсылок(ИсключенияПоискаСсылок, МассивИсключенийИзСобытия);
	ДобавитьИсключенияПоискаСсылок(ИсключенияПоискаСсылок, МассивИсключенийИзПереопределяемогоМодуля);
	
	Возврат ИсключенияПоискаСсылок;
КонецФункции

// Возвращает значение в виде XML-строки.
// Преобразованы в XML-строку (сериализованы) могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
// Значение – Произвольный. Значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
// XML-строка представления значения в сериализованном виде.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Возвращает значение, полученное из XML-строки. 
// Получены из XML-строки могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
// СтрокаXML – строка представления значения в сериализованном виде.
//
// Возвращаемое значение:
// Значение, полученное из переданной XML-строки.
//
Функция ЗначениеИзСтрокиXML(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

// Формирует из исходной строки СтрокаПоиска строку для поиска данных в запросе
//
// Параметры:
//	СтрокаПоиска - Строка - исходная строка, содержащая запрещенные символы 	
//
// Возвращаемое значение:
//  Строка - строка подготовленная для поиска данных в запросе
//
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");
	
	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - месторасположение wsdl
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса
//  ИмяСервиса - Строка - имя сервиса
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//  Таймаут - Число - таймаут на операции выполняемые через полученное прокси 
//
// Возвращаемое значение:
//  WSПрокси
//
Функция WSПрокси(
			Знач АдресWSDL,
			Знач URIПространстваИмен,
			Знач ИмяСервиса,
			Знач ИмяТочкиПодключения = "",
			Знач ИмяПользователя,
			Знач Пароль,
			Знач Таймаут = Неопределено,
			Знач ДелатьКонтрольныйВызов = Ложь
	) Экспорт
	
	Если ДелатьКонтрольныйВызов И Таймаут <> Неопределено И Таймаут > 20 Тогда
		
		WSПроксиPing = ОбщегоНазначенияПовтИсп.WSПрокси(
			АдресWSDL,
			URIПространстваИмен,
			ИмяСервиса,
			ИмяТочкиПодключения,
			ИмяПользователя,
			Пароль,
			3
		);
		
		Попытка
			WSПроксиPing.Ping();
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'WSПрокси'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())
			);
			ВызватьИсключение;
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат ОбщегоНазначенияПовтИсп.WSПрокси(
		АдресWSDL,
		URIПространстваИмен,
		ИмяСервиса,
		ИмяТочкиПодключения,
		ИмяПользователя,
		Пароль,
		Таймаут
	);
	
КонецФункции

// Определяет доступность объекта метаданных по функциональным опциям.
//   Вызывающие функции кэшированы в целях оптимизации.
//
// Параметры:
//   ОбъектМетаданных (ОбъектМетаданных)
//
// Возвращаемое значение: 
//   (Булево) Истина если объект доступен.
//
Функция ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Экспорт
	Содержится = Ложь;
	Доступен = Ложь;
	
	Параметры = Новый Структура;
	Для Каждого ФункциональнаяОпция Из Метаданные.ФункциональныеОпции Цикл
		Если ФункциональнаяОпция.Состав.Содержит(ОбъектМетаданных) Тогда
			Содержится = Истина;
			Значение = ПолучитьФункциональнуюОпцию(ФункциональнаяОпция.Имя, Параметры);
			Если Значение = Истина Тогда
				Доступен = Истина;
				Прервать;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат НЕ Содержится ИЛИ Доступен;
КонецФункции // ОбъектМетаданныхДоступенПоФункциональнымОпциям

// Устанавливает или снимает пометку удаления для всех объектов, которые ссылаются на заданный "объект-владелец".
//
//  Параметры:
// Владелец – ПланОбменаСсылка, СправочникСсылка, ДокументСсылка и пр. 
// Ссылка на объект, который является "владельцем" по отношению к помечаемым на удаление объектам.
//
// ПометкаУдаления – Булево. Признак установки/снятия пометки на удаление у всех "подчиненных" объектов.
// Истина - пометка будет установлена; Ложь - пометка будет снята.
//
Процедура УстановитьПометкуУдаленияПодчиненнымОбъектам(Знач Владелец, Знач ПометкаУдаления) Экспорт
	
	НачатьТранзакцию();
	Попытка
		
		СписокСсылок = Новый Массив;
		СписокСсылок.Добавить(Владелец);
		Ссылки = НайтиПоСсылкам(СписокСсылок);
		
		Для Каждого Ссылка из Ссылки Цикл
			
			Если ЗначениеСсылочногоТипа(Ссылка[1]) Тогда
				
				Ссылка[1].ПолучитьОбъект().УстановитьПометкуУдаления(ПометкаУдаления);
				
			КонецЕсли;
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Пытается выполнить запрос в несколько попыток.
// Используется для чтения вне транзакции часто изменяемых данных.
// При вызове в транзакции выдает ошибку.
//
// Параметры:
//  Запрос - Запрос - запрос который требуется выполнить
//
// Возвращаемое значение:
//  РезультатЗапроса - результат выполнения запроса
//
Функция ВыполнитьЗапросВнеТранзакции(Знач Запрос) Экспорт
	
	Если ТранзакцияАктивна() Тогда
		ВызватьИсключение(НСтр("ru = 'Транзакция активна. Выполнение запроса вне транзакции невозможно.'"));
	КонецЕсли;
	
	КоличествоПопыток = 0;
	
	Результат = Неопределено;
	Пока Истина Цикл
		Попытка
			Результат = Запрос.Выполнить(); // Чтение вне транзакции, возможно появление ошибки 
			                                // Could not continue scan with NOLOCK due to data movement
			                                // в этом случае нужно повторить попытку чтения
			Прервать;
		Исключение
			КоличествоПопыток = КоличествоПопыток + 1;
			Если КоличествоПопыток = 5 Тогда
				ВызватьИсключение;
			КонецЕсли;
		КонецПопытки;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает общие параметры базовой функциональности.
Функция ОбщиеПараметрыБазовойФункциональности() Экспорт
	
	ОбщиеПараметры = Новый Структура;
	ОбщиеПараметры.Вставить("ИмяФормыПерсональныхНастроек", "");
	ОбщиеПараметры.Вставить("МинимальноНеобходимаяВерсияПлатформы", "8.2.17.153");
	ОбщиеПараметры.Вставить("РаботаВПрограммеЗапрещена", Ложь);
	ОбщиеПараметры.Вставить("ЗапрашиватьПодтверждениеПриЗавершенииПрограммы", Истина);
	
	ОбщегоНазначенияПереопределяемый.ПриОпределенииОбщихПараметровБазовойФункциональности(ОбщиеПараметры);
	
	ОбщегоНазначенияПереопределяемый.ИмяФормыПерсональныхНастроек(ОбщиеПараметры.ИмяФормыПерсональныхНастроек);
	ОбщегоНазначенияВызовСервераПереопределяемый.ПолучитьМинимальноНеобходимуюВерсиюПлатформы(ОбщиеПараметры);
	ОбщегоНазначенияПереопределяемый.ПолучитьМинимальноНеобходимуюВерсиюПлатформы(ОбщиеПараметры);
	
	Возврат ОбщиеПараметры;
	
КонецФункции

// Определяет, что эта информационная база является подчиненным узлом
// распределенной информационной базы (РИБ).
//
Функция ЭтоПодчиненныйУзелРИБ() Экспорт
	
	Возврат ПланыОбмена.ГлавныйУзел() <> Неопределено;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с формами

// Процедура предназначена для заполнения реквизита формы типа «ДеревоЗначений»
//
// Параметры:
// КоллекцияЭлементовДерева – реквизит формы, который имеет тип «ДеревоЗначений»;
// 							  реквизит заполняется значениями из второго параметра процедуры.
// ДеревоЗначений           – ДеревоЗначений – параметр содержит данные для заполнения.
// 
Процедура ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(КоллекцияЭлементовДерева, ДеревоЗначений) Экспорт
	
	Для Каждого Строка Из ДеревоЗначений.Строки Цикл
		
		ЭлементДерева = КоллекцияЭлементовДерева.Добавить();
		
		ЗаполнитьЗначенияСвойств(ЭлементДерева, Строка);
		
		Если Строка.Строки.Количество() > 0 Тогда
			
			ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(ЭлементДерева.ПолучитьЭлементы(), Строка);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Получает картинку для вывода на странице с комментарием в зависимости
// от наличия текста в комментарии.
//
// Параметры
//  Комментарий  - Строка - текст комментария
//
// Возвращаемое значение:
//  Картинка - Картинка, которая должна отображаться на странице с комментарием.
//
Функция ПолучитьКартинкуКомментария(Комментарий) Экспорт
	
	Если НЕ ПустаяСтрока(Комментарий) Тогда
		Картинка = БиблиотекаКартинок.Комментарий;
	Иначе
		Картинка = Новый Картинка;
	КонецЕсли;
	
	Возврат Картинка;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с типами, объектами метаданных и их строковыми представлениями.

// Получает дерево метаданных конфигурации с заданным отбором по объектам метаданных.
//
// Параметры:
// Отбор – Структура – содержит значения элементов отбора.
//						Если параметр задан, то будет получено дерево метаданных в соответствии с заданным отбором. 
//						Ключ (Строка) – имя свойства элемента метаданных;
//						Значение (Массив) – множество значений для отбора.
//
// Пример инициализации переменной "Отбор":
//
// Массив = Новый Массив;
// Массив.Добавить("Константа.ИспользоватьСинхронизациюДанных");
// Массив.Добавить("Справочник.Валюты");
// Массив.Добавить("Справочник.Организации");
// Отбор = Новый Структура;
// Отбор.Вставить("ПолноеИмя", Массив);
// 
//  Возвращаемое значение:
//  Тип: ДеревоЗначений - дерево описания метаданных конфигурации
//
Функция ПолучитьДеревоМетаданныхКонфигурации(Отбор = Неопределено) Экспорт
	
	ИспользоватьОтбор = (Отбор <> Неопределено);
	
	КоллекцииОбъектовМетаданных = Новый ТаблицаЗначений;
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Имя");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Синоним");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Картинка");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("КартинкаОбъекта");
	
	НоваяСтрокаКоллекцииОбъектовМетаданных("Константы",               "Константы",                 БиблиотекаКартинок.Константа,              БиблиотекаКартинок.Константа,                    КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Справочники",             "Справочники",               БиблиотекаКартинок.Справочник,             БиблиотекаКартинок.Справочник,                   КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Документы",               "Документы",                 БиблиотекаКартинок.Документ,               БиблиотекаКартинок.ДокументОбъект,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовХарактеристик", "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыСчетов",             "Планы счетов",              БиблиотекаКартинок.ПланСчетов,             БиблиотекаКартинок.ПланСчетовОбъект,             КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовРасчета",       "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыСведений",        "Регистры сведений",         БиблиотекаКартинок.РегистрСведений,        БиблиотекаКартинок.РегистрСведений,              КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыНакопления",      "Регистры накопления",       БиблиотекаКартинок.РегистрНакопления,      БиблиотекаКартинок.РегистрНакопления,            КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыБухгалтерии",     "Регистры бухгалтерии",      БиблиотекаКартинок.РегистрБухгалтерии,     БиблиотекаКартинок.РегистрБухгалтерии,           КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыРасчета",         "Регистры расчета",          БиблиотекаКартинок.РегистрРасчета,         БиблиотекаКартинок.РегистрРасчета,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("БизнесПроцессы",          "Бизнес-процессы",           БиблиотекаКартинок.БизнесПроцесс,          БиблиотекаКартинок.БизнесПроцессОбъект,          КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Задачи",                  "Задачи",                    БиблиотекаКартинок.Задача,                 БиблиотекаКартинок.ЗадачаОбъект,                 КоллекцииОбъектовМетаданных);
	
	// возвращаемое значение функции
	ДеревоМетаданных = Новый ДеревоЗначений;
	ДеревоМетаданных.Колонки.Добавить("Имя");
	ДеревоМетаданных.Колонки.Добавить("ПолноеИмя");
	ДеревоМетаданных.Колонки.Добавить("Синоним");
	ДеревоМетаданных.Колонки.Добавить("Картинка");
	
	Для Каждого СтрокаКоллекции Из КоллекцииОбъектовМетаданных Цикл
		
		СтрокаДерева = ДеревоМетаданных.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаДерева, СтрокаКоллекции);
		Для Каждого ОбъектМетаданных Из Метаданные[СтрокаКоллекции.Имя] Цикл
			
			Если ИспользоватьОтбор Тогда
				
				ОбъектПрошелФильтр = Истина;
				Для Каждого ЭлементОтбора Из Отбор Цикл
					
					Значение = ?(ВРег(ЭлементОтбора.Ключ) = ВРег("ПолноеИмя"), ОбъектМетаданных.ПолноеИмя(), ОбъектМетаданных[ЭлементОтбора.Ключ]);
					Если ЭлементОтбора.Значение.Найти(Значение) = Неопределено Тогда
						ОбъектПрошелФильтр = Ложь;
						Прервать;
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не ОбъектПрошелФильтр Тогда
					Продолжить;
				КонецЕсли;
				
			КонецЕсли;
			
			СтрокаДереваОМ = СтрокаДерева.Строки.Добавить();
			СтрокаДереваОМ.Имя       = ОбъектМетаданных.Имя;
			СтрокаДереваОМ.ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			СтрокаДереваОМ.Синоним   = ОбъектМетаданных.Синоним;
			СтрокаДереваОМ.Картинка  = СтрокаКоллекции.КартинкаОбъекта;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// удаляем строки без подчиненных элементов
	Если ИспользоватьОтбор Тогда
		
		// используем обратный порядок обхода дерева значений
		КолвоЭлементовКоллекции = ДеревоМетаданных.Строки.Количество();
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
			
			ТекущийИндекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
			СтрокаДерева = ДеревоМетаданных.Строки[ТекущийИндекс];
			Если СтрокаДерева.Строки.Количество() = 0 Тогда
				ДеревоМетаданных.Строки.Удалить(ТекущийИндекс);
			КонецЕсли;
			
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат ДеревоМетаданных;
	
КонецФункции

// Получить представление физического места размещения информационной базы для отображения администратору.
//
// Возвращаемое значение:
//   Строка      - представление информационной базы
//
// Пример возвращаемого результата:
// - для ИБ в файлом режиме: \\FileServer\1c_ib\
// - для ИБ в серверном режиме: ServerName:1111 / information_base_name
//
Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
	
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
	
	Если ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
		Возврат Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
	КонецЕсли;
		
	// Прибавить к имени сервера имя пути информационной базы
	ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "SRVR=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
	НачальнаяПозицияКопирования = 6 + 1;
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	
	СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
	
	// Позиция имени сервера
	ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "REF=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НачальнаяПозицияКопирования = 6;
	ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	ПутьКБД = ИмяСервера + "/ " + ИмяИБНаСервере;
	Возврат ПутьКБД;
	
КонецФункции

// Возвращает строку реквизитов объекта метаданных с заданным типом
//
// Параметры:
//  Ссылка – ЛюбаяСсылка – ссылка на элемент базы данных, для которого требуется получить результат функции
//  Тип    – Тип – тип значения реквизита
// 
//  Возвращаемое значение:
// Тип: Строка – строка реквизитов объекта метаданных конфигурации, разделенные символом ","
//
Функция ИменаРеквизитовПоТипу(Ссылка, Тип) Экспорт
	
	Результат = "";
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		Если Реквизит.Тип.СодержитТип(Тип) Тогда
			Результат = Результат + ?(ПустаяСтрока(Результат), "", ", ") + Реквизит.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Возвращает имя базового типа по переданному значению объекта метаданных
//
// Параметры:
//  ОбъектМетаданных - объект метаданных, по которому необходимо определить базовый тип
// 
// Возвращаемое значение:
//  Строка - имя базового типа по переданному значению объекта метаданных
//
Функция ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) Экспорт
	
	Если Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаДокументы();
		
	ИначеЕсли Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаСправочники();
		
	ИначеЕсли Метаданные.Перечисления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПеречисления();
		
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыСведений();
		
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыНакопления();
		
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыБухгалтерии();
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыРасчета();
		
	ИначеЕсли Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыОбмена();
		
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовХарактеристик();
		
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаБизнесПроцессы();
		
	ИначеЕсли Метаданные.Задачи.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЗадачи();
		
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыСчетов();
		
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовРасчета();
		
	ИначеЕсли Метаданные.Константы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаКонстанты();
		
	ИначеЕсли Метаданные.ЖурналыДокументов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЖурналыДокументов();
		
	ИначеЕсли Метаданные.Последовательности.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПоследовательности();
		
	ИначеЕсли Метаданные.РегламентныеЗадания.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегламентныеЗадания();
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

// Возвращает менеджер объекта по полному имени объекта метаданных
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  ПолноеИмя    - Строка, полное имя объекта метаданных,
//                 например, "Справочник.Организации"
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	КлассОМ = ЧастиИмени[0];
	ИмяОМ   = ЧастиИмени[1];
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Возврат ПланыОбмена[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Возврат Справочники[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Возврат Документы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Возврат ЖурналыДокументов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Возврат Перечисления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Возврат Отчеты[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Возврат Обработки[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Возврат ПланыВидовХарактеристик[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Возврат ПланыСчетов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Возврат ПланЫВидовРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Возврат РегистрыСведений[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Возврат РегистрыНакопления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Возврат РегистрыБухгалтерии[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Возврат РегистрыРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Возврат БизнесПроцессы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Возврат Задачи[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Возврат Константы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Возврат Последовательности[ИмяОМ];
		
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неизвестный тип объекта метаданных (%1)'"), КлассОМ);
	КонецЕсли;
	
КонецФункции

// Возвращает менеджер объекта по ссылке на объект
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Справочники[ИмяОбъекта];
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Документы[ИмяОбъекта];
		
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
		
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
		
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Задачи[ИмяОбъекта];
		
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Перечисления[ИмяОбъекта];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки
//
// Параметры:
//  ЛюбаяСсылка - значение любой ссылки информационной базы данных
// 
// Возвращаемое значение:
//  Истина - ссылка физически существует;
//  Ложь   - ссылка физически не существует
//
Функция СсылкаСуществует(ЛюбаяСсылка) Экспорт
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Ссылка КАК Ссылка
	|ИЗ
	|	[ИмяТаблицы]
	|ГДЕ
	|	Ссылка = &Ссылка
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(ЛюбаяСсылка));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Функция ВидОбъектаПоСсылке возвращает имя вида объектов метаданных
// по ссылке на объект.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
// 
Функция ВидОбъектаПоСсылке(Ссылка) Экспорт
	
	Возврат ВидОбъектаПоТипу(ТипЗнч(Ссылка));
	
КонецФункции 

// Функция возвращает имя вида объектов метаданных по типу объекта.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Тип       - Тип прикладного объекта, определенный в конфигурации
//
// Возвращаемое значение:
//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
// 
Функция ВидОбъектаПоТипу(Тип) Экспорт
	
	Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Справочник";
	
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Документ";
	
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "БизнесПроцесс";
	
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовХарактеристик";
	
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланСчетов";
	
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовРасчета";
	
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Задача";
	
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланОбмена";
	
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Перечисление";
	
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неверный тип значения параметра (%1)'"), Строка(Тип));
	
	КонецЕсли;
	
КонецФункции 

// Возвращает полное имя объекта метаданных по переданному значению ссылки
// Например,
//  "Справочник.Номенклатура";
//  "Документ.ПриходнаяНакладная"
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - значение ссылки, для которого необходимо получить имя таблицы ИБ
// 
// Возвращаемое значение:
//  Строка - полное имя объекта метаданных для указанного значения ссылки
//
Функция ИмяТаблицыПоСсылке(Ссылка) Экспорт
	
	Возврат Ссылка.Метаданные().ПолноеИмя();
	
КонецФункции

// Проверить, что значение имеет ссылочный тип данных.
//
// Параметры:
//  Значение       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  Булево       - Истина, если тип значения ссылочный.
//
Функция ЗначениеСсылочногоТипа(Значение) Экспорт
	
	Если Значение = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Задачи.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверка того, что тип имеет ссылочный тип данных
//
Функция ЭтоСсылка(Тип) Экспорт
	
	Возврат Справочники.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Документы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
		ИЛИ Задачи.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип);
	
КонецФункции

// Проверяет является ли объект группой элементов.
//
// Параметры:
//  Объект       - Объект, Ссылка, ДанныеФормыСтруктура по типу Объект.
//
// Возвращаемое значение:
//  Булево.
//
Функция ОбъектЯвляетсяГруппой(Объект) Экспорт
	
	Если ЗначениеСсылочногоТипа(Объект) Тогда
		Ссылка = Объект;
	Иначе
		Ссылка = Объект.Ссылка;
	КонецЕсли;
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Если ЭтоСправочник(МетаданныеОбъекта) Тогда
		
		Если НЕ МетаданныеОбъекта.Иерархический
		 ИЛИ МетаданныеОбъекта.ВидИерархии
		     <> Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
			
			Возврат Ложь;
		КонецЕсли;
		
	ИначеЕсли НЕ ЭтоПланВидовХарактеристик(МетаданныеОбъекта) Тогда
		Возврат Ложь;
		
	ИначеЕсли НЕ МетаданныеОбъекта.Иерархический Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Ссылка <> Объект Тогда
		Возврат Объект.ЭтоГруппа;
	КонецЕсли;
	
	Возврат ЗначениеРеквизитаОбъекта(Ссылка, "ЭтоГруппа");
	
КонецФункции

// Только для использования в процедуре ОбщегоНазначенияПереопределяемый.Заполнить-
// ТаблицуПереименованияОбъектовМетаданных() для описания переименований объектов метаданных.
// 
// Параметры:
//   Итог                    - передается в процедуру подсистемой БазоваяФункциональность.
//   ВерсияИБ                - Строка - версия при переходе на которую нужно выполнить переименование.
//   СтароеПолноеИмя         - Строка - старое полное имя объекта метаданных,    которое нужно переименовать.
//   НовоеПолноеИмя          - Строка - новое  полное имя объекта метаданных, на которое нужно переименовать.
//   ИдентификаторБиблиотеки - Строка - внутренний идентификатор библиотеки, к которой относится ВерсияИБ,
//                             для основной конфигурации не требуется.
// 
Процедура ДобавитьПереименование(Итог, ВерсияИБ, СтароеПолноеИмя, НовоеПолноеИмя, ИдентификаторБиблиотеки = "") Экспорт
	
	СтароеИмяКоллекции = ВРег(ИмяКоллекции(СтароеПолноеИмя));
	НовоеИмяКоллекции  = ВРег(ИмяКоллекции(НовоеПолноеИмя));
	
	ЗаголовокОшибки =
		НСтр("ru = 'Ошибка в процедуре ЗаполнитьТаблицуПереименованияОбъектовМетаданных
		           |общего модуля ОбщегоНазначенияПереопределяемый.'");
	
	Если СтароеИмяКоллекции <> НовоеИмяКоллекции Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ЗаголовокОшибки + Символы.ПС + Символы.ПС
			+ НСтр("ru = 'Не совпадают имена типов старого объекта метаданных:
			             |""%1""
			             |и нового объекта метаданных:
			             |""%2"".'"),
			СтароеПолноеИмя,
			НовоеПолноеИмя);
	КонецЕсли;
	
	Если Итог.КоллекцииБезКлюча[СтароеИмяКоллекции] = Неопределено Тогда
		
		СписокДопустимыхТипов = "";
		Для каждого КлючИЗначение Из Итог.КоллекцииБезКлюча Цикл
			СписокДопустимыхТипов = СписокДопустимыхТипов + КлючИЗначение.Значение + "," + Символы.ПС;
		КонецЦикла;
		СписокДопустимыхТипов = СокрП(СписокДопустимыхТипов);
		СписокДопустимыхТипов = ?(ЗначениеЗаполнено(СписокДопустимыхТипов),
			Лев(СписокДопустимыхТипов, СтрДлина(СписокДопустимыхТипов) - 1), "");
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ЗаголовокОшибки + Символы.ПС + Символы.ПС
			+ НСтр("ru = 'Объект метаданных ""%1"" и остальные
			             |объекты метаданных этого типа обновляются автоматически.
			             |
			             |Переименование требуется только для следующих типов:
			             |%2.'"),
			СтароеПолноеИмя,
			НовоеПолноеИмя,
			СписокДопустимыхТипов);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИдентификаторБиблиотеки) Тогда
		Библиотека = ВРег(ИдентификаторБиблиотеки) <> ВРег(Метаданные.Имя);
	Иначе
		ИдентификаторБиблиотеки = Метаданные.Имя;
		Библиотека = Ложь;
	КонецЕсли;
	
	ПорядокБиблиотеки = Итог.ПорядокБиблиотек[ИдентификаторБиблиотеки];
	Если ПорядокБиблиотеки = Неопределено Тогда
		ПорядокБиблиотеки = Итог.ПорядокБиблиотек.Количество();
		Итог.ПорядокБиблиотек.Вставить(ИдентификаторБиблиотеки, ПорядокБиблиотеки);
	КонецЕсли;
	
	ВерсияБиблиотеки = Итог.ВерсииБиблиотек[ИдентификаторБиблиотеки];
	Если ВерсияБиблиотеки = Неопределено Тогда
		ВерсияБиблиотеки = ОбновлениеИнформационнойБазы.ВерсияИБ(ИдентификаторБиблиотеки);
		Итог.ВерсииБиблиотек.Вставить(ИдентификаторБиблиотеки, ВерсияБиблиотеки);
	КонецЕсли;
	
	Если ВерсияБиблиотеки = "0.0.0.0" Тогда
		// При начальном заполнении переименования не требуются.
		Возврат;
	КонецЕсли;
	
	Попытка
		Результат = ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияИБ, ВерсияБиблиотеки);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Если Библиотека Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				ЗаголовокОшибки + Символы.ПС + Символы.ПС
				+ НСтр("ru = 'При сравнении указанной версии ""%1""
				             |с текущей версией ""%2""
				             |указанной библиотеки ""%3""
				             |произошла ошибка:
				             |""%4"".'"),
				ВерсияИБ,
				ВерсияБиблиотеки,
				ИдентификаторБиблиотеки,
				КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
		Иначе
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				ЗаголовокОшибки + Символы.ПС + Символы.ПС
				+ НСтр("ru = 'При сравнении указанной версии ""%1""
				             |с текущей версией конфигурации ""%2""
				             |произошла ошибка:
				             |""%3"".'"),
				ВерсияИБ,
				ВерсияБиблиотеки,
				КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
		КонецЕсли;
	КонецПопытки;
	
	Если Результат > 0 Тогда
		ЧастиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ВерсияИБ, ".");
		
		ОписаниеПереименования = Итог.Таблица.Добавить();
		ОписаниеПереименования.ПорядокБиблиотеки = ПорядокБиблиотеки;
		ОписаниеПереименования.ВерсияЧасть1      = Число(ЧастиВерсии[0]);
		ОписаниеПереименования.ВерсияЧасть2      = Число(ЧастиВерсии[1]);
		ОписаниеПереименования.ВерсияЧасть3      = Число(ЧастиВерсии[2]);
		ОписаниеПереименования.ВерсияЧасть4      = Число(ЧастиВерсии[3]);
		ОписаниеПереименования.СтароеПолноеИмя   = СтароеПолноеИмя;
		ОписаниеПереименования.НовоеПолноеИмя    = НовоеПолноеИмя;
		ОписаниеПереименования.ПорядокДобавления = Итог.Таблица.Индекс(ОписаниеПереименования);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает строковое представление типа. 
// Для ссылочных типов возвращает в формате "СправочникСсылка.ИмяОбъекта" или "ДокументСсылка.ИмяОбъекта"
// Для остальных типов приводит тип к строке, например "Число".
//
Функция СтроковоеПредставлениеТипа(Тип) Экспорт
	
	Представление = "";
	
	Если ЭтоСсылка(Тип) Тогда
	
		ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
		ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".")[1];
		
		Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "СправочникСсылка";
		
		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ДокументСсылка";
		
		ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "БизнесПроцессСсылка";
		
		ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовХарактеристикСсылка";
		
		ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланСчетовСсылка";
		
		ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовРасчетаСсылка";
		
		ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ЗадачаСсылка";
		
		ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланОбменаСсылка";
		
		ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПеречислениеСсылка";
		
		КонецЕсли;
		
		Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);
		
	Иначе
		
		Результат = Строка(Тип);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверить, что описание типа состоит из единственного типа значения и 
// совпадает с нужным типом.
//
// Возвращаемое значение:
//   Булево      - Совпадает или нет
//
Функция ОписаниеТипаСостоитИзТипа(ОписаниеТипа, ТипЗначения) Экспорт
	
	Если ОписаниеТипа.Типы().Количество() = 1
	   И ОписаниеТипа.Типы().Получить(0) = ТипЗначения Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;

КонецФункции

// Проверяет наличие табличной части у справочника
//
//Параметры
//  ИмяСправочника    - Строка - имя справочника, для которого осуществляется проверка.
//  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
//
//Возвращаемое значение:
//  Булево   - Истина, если табличная часть есть, ложь в обратном случае
//
//Пример:
//  Если НЕ ОбщегоНазначения.НаличиеТабличнойЧастиУСправочника(ИмяСправочника,"КонтактнаяИнформация") Тогда
//  	Возврат;
//  КонецЕсли;
//
Функция НаличиеТабличнойЧастиУСправочника(ИмяСправочника, ИмяТабличнойЧасти) Экспорт
	
	Возврат (Метаданные.Справочники[ИмяСправочника].ТабличныеЧасти.Найти(ИмяТабличнойЧасти) <> Неопределено);
	
КонецФункции 

// Формирует расширенное представление объекта.
// Расширенное представление объекта складывается из представления объекта, кода и наименования.
// Если для объекта не удалось получить расширенное представление,
// то возвращается стандартное представление объекта, формируемое платформой.
//
// Пример возвращаемого значения функции:
// "Контрагент 0А-0001234, ООО Телекоммуникационные системы"
//
//  Параметры:
// Объект. Тип: СправочникСсылка,
//				ПланСчетовСсылка,
//				ПланОбменаСсылка,
//				ПланВидовХарактеристикСсылка,
//				ПланВидовРасчетаСсылка.
// Объект, для которого требуется получить расширенное представление.
//
//  Возвращаемое значение:
// Тип. Строка.
// Расширенное представление объекта.
//
Функция РасширенноеПредставлениеОбъекта(Объект) Экспорт
	
	ОбъектМетаданных = Объект.Метаданные();
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Если    ИмяБазовогоТипа = ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета()
		Тогда
		
		Если  ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Код")
			И ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Наименование") Тогда
			
			ЗначенияРеквизитов = ЗначенияРеквизитовОбъекта(Объект, "Код, Наименование");
			
			ПредставлениеОбъекта = ?(ПустаяСтрока(ОбъектМетаданных.ПредставлениеОбъекта), 
										?(ПустаяСтрока(ОбъектМетаданных.Синоним), ОбъектМетаданных.Имя, ОбъектМетаданных.Синоним
										),
									ОбъектМетаданных.ПредставлениеОбъекта
			);
			
			Результат = "[ПредставлениеОбъекта] [Код], [Наименование]";
			Результат = СтрЗаменить(Результат, "[ПредставлениеОбъекта]", ПредставлениеОбъекта);
			Результат = СтрЗаменить(Результат, "[Код]",          ?(ПустаяСтрока(ЗначенияРеквизитов.Код), "<>", ЗначенияРеквизитов.Код));
			Результат = СтрЗаменить(Результат, "[Наименование]", ?(ПустаяСтрока(ЗначенияРеквизитов.Наименование), "<>", ЗначенияРеквизитов.Наименование));
			
		Иначе
			
			Результат = Строка(Объект);
			
		КонецЕсли;
		
	Иначе
		
		Результат = Строка(Объект);
		
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Возвращает признак того, что реквизит входит в подмножество стандартных реквизитов
//
// Параметры:
//  СтандартныеРеквизиты – ОписанияСтандартныхРеквизитов - тип и значение описывает коллекцию настроек различных стандартных реквизитов;
//  ИмяРеквизита – Строка – реквизит который необходимо проверить на принадлежность множеству стандартных реквизитов;
// 
//  Возвращаемое значение:
// Тип: Булево. Истина -  реквизит входит в подмножество стандартных реквизитов; Ложь – нет.
//
Функция ЭтоСтандартныйРеквизит(СтандартныеРеквизиты, ИмяРеквизита) Экспорт
	
	Для Каждого Реквизит ИЗ СтандартныеРеквизиты Цикл
		Если Реквизит.Имя = ИмяРеквизита Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
	
КонецФункции

// Получает таблицу значений с описанием требуемых свойств всех реквизитов объекта метаданного
// Получает значения свойств стандартных реквизитов и пользовательских реквизитов (созданных в режиме конфигуратора)
//
// Параметры:
//  ОбъектМетаданных  - Объект метаданных конфигурации, для которого необходимо получить значение свойств реквизитов.
//                      Например: Метаданные.Документ.РеализацияТоваровИУслуг
//  Свойства - Строка - свойства реквизитов, перечисленных через запятую, значение которых необходимо получить.
//                      Например: "Имя, Тип, Синоним, Подсказка"
//
// Возвращаемое значение:
//  ТаблицаЗначений - таблица значений с описанием требуемых свойств всех реквизитов объекта метаданного
//
Функция ПолучитьТаблицуОписанияСвойствОбъекта(ОбъектМетаданных, Свойства) Экспорт
	
	МассивСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Свойства);
	
	// возвращаемое значение функции
	ТаблицаОписанияСвойствОбъекта = Новый ТаблицаЗначений;
	
	// добавляем в таблицу поля согласно именам переданных свойств
	Для Каждого ИмяСвойства ИЗ МассивСвойств Цикл
		ТаблицаОписанияСвойствОбъекта.Колонки.Добавить(СокрЛП(ИмяСвойства));
	КонецЦикла;
	
	// заполняем строку таблицы свойствами реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.Реквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	// заполняем строку таблицы свойствами стандартных реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.СтандартныеРеквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	Возврат ТаблицаОписанияСвойствОбъекта;
	
КонецФункции

// Возвращает состояние использования элемента состава общего реквизита
//
// Параметры:
//  ЭлементСостава - ОбъектМетаданных - элемент состава общего реквизита использование
//   которого требуется проверить
//  МетаданныеОбщегоРеквизита - ОбъектМетаданных - метаданные общего реквизита,  
//   которому принадлежит ЭлементСостава
//
// Возвращаемое значение:
//  Булево - Истина, если элемент состава используется, иначе Ложь
//
Функция ЭлементСоставаОбщегоРеквизитаИспользуется(Знач ЭлементСостава, Знач МетаданныеОбщегоРеквизита) Экспорт
	
	Если ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Использовать Тогда
		Возврат Истина;
	ИначеЕсли ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.НеИспользовать Тогда
		Возврат Ложь;
	Иначе
		Возврат МетаданныеОбщегоРеквизита.АвтоИспользование = Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
	КонецЕсли;
	
КонецФункции

// Возвращает признак того, что объект метаданных используется в общих реквизитах-разделителях.
//
// Параметры:
// ОбъектМетаданных - Строка; ОбъектМетаданных - Если объект метаданных задан строкой, происходит обращение к модулю повторного использования.
// Разделитель - имя общего реквизита-разделителя, на разделение которыми проверяется объект метаданных.
//
// Возвращаемое значение:
// Булево - Истина, если объект метаданных используется хотя бы в одном общем разделителе.
//
Функция ЭтоРазделенныйОбъектМетаданных(Знач ОбъектМетаданных, Знач Разделитель) Экспорт
	
	Если ТипЗнч(ОбъектМетаданных) = Тип("Строка") Тогда
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных;
	Иначе
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	КонецЕсли;
	
	РазделенныеОбъектыМетаданных = ОбщегоНазначенияПовтИсп.РазделенныеОбъектыМетаданных(Разделитель);
	Возврат РазделенныеОбъектыМетаданных.Получить(ПолноеИмяОбъектаМетаданных) <> Неопределено;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции определения типов объектов метаданных

// Ссылочные типы данных

// Определяет принадлежность объекта метаданных к общему типу "Документ"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоДокумент(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаДокументы();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Справочник"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоСправочник(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаСправочники();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Перечисление"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПеречисление(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПеречисления();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План обмена"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланОбмена(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыОбмена();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов характеристик"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланВидовХарактеристик(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовХарактеристик();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Бизнес-процесс"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоБизнесПроцесс(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаБизнесПроцессы();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Задача"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоЗадача(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаЗадачи();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План счетов"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланСчетов(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыСчетов();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов расчета"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланВидовРасчета(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовРасчета();
	
КонецФункции

// Регистры

// Определяет принадлежность объекта метаданных к общему типу "Регистр сведений"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрСведений(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыСведений();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр накопления"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрНакопления(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыНакопления();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр бухгалтерии"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрБухгалтерии(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыБухгалтерии();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр расчета"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрРасчета(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыРасчета();
	
КонецФункции

// Константы

// Определяет принадлежность объекта метаданных к общему типу "Константа"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоКонстанта(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаКонстанты();
	
КонецФункции

// Журналы документов

// Определяет принадлежность объекта метаданных к общему типу "Журнал документов"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоЖурналДокументов(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаЖурналыДокументов();
	
КонецФункции

// Последовательности

// Определяет принадлежность объекта метаданных к общему типу "Последовательности"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПоследовательность(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПоследовательности();
	
КонецФункции

// РегламентныеЗадания

// Определяет принадлежность объекта метаданных к общему типу "Регламентные задания"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегламентноеЗадание(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегламентныеЗадания();
	
КонецФункции

// Общие

// Определяет принадлежность объекта метаданных к типу регистр
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистр(ОбъектМетаданных) Экспорт
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Возврат ИмяБазовогоТипа = ИмяТипаРегистрыСведений()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыНакопления()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыБухгалтерии()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыРасчета();
	
КонецФункции

// Определяет принадлежность объекта метаданных к ссылочному типу
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоОбъектСсылочногоТипа(ОбъектМетаданных) Экспорт
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Возврат ИмяБазовогоТипа = ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ИмяТипаДокументы()
		ИЛИ ИмяБазовогоТипа = ИмяТипаБизнесПроцессы()
		ИЛИ ИмяБазовогоТипа = ИмяТипаЗадачи()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета();
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Имена типов.

// Возвращает значение для идентификации общего типа "Регистры сведений"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыСведений() Экспорт
	
	Возврат "РегистрыСведений";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры накопления"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыНакопления() Экспорт
	
	Возврат "РегистрыНакопления";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры бухгалтерии"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыБухгалтерии() Экспорт
	
	Возврат "РегистрыБухгалтерии";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры расчета"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыРасчета() Экспорт
	
	Возврат "РегистрыРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Документы"
//
// Тип: Строка
//
Функция ИмяТипаДокументы() Экспорт
	
	Возврат "Документы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Справочники"
//
// Тип: Строка
//
Функция ИмяТипаСправочники() Экспорт
	
	Возврат "Справочники";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Перечисления"
//
// Тип: Строка
//
Функция ИмяТипаПеречисления() Экспорт
	
	Возврат "Перечисления";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Отчеты"
//
// Тип: Строка
//
Функция ИмяТипаОтчеты() Экспорт
	
	Возврат "Отчеты";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Обработки"
//
// Тип: Строка
//
Функция ИмяТипаОбработки() Экспорт
	
	Возврат "Обработки";
	
КонецФункции

// Возвращает значение для идентификации общего типа "ПланыОбмена"
//
// Тип: Строка
//
Функция ИмяТипаПланыОбмена() Экспорт
	
	Возврат "ПланыОбмена";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов характеристик"
//
// Тип: Строка
//
Функция ИмяТипаПланыВидовХарактеристик() Экспорт
	
	Возврат "ПланыВидовХарактеристик";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Бизнес-процессы"
//
// Тип: Строка
//
Функция ИмяТипаБизнесПроцессы() Экспорт
	
	Возврат "БизнесПроцессы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Задачи"
//
// Тип: Строка
//
Функция ИмяТипаЗадачи() Экспорт
	
	Возврат "Задачи";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы счетов"
//
// Тип: Строка
//
Функция ИмяТипаПланыСчетов() Экспорт
	
	Возврат "ПланыСчетов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов расчета"
//
// Тип: Строка
//
Функция ИмяТипаПланыВидовРасчета() Экспорт
	
	Возврат "ПланыВидовРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Константы"
//
// Тип: Строка
//
Функция ИмяТипаКонстанты() Экспорт
	
	Возврат "Константы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Журналы документов"
//
// Тип: Строка
//
Функция ИмяТипаЖурналыДокументов() Экспорт
	
	Возврат "ЖурналыДокументов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Последовательности"
//
// Тип: Строка
//
Функция ИмяТипаПоследовательности() Экспорт
	
	Возврат "Последовательности";
	
КонецФункции

// Возвращает значение для идентификации общего типа "РегламентныеЗадания"
//
// Тип: Строка
//
Функция ИмяТипаРегламентныеЗадания() Экспорт
	
	Возврат "РегламентныеЗадания";
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Сохранение, чтение и удаление настроек из хранилищ

// Сохраняет настройку в хранилище общих настроек.
// 
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроекСохранить.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
// 
Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		Значение,
		ОписаниеНастроек,
		ИмяПользователя,
		НужноОбновитьПовторноИспользуемыеЗначения
	);
	
КонецПроцедуры

// Загружает настройку из хранилища общих настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		ОписаниеНастроек,
		ИмяПользователя
	);
	
КонецФункции

// Удаляет настройку из хранилища общих настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроек.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеОбщихНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя
	);
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур. 
// Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//    НужноОбновитьПовторноИспользуемыеЗначения - Булево - требуется обновить повторно используемые значения
//
Процедура ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур,
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Элемент Из МассивСтруктур Цикл
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, Элемент.Настройка, Элемент.Значение);
	КонецЦикла;
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур и обновляет повторно
//   используемые значения. Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//
Процедура ХранилищеОбщихНастроекСохранитьМассивИОбновитьПовторноИспользуемыеЗначения(МассивСтруктур) Экспорт
	
	ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур, Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище общих настроек и обновляет повторно используемые 
//   значения.
// 
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроекСохранить.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
//
Процедура ХранилищеОбщихНастроекСохранитьИОбновитьПовторноИспользуемыеЗначения(КлючОбъекта, КлючНастроек, Значение) Экспорт
	
	ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,,,Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище системных настроек.
// 
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
// 
Процедура ХранилищеСистемныхНастроекСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения
	);
	
КонецПроцедуры

// Загружает настройку из хранилища системных настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеСистемныхНастроекЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя
	);
	
КонецФункции

// Удаляет настройку из хранилища системных настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеСистемныхНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеСистемныхНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя
	);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек данных форм.
// 
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
//
Процедура ХранилищеНастроекДанныхФормСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения
	);
	
КонецПроцедуры

// Загружает настройку из хранилища настроек данных форм.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеНастроекДанныхФормЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя
	);
	
КонецФункции

// Удаляет настройку из хранилища настроек данных форм.
//
// Параметры:
//   Соответствуют методу ХранилищеНастроекДанныхФорм.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеНастроекДанныхФормУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеНастроекДанныхФорм,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя
	);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек через его менеджер.
// 
// Параметры:
//   МенеджерХранилища (СтандартноеХранилищеНастроекМенеджер) Хранилище, в котором сохраняется настройка
//   КлючОбъекта       (Строка) Ключ объекта настройки. 
//                              Подробнее см. раздел справки "Настройки, автоматически сохраняемые в системном хранилище".
//   КлючНастроек      (Строка) Ключ сохраняемых настроек.
//   Значение          (*)      Содержит настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  (ОписаниеНастроек) Содержит информацию об описании настройки.
//   ИмяПользователя   (Строка) Имя пользователя, настройки которого сохраняются.
//                              Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения (Булево)
// 
Процедура ХранилищеСохранить(МенеджерХранилища, КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек, ИмяПользователя, НужноОбновитьПовторноИспользуемыеЗначения)
	
	Если НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек, Значение, ОписаниеНастроек, ИмяПользователя);
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Загружает настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища   (СтандартноеХранилищеНастроекМенеджер) Хранилище, из которого загружается настройка
//   КлючОбъекта         (Строка) Ключ объекта настройки. 
//                                Подробнее см. раздел справки "Настройки, автоматически сохраняемые в системном хранилище".
//   КлючНастроек        (Строка) Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию (*)      Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек    (ОписаниеНастроек) Через данный параметр при загрузке можно получить описание настроек.
//   ИмяПользователя     (Строка) Имя пользователя, настройки которого загружается.
//                                Если не указано, то загружается настройки текущего пользователя.
// 
// Возвращаемое значение: 
//   (*) Настройки, загруженные из хранилища. Неопределено, если настройки не найдены. 
// 
Функция ХранилищеЗагрузить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию,
	ОписаниеНастроек, ИмяПользователя)
	
	Результат = Неопределено;
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек, ОписаниеНастроек, ИмяПользователя);
	КонецЕсли;
	
	Если (Результат = Неопределено) И (ЗначениеПоУмолчанию <> Неопределено) Тогда
		Результат = ЗначениеПоУмолчанию;
	КонецЕсли;

	Возврат Результат;
	
КонецФункции

// Удаляет настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища (СтандартноеХранилищеНастроекМенеджер) Хранилище, из которого удаляется настройка
//   КлючОбъекта       (Строка)       Ключ объекта настройки. 
//                     (Неопределено) Удаляются настройки для всех объектов.
//   КлючНастроек      (Строка)       Ключ сохраняемых настроек.
//                     (Неопределено) Удаляются настройки со всеми ключами.
//   ИмяПользователя   (Строка)       Имя пользователя, настройки которого загружается.
//                     (Неопределено) Удаляются настройки всех пользователей.
// 
// Возвращаемое значение: 
//   (*) Настройки, загруженные из хранилища. Неопределено, если настройки не найдены. 
// 
Процедура ХранилищеУдалить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ИмяПользователя)
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		МенеджерХранилища.Удалить(КлючОбъекта, КлючНастроек, ИмяПользователя);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с табличными документами

// Проверяет, умещаются ли переданные табличные документы на страницу при печати.
//
// Параметры
//  ТабДокумент        – Табличный документ
//  ВыводимыеОбласти   – Массив из проверяемых таблиц или табличный документ
//  РезультатПриОшибке - Какой возвращать результат при возникновении ошибки
//
// Возвращаемое значение:
//   Булево   – умещаются или нет переданные документы
//
Функция ПроверитьВыводТабличногоДокумента(ТабДокумент, ВыводимыеОбласти, РезультатПриОшибке = Истина) Экспорт

	Попытка
		Возврат ТабДокумент.ПроверитьВывод(ВыводимыеОбласти);
	Исключение
		Возврат РезультатПриОшибке;
	КонецПопытки;

КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с журналом регистрации

// Процедура пакетной записи сообщений в журнал регистрации
// 
// Параметры: СобытияДляЖурналаРегистрации - массив структур, клиентская глобальная переменная 
// Каждая структура - сообщение для журнала регистрации.
// После записи переменная очищается.
Процедура ЗаписатьСобытияВЖурналРегистрации(СобытияДляЖурналаРегистрации) Экспорт
	
	Если ТипЗнч(СобытияДляЖурналаРегистрации) <> Тип("СписокЗначений") Тогда
		Возврат;
	КонецЕсли;	
	
	Если СобытияДляЖурналаРегистрации.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого СообщениеЖурнала Из СобытияДляЖурналаРегистрации Цикл
		ЗначениеСообщения = СообщениеЖурнала.Значение;
		ИмяСобытия = ЗначениеСообщения.ИмяСобытия;
		УровеньСобытия = УровеньСобытияПоПредставлению(ЗначениеСообщения.ПредставлениеУровня);
		ДатаСобытия = ТекущаяДатаСеанса();
		Если ЗначениеСообщения.Свойство("ДатаСобытия") И ЗначениеЗаполнено(ЗначениеСообщения.ДатаСобытия) Тогда
			ДатаСобытия = ЗначениеСообщения.ДатаСобытия;
		КонецЕсли;
		Комментарий = Строка(ДатаСобытия) + " " + ЗначениеСообщения.Комментарий;
		ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньСобытия,,, Комментарий);
	КонецЦикла;
	СобытияДляЖурналаРегистрации.Очистить();
	
КонецПроцедуры

// Включить запись уровней событий СписокУровней в журнале регистрации.
//
// Параметры: УровниСобытий - СписокЗначений - наименования уровней регистрации событий, 
//                                             которые необходимо включить
//
Процедура ВключитьИспользованиеЖурналаРегистрации(СписокУровней = Неопределено) Экспорт
	
	МассивУровней = Новый Массив();
	Если СписокУровней = Неопределено Тогда
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Информация);
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Ошибка);
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Предупреждение);
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Примечание);
	Иначе
		МассивУровней = УровниСобытияЖурналаРегистрацииПоСтроке(СписокУровней);
	КонецЕсли;
		
	МонопольныйРежимУстановленРанее = МонопольныйРежим();
	УстановитьМонопольныйРежим(Истина);
	
	Попытка
		УстановитьИспользованиеЖурналаРегистрации(МассивУровней);
	Исключение
		Если Не МонопольныйРежимУстановленРанее Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Проверяет, включена ли регистрация событий УровниСобытий в журнале регистрации.
//
// Параметры: 
//   УровниСобытий - СписокЗначений - список строк с уровнями регистрации событий журнала регистрации, 
//                                    для которых необходимо проверить, что они включены.
//                                    Если Неопределено, то проверяются все уровни событий.
//
// Возвращаемое значение: 
//   Булево - Истина, когда заданные режимы включены. Иначе - Ложь.
//
Функция ПроверитьВключениеЖурналаРегистрации(УровниСобытий = Неопределено) Экспорт	
	
	УстановленныеУровниСобытий = ПолучитьИспользованиеЖурналаРегистрации();
	Если УровниСобытий = Неопределено Тогда
		Возврат УстановленныеУровниСобытий.Количество() = 4; // включены все уровни событий?
	КонецЕсли;
	
	ИменаУровнейСобытий = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(УровниСобытий);
	Для Каждого Название Из ИменаУровнейСобытий Цикл
		УровеньСобытия = УровеньСобытияПоПредставлению(Название);
		Если УстановленныеУровниСобытий.Найти(УровеньСобытия) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы в режиме разделения данных

// Устанавливает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе
// начинает транзакцию и устанавливает исключительную управляемую блокировку
// на пространства блокировок всех объектов метаданных, входящих в состав разделителя ОбластьДанных.
//
// В других случаях (например, в локальном режиме работы) устанавливает монопольный режим. 
//
// Параметры:
// ПроверитьОтсутствиеДругихСеансов - Булево - проверить отсутствие других
// пользовательских сеансов со значением разделителя равным текущему.
// В случае обнаружения других сеансов будет выдано исключение.
// Параметр используется только при работе в модели сервиса.
//
Процедура ЗаблокироватьИБ(Знач ПроверитьОтсутствиеДругихСеансов = Истина) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если НЕ МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Истина);
		КонецЕсли;
	Иначе
		Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
			Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
			НачатьТранзакцию();
			Модуль.ЗаблокироватьТекущуюОбластьДанных(ПроверитьОтсутствиеДругихСеансов);
		Иначе
			ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
		КонецЕсли;
	КонецЕсли;
		
КонецПроцедуры

// Снимает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе,
// - если вызов делается внутри обработчика исключения (из секции Исключении...)
//   отменяет транзакцию;
// - иначе фиксирует транзакцию.
//
// В других случаях (например, в локальном режиме работы) снимает монопольный режим. 
//
Процедура РазблокироватьИБ() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
	Иначе
		Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
			Попытка
				ЗафиксироватьТранзакцию();
			Исключение
				ОтменитьТранзакцию();
			КонецПопытки;
		Иначе
			ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает разделение сеанса.
//
// Параметры:
// Использование - Булево - Использование разделителя ОбластьДанных в сеансе
// ОбластьДанных - Число - Значение разделителя ОбластьДанных
//
Процедура УстановитьРазделениеСеанса(Знач Использование, Знач ОбластьДанных = Неопределено) Экспорт
	
	ПриУстановкеРазделенияСеанса(Использование, ОбластьДанных);
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Возвращаемое значение: 
// Тип значения разделителя.
// Значение разделителя текущей области данных. 
// 
Функция ЗначениеРазделителяСеанса() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат 0;
	Иначе
		ЗначениеРазделителя = Неопределено;
		ПриПолученииЗначенияРазделителяСеанса(ЗначениеРазделителя);
		Возврат ЗначениеРазделителя;
	КонецЕсли;
	
КонецФункции

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Возвращаемое значение: 
// Булево - Истина разделение используется, иначе нет.
// 
Функция ИспользованиеРазделителяСеанса() Экспорт
	
	ИспользованиеРазделителя = Неопределено;
	ПриПолученииИспользованияРазделителяСеанса(ИспользованиеРазделителя);
	Возврат ИспользованиеРазделителя;
	
КонецФункции

// Процедура инициализации разделенной информационной базы
// 
// Параметры:
// ВключитьРазделение - Булево - признак включения разделения в
// информационной базе
//
Процедура УстановитьПараметрыРазделенияИнформационныйБазы(Знач ВключитьРазделение = Ложь) Экспорт
	
КонецПроцедуры

// Устанавливает значение двух дополнительных констант.
// Имена констант строго регламентированы и должны соответствовать шаблонам:
//  <Имя основной константы>ВМоделиСервиса
//  <Имя основной константы>ВЛокальномРежиме
//
// Параметры:
//  Значение – Булево – значение основной константы.
//  ИмяКонстанты – Строка – имя основной константы.
//
Процедура УстановитьЗначенияДополнительныхКонстант(Знач Значение, Знач ИмяКонстанты, Знач МенеджерЗначения) Экспорт
	
	Если Значение = Истина Тогда
		
		РазделениеВключено = ОбщегоНазначенияПовтИсп.РазделениеВключено();
		
		УстановитьЗначениеКонстанты(РазделениеВключено, ИмяКонстанты + "ВМоделиСервиса", МенеджерЗначения);
		УстановитьЗначениеКонстанты(Не РазделениеВключено, ИмяКонстанты + "ВЛокальномРежиме", МенеджерЗначения);
		
	Иначе
		
		УстановитьЗначениеКонстанты(Ложь, ИмяКонстанты + "ВМоделиСервиса", МенеджерЗначения);
		УстановитьЗначениеКонстанты(Ложь, ИмяКонстанты + "ВЛокальномРежиме", МенеджерЗначения);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьЗначениеКонстанты(Знач Значение, Знач ИмяКонстанты, Знач МенеджерЗначения)
	
	МенеджерКонстанты = Константы[ИмяКонстанты].СоздатьМенеджерЗначения();
	
	Для Каждого ДополнительноеСвойство Из МенеджерЗначения.ДополнительныеСвойства Цикл
		
		МенеджерКонстанты.ДополнительныеСвойства.Вставить(ДополнительноеСвойство.Ключ, ДополнительноеСвойство.Значение);
		
	КонецЦикла;
	
	МенеджерКонстанты.ОбменДанными.Загрузка = МенеджерЗначения.ОбменДанными.Загрузка;
	МенеджерКонстанты.Значение = Значение;
	МенеджерКонстанты.Записать();
	
КонецПроцедуры

// Устанавливает управляемую блокировку на объекты, разделенные разделителем РазделительВспомогательныхДанных.
//
// Параметры:
//  Блокировка - БлокировкаДанных.
//  ОбластьДанных - Число(7,0), область данных, в пределах которой устанавливается блокировка,
//  ВосстановитьРазделениеСеанса - Булево, если передано значение Истина, после установки блокировки разделение
//    будет возвращено в исходное состояние.
//  ТребуетсяВосстановлениеРазделенияСеанса - Булево, при выполнении данной процедуры данный параметр будет
//    установлен равным флагу, означающему необходимость восстановления разделения сеанса.
//    Имеет смысл только при ВосстановитьРазделениеСеанса = Ложь.
//
Процедура ЗаблокироватьВспомогательныеДанные(Знач Блокировка, Знач ОбластьДанных, Знач ВосстановитьРазделениеСеанса = Истина, ТребуетсяВосстановлениеРазделенияСеанса = Неопределено) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		Модуль.ЗаблокироватьВспомогательныеДанные(Блокировка, ОбластьДанных, ВосстановитьРазделениеСеанса, ТребуетсяВосстановлениеРазделенияСеанса);
	Иначе
		ТребуетсяВосстановлениеРазделенияСеанса = Ложь;
		Блокировка.Заблокировать();
	КонецЕсли;
	
КонецПроцедуры

// Восстанавливает исходное состояние разделения сеанса после обработки вспомогательных
// данных.
//
// Параметры:
//  ВосстановитьРазделениеСеанса - Булево, флаг необходимости восстановления
//    разделения сеанса.
//
Процедура ВосстановитьРазделениеСеансаПослеОбработкиВспомогательныхДанных(Знач ВосстановитьРазделениеСеанса = Истина) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		Модуль.ВосстановитьРазделениеСеансаПослеОбработкиВспомогательныхДанных(ВосстановитьРазделениеСеанса);
	КонецЕсли;
	
КонецПроцедуры

// Выполняет запись значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - значение ссылочного типа или УдалениеОбъекта,
//  ВосстановитьРазделениеСеанса - Булево, флаг необходимости восстановления разделения сеанса
//    после записи вспомогательных данных,
//  ТребуетсяВосстановлениеРазделенияСеанса - Булево, флаг, указывающий состояние необходимости
//    восстановления разделения сеанса на момент вызова процедуры.
//
Процедура ЗаписатьВспомогательныеДанные(ОбъектВспомогательныхДанных, Знач ВосстановитьРазделениеСеанса = Истина, ТребуетсяВосстановлениеРазделенияСеанса = Ложь) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		Модуль.ЗаписатьВспомогательныеДанные(ОбъектВспомогательныхДанных, ВосстановитьРазделениеСеанса, ТребуетсяВосстановлениеРазделенияСеанса);
	Иначе
		ОбъектВспомогательныхДанных.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Выполняет удаление значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - значение ссылочного типа,
//  ВосстановитьРазделениеСеанса - Булево, флаг необходимости восстановления разделения сеанса
//    после записи вспомогательных данных,
//  ТребуетсяВосстановлениеРазделенияСеанса - Булево, флаг, указывающий состояние необходимости
//    восстановления разделения сеанса на момент вызова процедуры.
//
Процедура УдалитьВспомогательныеДанные(ОбъектВспомогательныхДанных, Знач ВосстановитьРазделениеСеанса = Истина, ТребуетсяВосстановлениеРазделенияСеанса = Ложь) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		Модуль.УдалитьВспомогательныеДанные(ОбъектВспомогательныхДанных, ВосстановитьРазделениеСеанса, ТребуетсяВосстановлениеРазделенияСеанса);
	Иначе
		ОбъектВспомогательныхДанных.Удалить();
	КонецЕсли;
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////
// Версионирование программных интерфейсов

// Возвращает массив номеров версий, поддерживаемых интерфейсом удаленной системы.
//
// Параметры:
//  ПараметрыПодключения - Структура:
//							- URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//							- UserName - Строка - Имя пользователя сервиса.
//							- Password - Строка - Пароль пользователя сервиса.
//  ИмяИнтерфейса - Строка.
//
// Параметры:
//  Адрес - Строка - адрес web-сервиса версионирования интерфейсов
//  Пользователь - Строка - имя пользователя
//  Пароль - Строка - пароль пользователя
//  Интерфейс - Строка - имя интерфейса
//
//
// Возвращаемое значение:
// ФиксированныйМассив - Массив строк:
//	- Каждая строка является представлением номера версии интерфейса. Например, "1.0.2.1".
//
// Пример использования:
//	  ПараметрыПодключения = Новый Структура;
//	  ПараметрыПодключения.Вставить("URL", "http://vsrvx/sm");
//	  ПараметрыПодключения.Вставить("UserName", "ivanov");
//	  МассивВерсий = ПолучитьВерсииИнтерфейса(ПараметрыПодключения, "СервисПередачиФайлов");
//
// Примечание: при получении версий используется кэш, время обновления которого составляет
//  одни сутки. Если для целей отладки требуется обновить значения в кэше, раньше этого 
//  времени, следует удалить из регистра сведений КэшПрограммныхИнтерфейсов соответствующие 
//  записи.
//
Функция ПолучитьВерсииИнтерфейса(Знач Адрес, Знач Пользователь, Знач Пароль = Неопределено, Знач Интерфейс = Неопределено) Экспорт
	
	Если ТипЗнч(Адрес) = Тип("Структура") Тогда
		ПараметрыПодключения = Адрес;
		ИмяИнтерфейса = Пользователь;
	Иначе
		ПараметрыПодключения = Новый Структура;
		ПараметрыПодключения.Вставить("URL", Адрес);
		ПараметрыПодключения.Вставить("UserName", Пользователь);
		ПараметрыПодключения.Вставить("Password", Пароль);
		ИмяИнтерфейса = Интерфейс;
	КонецЕсли;
	
	Если Не ПараметрыПодключения.Свойство("URL") 
		Или Не ЗначениеЗаполнено(ПараметрыПодключения.URL) Тогда
		
		ВызватьИсключение(НСтр("ru = 'Не задан URL сервиса.'"));
	КонецЕсли;
	
	ПараметрыПолучения = Новый Массив;
	ПараметрыПолучения.Добавить(ПараметрыПодключения);
	ПараметрыПолучения.Добавить(ИмяИнтерфейса);
	
	Возврат ОбщегоНазначенияПовтИсп.ПолучитьДанныеКэшаВерсий(
		ИдентификаторЗаписиКэшаВерсий(ПараметрыПодключения.URL, ИмяИнтерфейса), 
		Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ВерсииИнтерфейса, 
		ЗначениеВСтрокуXML(ПараметрыПолучения),
		Истина);
	
КонецФункции

// Возвращает массив номеров версий, поддерживаемых интерфейсом системы, подключенной через внешнее соединение.
//
// Параметры:
// ВнешнееСоединение - объект COM-соединение, которое используется для работы с корреспондентом.
// ИмяИнтерфейса - Строка.
//
// Возвращаемое значение:
// ФиксированныйМассив - Массив строк:
//  Каждая строка является представлением номера версии интерфейса. Например, "1.0.2.1".
//
// Пример использования:
//  Параметры = ...
//  ВнешнееСоединение = ОбщегоНазначения.УстановитьВнешнееСоединение(Параметры);
//  МассивВерсий = ОбщегоНазначения.ПолучитьВерсииИнтерфейсаЧерезВнешнееСоединение(ВнешнееСоединение, "ОбменДанными");
//
Функция ПолучитьВерсииИнтерфейсаЧерезВнешнееСоединение(ВнешнееСоединение, Знач ИмяИнтерфейса) Экспорт
	
	Попытка
		ВерсииИнтерфейсаXML = ВнешнееСоединение.СтандартныеПодсистемыСервер.ПоддерживаемыеВерсии(ИмяИнтерфейса);
	Исключение
		СтрокаСообщения = НСтр("ru = 'Корреспондент не поддерживает версионирование интерфейсов подсистем.
			|Описание ошибки: %1'");
		СтрокаСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение версий интерфейса'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , СтрокаСообщения);
		
		Возврат Новый ФиксированныйМассив(Новый Массив);
	КонецПопытки;
	
	Возврат Новый ФиксированныйМассив(ЗначениеИзСтрокиXML(ВерсииИнтерфейсаXML));
КонецФункции

// Удаляет записи кэша версий содержащих в идентификаторе указанную
// подстроку. В качестве подстроки может использоваться, например,
// имя интерфейса более не используемого в конфигурации.
//
// Параметры:
//  ПодстрокаПоискаИдентификаторов - Строка - подстрока поиска 
//   идентификаторов. Строка не может содержать символов
//   %, _ и [
//
Процедура УдалитьЗаписиКэшаВерсий(Знач ПодстрокаПоискаИдентификаторов) Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить("РегистрСведений.КэшПрограммныхИнтерфейсов");
		ПодстрокаПоиска = СформироватьСтрокуДляПоискаВЗапросе(ПодстрокаПоискаИдентификаторов);

		ТекстЗапроса =
			"ВЫБРАТЬ
			|	ТаблицаКэша.Идентификатор КАК Идентификатор,
			|	ТаблицаКэша.ТипДанных КАК ТипДанных
			|ИЗ
			|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК ТаблицаКэша
			|ГДЕ
			|	ТаблицаКэша.Идентификатор ПОДОБНО ""%" + ПодстрокаПоиска + "%""
			|		СПЕЦСИМВОЛ ""~""";
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Результат = Запрос.Выполнить();
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			Запись = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьМенеджерЗаписи();
			Запись.Идентификатор = Выборка.Идентификатор;
			Запись.ТипДанных = Выборка.ТипДанных;
			
			Запись.Удалить();
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

////////////////////////////////////////////////////////////////////////////////
// Получение обработчиков серверных событий.

// Возвращает структуру для добавления обязательного события.
//
// Возвращаемое значение:
//  Структура - 
//    ИмяСобытия - Строка, представление события.
//       Пример: "СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления".
//
//    Обязательное - Булево, если Истина, то для данного события обязательно объявление обработчиков.
//
Функция НовоеСобытие() Экспорт
	
	Возврат Новый Структура("Имя, Обязательное", "", Ложь);

КонецФункции

// Возвращает обработчики указанного серверного события.
//
// Параметры:
//  Событие  - Строка, например,
//             "СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления".
//
// Возвращаемое значение:
//  ФиксированныйМассив со значениями типа
//    ФиксированнаяСтруктура со свойствами:
//      Версия - Строка      - версия обработчика, например, "2.1.3.4". Пустая строка, если не указана.
//      Модуль - ОбщийМодуль - серверный общий модуль.
// 
Функция ОбработчикиСобытия(Событие) Экспорт
	
	Массив = Новый Массив;
	
	Обработчики = СтандартныеПодсистемыПовтИсп.ОбработчикиСерверногоСобытия(Событие, Ложь);
	Для каждого Обработчик Из Обработчики Цикл
		
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль(Обработчик.Модуль);
		
		Элемент = Новый Структура;
		Элемент.Вставить("Модуль",     Модуль);
		Элемент.Вставить("Версия",     Обработчик.Версия);
		Элемент.Вставить("Подсистема", Обработчик.Подсистема);
		
		Массив.Добавить(Новый ФиксированнаяСтруктура(Элемент));
	КонецЦикла;
	
	Возврат Новый ФиксированныйМассив(Массив);
	
КонецФункции

// Возвращает обработчики указанного серверного служебного события.
//
// Параметры:
//  Событие  - Строка, например,
//             "СтандартныеПодсистемы.БазоваяФункциональность\ПриОпределенииПоддерживаемыхВерсийПрограммныхИнтерфейсов".
//
// Возвращаемое значение:
//  ФиксированныйМассив со значениями типа
//    ФиксированнаяСтруктура со свойствами:
//      Версия - Строка      - версия обработчика, например, "2.1.3.4". Пустая строка, если не указана.
//      Модуль - ОбщийМодуль - серверный общий модуль.
// 
Функция ОбработчикиСлужебногоСобытия(Событие) Экспорт
	
	Массив = Новый Массив;
	
	Обработчики = СтандартныеПодсистемыПовтИсп.ОбработчикиСерверногоСобытия(Событие, Истина);
	Для каждого Обработчик Из Обработчики Цикл
		
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль(Обработчик.Модуль);
		
		Элемент = Новый Структура;
		Элемент.Вставить("Модуль",     Модуль);
		Элемент.Вставить("Версия",     Обработчик.Версия);
		Элемент.Вставить("Подсистема", Обработчик.Подсистема);
		
		Массив.Добавить(Новый ФиксированнаяСтруктура(Элемент));
	КонецЦикла;
	
	Возврат Новый ФиксированныйМассив(Массив);
	
КонецФункции

// Обновляет данные в кэше версий
//
// Параметры:
//  Идентификатор - Строка - идентификатор записи кэша
//  ТипДанных - ПеречислениеСсылка.ТипыДанныхКэшаПрограммныхИнтерфейсов - 
//   тип обновляемых данных
//  ПараметрыПолучения - Массив - дополнительные параметры получения данных в кэш
//
Процедура ОбновитьДанныеКэшаВерсий(Знач Идентификатор, Знач ТипДанных, Знач ПараметрыПолучения) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	ТаблицаКэша.ДатаОбновления КАК ДатаОбновления,
		|	ТаблицаКэша.Данные КАК Данные,
		|	ТаблицаКэша.ТипДанных КАК ТипДанных
		|ИЗ
		|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК ТаблицаКэша
		|ГДЕ
		|	ТаблицаКэша.Идентификатор = &Идентификатор
		|	И ТаблицаКэша.ТипДанных = &ТипДанных";
	Идентификатор = Идентификатор;
	Запрос.УстановитьПараметр("Идентификатор", Идентификатор);
	Запрос.УстановитьПараметр("ТипДанных", ТипДанных);
	
	НачатьТранзакцию();
	
	ОшибкаУстановкиБлокировки = Ложь;
	
	Попытка
		
		СтруктураКлюча = Новый Структура("Идентификатор, ТипДанных", Идентификатор, ТипДанных);
		Ключ = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьКлючЗаписи(СтруктураКлюча);
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Ключ);
		Исключение
			// Данные уже обновляются из другого сеанса
			ОшибкаУстановкиБлокировки = Истина;
			ВызватьИсключение;
		КонецПопытки;
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КэшПрограммныхИнтерфейсов");
		ЭлементБлокировки.УстановитьЗначение("Идентификатор", Идентификатор);
		ЭлементБлокировки.УстановитьЗначение("ТипДанных", ТипДанных);
		Блокировка.Заблокировать();
		
		Результат = Запрос.Выполнить();
		
		// Убедимся что данные требуют обновления
		Если НЕ Результат.Пустой() Тогда
			Выборка = Результат.Выбрать();
			Выборка.Следующий();
			Если НЕ ЗаписьКэшаВерсийУстарела(Выборка) Тогда
				// Данные актуальны
				ОтменитьТранзакцию();
				Возврат;
			КонецЕсли;
		КонецЕсли;
		
		Набор = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьНаборЗаписей();
		
		Набор.Отбор.Идентификатор.Установить(Идентификатор);
		Набор.Отбор.ТипДанных.Установить(ТипДанных);
		
		Запись = Набор.Добавить();
		Запись.Идентификатор = Идентификатор;
		Запись.ТипДанных = ТипДанных;
		Запись.ДатаОбновления = ТекущаяУниверсальнаяДата();
		
		Если Не ОбщегоНазначенияПовтИсп.РазделениеВключено() Или Не ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
			Данные = ПодготовитьДанныеКэшаВерсий(ТипДанных, ПараметрыПолучения);
			Запись.Данные = Новый ХранилищеЗначения(Данные);
			
		Иначе
			
			Набор.ДополнительныеСвойства.Вставить("ПараметрыПолучения", ПараметрыПолучения);
			
		КонецЕсли;
		
		Набор.Записать();
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		
		Если ОшибкаУстановкиБлокировки Тогда
			Возврат;
		Иначе
			ВызватьИсключение;
		КонецЕсли;
		
	КонецПопытки;
	
КонецПроцедуры

// Подготавливает данные для кэша программных интерфейсов.
//
// Параметры:
//  ТипДанных - ПеречислениеСсылка.ТипыДанныхКэшаПрограммныхИнтерфейсов - 
//   тип обновляемых данных
//  ПараметрыПолучения - Массив - дополнительные параметры получения данных в кэш
//
Функция ПодготовитьДанныеКэшаВерсий(Знач ТипДанных, Знач ПараметрыПолучения) Экспорт
	
	Если ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ВерсииИнтерфейса Тогда
		Данные = ПолучитьВерсииИнтерфейсаВКэш(ПараметрыПолучения[0], ПараметрыПолучения[1]);
	ИначеЕсли ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса Тогда
		Данные = ПолучитьWSDL(ПараметрыПолучения[0], ПараметрыПолучения[1], ПараметрыПолучения[2], ПараметрыПолучения[3]);
	Иначе
		ШаблонТекста = НСтр("ru = 'Неизвестный тип данных кэша версий: %1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонТекста, ТипДанных);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Возвращает факт устаревания записи кэша версий
//
// Параметры:
//  Запись - РегистрСведенийМенеджерЗаписи.КэшПрограммныхИнтерфейсов - запись
//   факт устаревания которой требуется проверить
//
// Возвращаемое значение:
//  Булево - признак устаревания записи
//
Функция ЗаписьКэшаВерсийУстарела(Знач Запись) Экспорт
	
	Если Запись.ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса Тогда
		Возврат НЕ ЗначениеЗаполнено(Запись.ДатаОбновления)
	Иначе
		Возврат Запись.ДатаОбновления + 86400 < ТекущаяУниверсальнаяДата();
	КонецЕсли;
	
КонецФункции

// Формирует идентификатор записи кэша версий из адреса сервера и имени ресурса
//
// Параметры:
//  Адрес - Строка - адрес сервера
//  Имя - Имя - имя ресурса
//
// Возвращаемое значение:
//  Строка - идентификатор записи кэша версий 
//
Функция ИдентификаторЗаписиКэшаВерсий(Знач Адрес, Знач Имя) Экспорт
	
	Возврат Адрес + "|" + Имя;
	
КонецФункции

// Функция возвращает объект WSОпределения созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - месторасположение wsdl
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//  Таймаут - Число - таймаут на получение wsdl
//
// Примечание: при получении определения используется кэш, обновление которого осуществляется
//  при смене версии конфигурации. Если для целей отладки требуется обновить
//  значения в кэше, раньше этого времени, следует удалить из регистра сведений 
//  КэшПрограммныхИнтерфейсов соответствующие записи.
//
Функция WSОпределения(Знач АдресWSDL, Знач ИмяПользователя, Знач Пароль, Знач Таймаут = 10) Экспорт
	
	ДоступноПолучениеФайловИзИнтернета = Неопределено;
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		ДоступноПолучениеФайловИзИнтернета = Истина;
	КонецЕсли;
	
	Если ДоступноПолучениеФайловИзИнтернета = Истина Тогда
	
		ПараметрыПолучения = Новый Массив;
		ПараметрыПолучения.Добавить(АдресWSDL);
		ПараметрыПолучения.Добавить(ИмяПользователя);
		ПараметрыПолучения.Добавить(Пароль);
		ПараметрыПолучения.Добавить(Таймаут);
		
		ДанныеWSDL = ОбщегоНазначенияПовтИсп.ПолучитьДанныеКэшаВерсий(
			АдресWSDL, 
			Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса, 
			ЗначениеВСтрокуXML(ПараметрыПолучения),
			Ложь);
			
		ИмяФайлаWSDL = ПолучитьИмяВременногоФайла("wsdl");
		
		ДанныеWSDL.Записать(ИмяФайлаWSDL);
		
		Определения = Новый WSОпределения(ИмяФайлаWSDL);
		
		Попытка
			УдалитьФайлы(ИмяФайлаWSDL);
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение WSDL'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		Возврат Определения;
		
	Иначе
		
		Параметры = Новый Массив;
		Параметры.Добавить(АдресWSDL);
		Параметры.Добавить(ИмяПользователя);
		Параметры.Добавить(Пароль);
		Параметры.Добавить(Таймаут);
		
		Возврат Новый(Тип("WSОпределения"), Параметры);
		
	КонецЕсли;
	
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - месторасположение wsdl
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса
//  ИмяСервиса - Строка - имя сервиса
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//  Таймаут - Число - таймаут на операции выполняемые через полученное прокси 
//
// Возвращаемое значение:
//  WSПрокси
//
Функция ВнутренняяWSПрокси(Знач АдресWSDL, Знач URIПространстваИмен, Знач ИмяСервиса,
	Знач ИмяТочкиПодключения = "", Знач ИмяПользователя, Знач Пароль,
	Знач Таймаут = Неопределено) Экспорт
	
	WSОпределения = ОбщегоНазначенияПовтИсп.WSОпределения(АдресWSDL, ИмяПользователя, Пароль);
	
	Если ПустаяСтрока(ИмяТочкиПодключения) Тогда
		ИмяТочкиПодключения = ИмяСервиса + "Soap";
	КонецЕсли;
	
	Параметры = Новый Массив;
	Параметры.Добавить(WSОпределения);
	Параметры.Добавить(URIПространстваИмен);
	Параметры.Добавить(ИмяСервиса);
	Параметры.Добавить(ИмяТочкиПодключения);
	Параметры.Добавить(Таймаут);
	
	Прокси = Новый(Тип("WSПрокси"), Параметры);
	Прокси.Пользователь = ИмяПользователя;
	Прокси.Пароль = Пароль;
	
	Возврат Прокси;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Устаревшие процедуры и функции

// Устарела. Следует использовать ЕстьСсылкиНаОбъект.
Функция ОбъектИспользуютсяВБазеДанных(Знач СсылкаИлиМассивСсылок, Знач ИскатьСредиСлужебныхОбъектов = Ложь) Экспорт
	Возврат ЕстьСсылкиНаОбъект(СсылкаИлиМассивСсылок, ИскатьСредиСлужебныхОбъектов);
КонецФункции

// Устарела. Следует использовать ОбщегоНазначенияКлиентСервер.КлючиСтруктурыВСтроку.
Функция КлючиСтруктурыВСтроку(Структура, Разделитель = ",") Экспорт
	
	Возврат ОбщегоНазначенияКлиентСервер.КлючиСтруктурыВСтроку(Структура, Разделитель);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Функция УровеньСобытияПоПредставлению(ПредставлениеУровня)
	Если ПредставлениеУровня = "Информация" Тогда
		Возврат УровеньЖурналаРегистрации.Информация;
	ИначеЕсли ПредставлениеУровня = "Ошибка" Тогда
		Возврат УровеньЖурналаРегистрации.Ошибка;
	ИначеЕсли ПредставлениеУровня = "Предупреждение" Тогда
		Возврат УровеньЖурналаРегистрации.Предупреждение; 
	ИначеЕсли ПредставлениеУровня = "Примечание" Тогда
		Возврат УровеньЖурналаРегистрации.Примечание;
	КонецЕсли;	
КонецФункции

Функция УровниСобытияЖурналаРегистрацииПоСтроке(СписокУровней)
	МассивНазванийУровней = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СписокУровней);
	МассивУровней = Новый Массив;
	Для Каждого Название Из МассивНазванийУровней Цикл
		МассивУровней.Добавить(УровеньСобытияПоПредставлению(Название));
	КонецЦикла;
	Возврат МассивУровней;
КонецФункции

Процедура НоваяСтрокаКоллекцииОбъектовМетаданных(Имя, Синоним, Картинка, КартинкаОбъекта, Таб)
	
	НоваяСтрока = Таб.Добавить();
	НоваяСтрока.Имя               = Имя;
	НоваяСтрока.Синоним           = Синоним;
	НоваяСтрока.Картинка          = Картинка;
	НоваяСтрока.КартинкаОбъекта   = КартинкаОбъекта;
	
КонецПроцедуры

Функция ПолучитьВерсииИнтерфейсаВКэш(Знач ПараметрыПодключения, Знач ИмяИнтерфейса)
	
	Если Не ПараметрыПодключения.Свойство("URL") 
		Или Не ЗначениеЗаполнено(ПараметрыПодключения.URL) Тогда
		
		ВызватьИсключение(НСтр("ru = 'Не задан URL сервиса.'"));
	КонецЕсли;
	
	Если ПараметрыПодключения.Свойство("UserName")
		И ЗначениеЗаполнено(ПараметрыПодключения.UserName) Тогда
		
		ИмяПользователя = ПараметрыПодключения.UserName;
		
		Если ПараметрыПодключения.Свойство("Password") Тогда
			ПарольПользователя = ПараметрыПодключения.Password;
		Иначе
			ПарольПользователя = Неопределено;
		КонецЕсли;
		
	Иначе
		ИмяПользователя = Неопределено;
		ПарольПользователя = Неопределено;
	КонецЕсли;
	
	АдресСервиса = ПараметрыПодключения.URL + "/ws/InterfaceVersion?wsdl";
	
	ПроксиВерсионирования = WSПрокси(АдресСервиса, "http://www.1c.ru/SaaS/1.0/WS",
		"InterfaceVersion", , ИмяПользователя, ПарольПользователя, 3);
		
	МассивXDTO = ПроксиВерсионирования.GetVersions(ИмяИнтерфейса);
	Если МассивXDTO = Неопределено Тогда
		Возврат Новый ФиксированныйМассив(Новый Массив);
	Иначе	
		Сериализатор = Новый СериализаторXDTO(ПроксиВерсионирования.ФабрикаXDTO);
		Возврат Новый ФиксированныйМассив(Сериализатор.ПрочитатьXDTO(МассивXDTO));
	КонецЕсли;
	
КонецФункции

Функция ПолучитьWSDL(Знач Адрес, Знач ИмяПользователя, Знач Пароль, Знач Таймаут)
	
	ПараметрыПолучения = Новый Структура;
	Если НЕ ПустаяСтрока(ИмяПользователя) Тогда
		ПараметрыПолучения.Вставить("Пользователь", ИмяПользователя);
		ПараметрыПолучения.Вставить("Пароль", Пароль);
	КонецЕсли;
	ПараметрыПолучения.Вставить("Таймаут", Таймаут);
	
	ОписаниеФайла = Неопределено;
	
	ПриСкачиванииФайлаНаСервере(Адрес, ПараметрыПолучения, ОписаниеФайла);
	
	Если НЕ ОписаниеФайла.Статус Тогда
		ВызватьИсключение(НСтр("ru = 'Ошибка получения файла описания web-сервиса:'") + Символы.ПС + ОписаниеФайла.СообщениеОбОшибке)
	КонецЕсли;
	
	// Попробуем создать WS определения на основе полученного файла
	Определения = Новый WSОпределения(ОписаниеФайла.Путь);
	Если Определения.Сервисы.Количество() = 0 Тогда
		ШаблонСообщения = НСтр("ru = 'Ошибка получения файла описания web-сервиса:
			|В полученном файле не содержится ни одного описания сервиса.
			|
			|Возможно, адрес файла описания указан неверно:
			|%1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Адрес);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	Определения = Неопределено;
	
	ДанныеФайла = Новый ДвоичныеДанные(ОписаниеФайла.Путь);
	
	Попытка
		УдалитьФайлы(ОписаниеФайла.Путь);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение WSDL'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат ДанныеФайла;
	
КонецФункции

Функция ИмяКоллекции(ПолноеИмя)
	
	ПозицияТочки = Найти(ПолноеИмя, ".");
	
	Если ПозицияТочки > 0 Тогда
		Возврат Лев(ПолноеИмя, ПозицияТочки - 1);
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

Процедура ПроверкаФиксированностиДанных(Данные, ДанныеВЗначенииФиксированныхТипов = Ложь)
	
	ТипДанных = ТипЗнч(Данные);
	
	Если ТипДанных = Тип("ХранилищеЗначения")
	 ИЛИ ТипДанных = Тип("ФиксированныйМассив")
	 ИЛИ ТипДанных = Тип("ФиксированнаяСтруктура")
	 ИЛИ ТипДанных = Тип("ФиксированноеСоответствие") Тогда
		
		Возврат;
	КонецЕсли;
	
	Если ДанныеВЗначенииФиксированныхТипов Тогда
		
		Если ТипДанных = Тип("Булево")
		 ИЛИ ТипДанных = Тип("Строка")
		 ИЛИ ТипДанных = Тип("Число")
		 ИЛИ ТипДанных = Тип("Дата")
		 ИЛИ ТипДанных = Тип("Неопределено")
		 ИЛИ ТипДанных = Тип("УникальныйИдентификатор")
		 ИЛИ ТипДанных = Тип("Null")
		 ИЛИ ТипДанных = Тип("Тип")
		 ИЛИ ТипДанных = Тип("ХранилищеЗначения")
		 ИЛИ ТипДанных = Тип("ОбщийМодуль")
		 ИЛИ ТипДанных = Тип("ОбъектМетаданных")
		 ИЛИ ТипДанных = Тип("ТипЗначенияXDTO")
		 ИЛИ ТипДанных = Тип("ТипОбъектаXDTO")
		 ИЛИ ЭтоСсылка(ТипДанных) Тогда
			
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Ошибка в функции ФиксированныеДанные общего модуля ОбщегоНазначения.
		           |Данные типа ""%1"" не могут быть зафиксированы.'"),
		Строка(ТипДанных) );
	
КонецПроцедуры

Процедура ДобавитьИсключенияПоискаСсылок(ИсключенияПоискаСсылок, МассивИсключений)
	Для Каждого ЭлементМассива Из МассивИсключений Цикл
		Если ТипЗнч(ЭлементМассива) = Тип("Строка") Тогда
			ЭлементМетаданные = Метаданные.НайтиПоПолномуИмени(ЭлементМассива);
		Иначе
			ЭлементМетаданные = ЭлементМассива;
		КонецЕсли;
		
		РодительМетаданные = ЭлементМетаданные.Родитель();
		
		Если ТипЗнч(РодительМетаданные) = Тип("ОбъектМетаданныхКонфигурация") Тогда
			// Если указан корневой объект метаданных (справочник, документ, регистр и т.п.):
			// - Добавление в исключения объекта метаданных целиком (всех ссылок, которые он может содержать).
			ИсключенияПоискаСсылок.Вставить(ЭлементМетаданные, "*");
			Продолжить;
		КонецЕсли;
		
		// Если указан конкретный реквизит объекта метаданных:
		ПутиКРеквизитам = ИсключенияПоискаСсылок[ЭлементМетаданные];
		Если ПутиКРеквизитам = "*" Тогда
			Продолжить; // - Пропуск, если весь объект метаданных уже исключен.
		КонецЕсли;
		
		// - Регистрация исключаемого реквизита объекта метаданных.
		ОтносительныйПутьКРеквизиту = ЭлементМетаданные.Имя;
		РодительРодителя = РодительМетаданные.Родитель();
		Пока ТипЗнч(РодительРодителя) <> Тип("ОбъектМетаданныхКонфигурация") Цикл
			ОтносительныйПутьКРеквизиту = РодительМетаданные.Имя + "." + ОтносительныйПутьКРеквизиту;
			РодительМетаданные = РодительРодителя;
			РодительРодителя   = РодительМетаданные.Родитель();
		КонецЦикла;
		
		Если ПутиКРеквизитам = Неопределено Тогда
			ПутиКРеквизитам = Новый Массив;
		КонецЕсли;
		
		ПутиКРеквизитам.Добавить(ОтносительныйПутьКРеквизиту);
		
		ИсключенияПоискаСсылок.Вставить(РодительМетаданные, ПутиКРеквизитам);
	КонецЦикла;
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в другие подсистемы

// Получить файл из Интернета по протоколу http(s), либо ftp и сохранить его во временный файл.
//
// Параметры:
//   URL                  - Строка - url файла в формате
//                                   [Протокол://]<Сервер>/<Путь к файлу на сервере>
//   ПараметрыПолучения   - Структура со свойствами
//     ПутьДляСохранения    - Строка - путь на сервере (включая имя файла), для сохранения скачанного файла
//     Пользователь         - Строка - пользователь от имени которого установлено соединение
//     Пароль               - Строка - пароль пользователя от которого установлено соединение
//     Порт                 - Число  - порт сервера с которым установлено соединение
//     ЗащищенноеСоединение - Булево - для случая http загрузки флаг указывает,
//                                     что соединение должно производиться через https
//     ПассивноеСоединение  - Булево - для случая ftp загрузки флаг указывает,
//                                     что соединение должно пассивным (или активным)
//   ВозвращаемоеЗначение - (выходной параметр)
//     Структура, со свойствами
//       Статус - Булево - ключ присутствует в структуре всегда, значения
//                         Истина - вызов функции успешно завершен
//                         Ложь   - вызов функции завершен неудачно
//       Путь   - Строка - путь к файлу на сервере, ключ используется только
//                         если статус Истина
//       СообщениеОбОшибке - Строка - сообщение об ошибке, если статус Ложь
//
Процедура ПриСкачиванииФайлаНаСервере(Знач Адрес, Знач ПараметрыПолучения, ВозвращаемоеЗначение)
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("ПолучениеФайловИзИнтернета");
		ВозвращаемоеЗначение = Модуль.СкачатьФайлНаСервере(Адрес, ПараметрыПолучения);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает разделение сеанса.
//
// Параметры:
// Использование - Булево - Использование разделителя ОбластьДанных в сеансе
// ОбластьДанных - Число - Значение разделителя ОбластьДанных
//
Процедура ПриУстановкеРазделенияСеанса(Знач Использование, Знач ОбластьДанных = Неопределено)
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		Модуль.УстановитьРазделениеСеанса(Использование, ОбластьДанных);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Параметры:
//  ЗначениеРазделителя - Значение разделителя текущей области данных. Возвращаемый параметр.
//
Процедура ПриПолученииЗначенияРазделителяСеанса(ЗначениеРазделителя)
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		ЗначениеРазделителя = Модуль.ЗначениеРазделителяСеанса();
	Иначе
		ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
	
КонецПроцедуры

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Параметры:
// ИспользованиеРазделителя - Булево - Истина разделение используется, иначе нет. Возвращаемый параметр.
// 
Процедура ПриПолученииИспользованияРазделителяСеанса(ИспользованиеРазделителя) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		ИспользованиеРазделителя = Модуль.ИспользованиеРазделителяСеанса();
	Иначе
		ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
	
КонецПроцедуры

// Конец СтандартныеПодсистемы